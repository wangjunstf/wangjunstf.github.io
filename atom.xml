<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>编程之禅</title>
  
  
  <link href="https://wangjunstf.github.io/atom.xml" rel="self"/>
  
  <link href="https://wangjunstf.github.io/"/>
  <updated>2025-01-16T10:45:49.523Z</updated>
  <id>https://wangjunstf.github.io/</id>
  
  <author>
    <name>编程之禅</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Common Lisp实践：建立单元测试框架</title>
    <link href="https://wangjunstf.github.io/2025/01/16/common-lisp-shi-jian-jian-li-dan-yuan-ce-shi-kuang-jia/"/>
    <id>https://wangjunstf.github.io/2025/01/16/common-lisp-shi-jian-jian-li-dan-yuan-ce-shi-kuang-jia/</id>
    <published>2025-01-16T10:44:23.000Z</published>
    <updated>2025-01-16T10:45:49.523Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;单元测试框架&lt;/strong&gt;是一种工具或库，用于帮助开发人员创建、组织、运行和报告代码的单元测试。&lt;br&gt;
&lt;strong&gt;单元测试&lt;/strong&gt;是指对软件系统中最小的可测试单元（通常是一个函数或方法）进行的验证测试。&lt;/p&gt;</summary>
    
    
    
    <category term="Lisp" scheme="https://wangjunstf.github.io/categories/Lisp/"/>
    
    
    <category term="Common Lisp" scheme="https://wangjunstf.github.io/tags/Common-Lisp/"/>
    
    <category term="单元测试" scheme="https://wangjunstf.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Common Lisp如何编写宏</title>
    <link href="https://wangjunstf.github.io/2025/01/16/common-lisp-ru-he-bian-xie-hong/"/>
    <id>https://wangjunstf.github.io/2025/01/16/common-lisp-ru-he-bian-xie-hong/</id>
    <published>2025-01-16T10:41:56.000Z</published>
    <updated>2025-01-16T10:43:32.701Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;一-宏展开期和运行期&quot;&gt;一 宏展开期和运行期&lt;/h2&gt;
&lt;p&gt;编写宏就是在编写那些将被编译器用来生成代码并随后编译的程序，只有当所有宏都被完全展开并且产生的代码被编译后，程序才可以实际运行。宏运行的时期被称为宏展开期(macro expansion time)，这和运行期(runtime)是不同的，宏展开期无法访问运行期的数据。&lt;/p&gt;</summary>
    
    
    
    <category term="Lisp" scheme="https://wangjunstf.github.io/categories/Lisp/"/>
    
    
    <category term="Common Lisp" scheme="https://wangjunstf.github.io/tags/Common-Lisp/"/>
    
    <category term="宏" scheme="https://wangjunstf.github.io/tags/%E5%AE%8F/"/>
    
  </entry>
  
  <entry>
    <title>解构Common Lisp宏：从基本语法到高级用法</title>
    <link href="https://wangjunstf.github.io/2025/01/16/jie-gou-common-lisp-hong-cong-ji-ben-yu-fa-dao-gao-ji-yong-fa/"/>
    <id>https://wangjunstf.github.io/2025/01/16/jie-gou-common-lisp-hong-cong-ji-ben-yu-fa-dao-gao-ji-yong-fa/</id>
    <published>2025-01-16T10:33:41.000Z</published>
    <updated>2025-01-16T10:39:21.127Z</updated>
    
    
    <summary type="html">&lt;p&gt;其余自Lisp的许多编程思想，从条件表达式到垃圾收集，都已经被吸取进其他语言，但Lisp的宏系统却始终使它保持了在语言风格上的独特性。Lisp的宏和大多数其他语言中的也叫宏的东西是完全不一样的，要完全认识Lisp中的宏系统，就需要重新看待它。&lt;/p&gt;</summary>
    
    
    
    <category term="Lisp" scheme="https://wangjunstf.github.io/categories/Lisp/"/>
    
    
    <category term="Common Lisp" scheme="https://wangjunstf.github.io/tags/Common-Lisp/"/>
    
    <category term="宏" scheme="https://wangjunstf.github.io/tags/%E5%AE%8F/"/>
    
    <category term="WHEN" scheme="https://wangjunstf.github.io/tags/WHEN/"/>
    
    <category term="COND" scheme="https://wangjunstf.github.io/tags/COND/"/>
    
    <category term="DO" scheme="https://wangjunstf.github.io/tags/DO/"/>
    
    <category term="DOLIST" scheme="https://wangjunstf.github.io/tags/DOLIST/"/>
    
    <category term="DOTIMES" scheme="https://wangjunstf.github.io/tags/DOTIMES/"/>
    
  </entry>
  
  <entry>
    <title>uiop-run-program 基本使用教程</title>
    <link href="https://wangjunstf.github.io/2025/01/16/uiop-run-program-ji-ben-shi-yong-jiao-cheng/"/>
    <id>https://wangjunstf.github.io/2025/01/16/uiop-run-program-ji-ben-shi-yong-jiao-cheng/</id>
    <published>2025-01-16T10:28:41.000Z</published>
    <updated>2025-01-16T10:39:38.970Z</updated>
    
    
    <summary type="html">&lt;p&gt;uiop:run-program 是 Common Lisp 中 UIOP (Utilities for Implementation- and OS- Portability) 库的一部分，用于在 Lisp 环境中执行外部程序和命令。这个函数提供了一个强大的接口来启动外部进程，并可以处理进程的输入、输出和退出状态。以下是一个关于如何使用 uiop:run-program 的入门教程：&lt;/p&gt;</summary>
    
    
    
    <category term="Lisp" scheme="https://wangjunstf.github.io/categories/Lisp/"/>
    
    
    <category term="Common Lisp" scheme="https://wangjunstf.github.io/tags/Common-Lisp/"/>
    
    <category term="uiop:run-program" scheme="https://wangjunstf.github.io/tags/uiop-run-program/"/>
    
  </entry>
  
  <entry>
    <title>Common Lisp 变量</title>
    <link href="https://wangjunstf.github.io/2025/01/16/common-lisp-bian-liang/"/>
    <id>https://wangjunstf.github.io/2025/01/16/common-lisp-bian-liang/</id>
    <published>2025-01-16T10:17:39.000Z</published>
    <updated>2025-01-16T10:25:54.570Z</updated>
    
    
    <summary type="html">&lt;p&gt;Common Lisp 支持两种类型的变量：词法变量(lexical)和动态变量(dynamic)&lt;/p&gt;
&lt;h2 id=&quot;一-变量的基础知识&quot;&gt;一 变量的基础知识&lt;/h2&gt;
&lt;p&gt;和常见的编程语言一样，Common Lisp中的变量是一些可以保存值的具名位置，但在Common Lisp 中，变量并不像在C++或Java那样带有确定的类型，一个变量可以保存任何类型的值，并且这些变量带有可用于运行期类型检查的类型信息。因此，Common Lisp是动态类型的，如果将某个并非数字的对象传给了+函数，那么Common Lisp将会报类型错误。&lt;/p&gt;</summary>
    
    
    
    <category term="Lisp" scheme="https://wangjunstf.github.io/categories/Lisp/"/>
    
    
    <category term="Common Lisp 变量" scheme="https://wangjunstf.github.io/tags/Common-Lisp-%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>The Rust Slice Type</title>
    <link href="https://wangjunstf.github.io/2023/01/28/the-rust-slice-type/"/>
    <id>https://wangjunstf.github.io/2023/01/28/the-rust-slice-type/</id>
    <published>2023-01-28T09:22:10.000Z</published>
    <updated>2024-10-01T14:17:56.613Z</updated>
    
    
    <summary type="html">&lt;h1&gt;The Rust Slice Type&lt;/h1&gt;
&lt;p&gt;Slice is a kind of data structure that store heap memory, it contains two fields, one representing the memory address and the other representing the length. Our most common string literal is a kind of slice.&lt;/p&gt;
&lt;p&gt;Slice let us reference a contiguous sequence of elements in a collection rather than the whole collection. A slice is a kind of reference, so it does not have ownership. And the slice ensures that the data it references is always valid.&lt;/p&gt;
&lt;h2 id=&quot;String-Slices&quot;&gt;String Slices&lt;/h2&gt;
&lt;p&gt;A string slice is a reference to part of a String, and it looks like this:&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;s&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;::&lt;span class=&quot;title function_ invoke__&quot;&gt;from&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;hello world&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;world&lt;/span&gt; = &amp;amp;s[&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://wangjunstf.github.io/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://wangjunstf.github.io/tags/Rust/"/>
    
    <category term="slice" scheme="https://wangjunstf.github.io/tags/slice/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++总结</title>
    <link href="https://wangjunstf.github.io/2023/01/12/effective-cpp/"/>
    <id>https://wangjunstf.github.io/2023/01/12/effective-cpp/</id>
    <published>2023-01-12T09:31:47.000Z</published>
    <updated>2024-10-01T14:17:56.609Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;导读&quot;&gt;&lt;strong&gt;导读&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;学习程序语言根本大法是一回事；学习如何以某种语言设计并实现高效程序则是令一会事。&lt;/p&gt;
&lt;p&gt;一组明智选择并精心设计的 classes，functions 和 templates 可使程序编写容易，直观，高效，并且远离错误。&lt;/p&gt;
&lt;h3 id=&quot;1-explicit&quot;&gt;&lt;strong&gt;1 explicit&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;default 构造函数：一个可被调用而不带任何实参的函数，这样的构造函数要不没有参数，要不就是每个参数都有缺省值。&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://wangjunstf.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C++" scheme="https://wangjunstf.github.io/tags/C/"/>
    
    <category term="Effective C++" scheme="https://wangjunstf.github.io/tags/Effective-C/"/>
    
  </entry>
  
  <entry>
    <title>ARM 移位指令</title>
    <link href="https://wangjunstf.github.io/2022/01/20/arm-yi-wei-zhi-ling/"/>
    <id>https://wangjunstf.github.io/2022/01/20/arm-yi-wei-zhi-ling/</id>
    <published>2022-01-20T03:36:23.000Z</published>
    <updated>2024-10-01T14:17:56.604Z</updated>
    
    
    <summary type="html">&lt;p&gt;移位指令是一组经常使用的指令，它包括移位指令（含算术移位指令，逻辑移位指令），循环移位指令（含带进位循环移位指令），其作用就是将目的操作数的所有位按操作符规定的方式移动指定的位数。&lt;/p&gt;
&lt;p&gt;ARM 中的移位指令如下：ASR, LSR, LSL, ROR和 RRX，直接写入目标寄存器中。&lt;/p&gt;</summary>
    
    
    
    <category term="ARM" scheme="https://wangjunstf.github.io/categories/ARM/"/>
    
    
    <category term="ARM" scheme="https://wangjunstf.github.io/tags/ARM/"/>
    
    <category term="移位指令" scheme="https://wangjunstf.github.io/tags/%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>用 Lisp 实现一个简单的数据库</title>
    <link href="https://wangjunstf.github.io/2021/11/16/yong-lisp-shi-xian-yi-ge-jian-dan-de-shu-ju-ku/"/>
    <id>https://wangjunstf.github.io/2021/11/16/yong-lisp-shi-xian-yi-ge-jian-dan-de-shu-ju-ku/</id>
    <published>2021-11-16T03:12:14.000Z</published>
    <updated>2024-10-01T14:17:56.617Z</updated>
    
    
    <summary type="html">&lt;p&gt;第一次认识 Lisp 是通过《黑客与画家》这本书，书中对 Lisp 赞不绝口，声称现在编程语言的发展也只是赶上了 1958 年的 Lisp 语言的水平。很多人就有疑问了，一个诞生于 1958 年的语言，计算机技术不是日新月异吗，为什么 Lisp 还没有过时？书中是这样说的，Lisp 是数学，数学是不会过时的。在书的作者 Paul Graham 的力荐下，对 Lisp 充满了浓厚的兴趣，就开始了 Lisp 的学习之旅。由于之前学习的繁忙，加上 Lisp 在&amp;quot;主流编程界&amp;quot; 好像并不受待见，我也没有一直持续学习，而是学习更加受欢迎的 C，Python 等语言，毕竟以后是要吃饭的嘛。在大学生涯的最后一段时间里，计算机基础知识学的越多，越发觉得编程语言的有趣之处，也明白了所有编程语言其实都是图灵等价的，即一个功能可以用任何编程语言实现，只不过是实现方式不一样。编程语言学的越多，越来越感受到 Lisp 本身设计的优雅，怀着一份好奇心，我又重新走进了 Lisp 的世界。&lt;/p&gt;</summary>
    
    
    
    <category term="Lisp" scheme="https://wangjunstf.github.io/categories/Lisp/"/>
    
    
    <category term="Lisp" scheme="https://wangjunstf.github.io/tags/Lisp/"/>
    
    <category term="数据结构" scheme="https://wangjunstf.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>用两个栈模拟一个队列</title>
    <link href="https://wangjunstf.github.io/2021/11/11/yong-liang-ge-zhan-mo-ni-yi-ge-dui-lie/"/>
    <id>https://wangjunstf.github.io/2021/11/11/yong-liang-ge-zhan-mo-ni-yi-ge-dui-lie/</id>
    <published>2021-11-11T09:39:40.000Z</published>
    <updated>2024-10-01T14:17:56.618Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;思路&quot;&gt;思路&lt;/h2&gt;
&lt;p&gt;本题是考察栈和队列的常见问题。要解答本题必须知道栈的队列的基本原理。&lt;/p&gt;
&lt;p&gt;栈：一种后进先出的数据结构，想象一个单车道，汽车一辆接一辆往里开，最先进入的在最里面，最后进入的在最外面，当需要出去的时候，最后进入的先出，最先进入的最后出去。符合类似进出原则的数据结构就叫做栈。 往栈中存入数据也叫压栈，取出数据也叫弹栈。&lt;/p&gt;
&lt;p&gt;队列：先进先出的数据结构。顾名思义，就像排队一样，最先进入在队头，后进入在队尾，队头先出队，队尾后出队。往队列中存入数据叫入队，往队列中取数据叫出队。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://wangjunstf.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="栈" scheme="https://wangjunstf.github.io/tags/%E6%A0%88/"/>
    
    <category term="队列" scheme="https://wangjunstf.github.io/tags/%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>快速幂算法</title>
    <link href="https://wangjunstf.github.io/2021/11/11/kuai-su-mi-suan-fa/"/>
    <id>https://wangjunstf.github.io/2021/11/11/kuai-su-mi-suan-fa/</id>
    <published>2021-11-10T16:51:08.000Z</published>
    <updated>2024-10-01T14:17:56.616Z</updated>
    
    
    <summary type="html">&lt;h1&gt;快速幂算法&lt;/h1&gt;
&lt;p&gt;看了不少题解，都讲的太复杂，而本人一直崇尚大道至简，于是萌生出写该题解的想法。&lt;/p&gt;
&lt;p&gt;快速幂算法可以在 O(lgn) 内完一个数的 n 次幂计算，即实现C语言库函数 &lt;code&gt;double pow(double x, double y)&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://wangjunstf.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="快速幂" scheme="https://wangjunstf.github.io/tags/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    
  </entry>
  
  <entry>
    <title>C/C++ 实现一个堆内存分配器(malloc/free)</title>
    <link href="https://wangjunstf.github.io/2021/11/09/c-yu-yan-shi-xian-yi-ge-dui-nei-cun-fen-pei-qi-malloc-free/"/>
    <id>https://wangjunstf.github.io/2021/11/09/c-yu-yan-shi-xian-yi-ge-dui-nei-cun-fen-pei-qi-malloc-free/</id>
    <published>2021-11-09T10:27:32.000Z</published>
    <updated>2024-10-01T14:17:56.607Z</updated>
    
    
    <summary type="html">&lt;p&gt;C 语言使用 malloc 分配内存，使用 free 释放内存。那么它们是怎么实现的呢？&lt;/p&gt;
&lt;p&gt;堆内存位于数据段(data) 和内存映射区之间，它有一个堆顶指针 brk，malloc 将堆内存分为空闲块和已分配块，使用链表来管理空闲块和已分配块。当堆内存用完时，使用系统调用 sbrk 增大 brk 来增大堆内存的大小。当要求分配的内存大小大于空闲块时，就将空闲块分成两份，一份分配给用户，剩下的内存作为一个空闲块。&lt;/p&gt;</summary>
    
    
    
    <category term="深入理解计算机系统" scheme="https://wangjunstf.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="堆内存" scheme="https://wangjunstf.github.io/tags/%E5%A0%86%E5%86%85%E5%AD%98/"/>
    
    <category term="内存分配器" scheme="https://wangjunstf.github.io/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/"/>
    
    <category term="malloc" scheme="https://wangjunstf.github.io/tags/malloc/"/>
    
    <category term="free" scheme="https://wangjunstf.github.io/tags/free/"/>
    
  </entry>
  
  <entry>
    <title>C/C++ 常见的内存错误</title>
    <link href="https://wangjunstf.github.io/2021/11/09/c-chang-jian-de-nei-cun-cuo-wu/"/>
    <id>https://wangjunstf.github.io/2021/11/09/c-chang-jian-de-nei-cun-cuo-wu/</id>
    <published>2021-11-09T10:09:58.000Z</published>
    <updated>2024-10-01T14:17:56.605Z</updated>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;
&lt;h3 id=&quot;间接引用坏指针&quot;&gt;间接引用坏指针&lt;/h3&gt;
&lt;p&gt;使用以下代码向 val 变量写入数据&lt;/p&gt;
&lt;figure class=&quot;highlight c&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;scanf&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;%d&amp;quot;&lt;/span&gt;,&amp;amp;val);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="深入理解计算机系统" scheme="https://wangjunstf.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="C" scheme="https://wangjunstf.github.io/tags/C/"/>
    
    <category term="CPP" scheme="https://wangjunstf.github.io/tags/CPP/"/>
    
    <category term="常见内存错误" scheme="https://wangjunstf.github.io/tags/%E5%B8%B8%E8%A7%81%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF/"/>
    
  </entry>
  
  <entry>
    <title>垃圾回收的基本原理</title>
    <link href="https://wangjunstf.github.io/2021/11/09/la-ji-hui-shou-de-ji-ben-yuan-li/"/>
    <id>https://wangjunstf.github.io/2021/11/09/la-ji-hui-shou-de-ji-ben-yuan-li/</id>
    <published>2021-11-09T10:07:09.000Z</published>
    <updated>2024-10-01T14:17:56.614Z</updated>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;
&lt;p&gt;对于像 maclloc 这样的显式分配器，应用通过调用 malloc 和 free 来分配和释放堆块，应用要负责释放所有不再需要的已分配块。&lt;/p&gt;
&lt;p&gt;不能及时释放内存堆块可能造成严重的内存错误，例如：内存泄漏，如下列代码所示：&lt;/p&gt;</summary>
    
    
    
    <category term="深入理解计算机系统" scheme="https://wangjunstf.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="垃圾回收" scheme="https://wangjunstf.github.io/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
    <category term="标记清除法" scheme="https://wangjunstf.github.io/tags/%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux 虚拟内存系统, 内存映射, fork, execve, malloc, free 动态内存分配与释放</title>
    <link href="https://wangjunstf.github.io/2021/11/09/linux-xu-ni-nei-cun-xi-tong-nei-cun-ying-she-fork-execve-malloc-free-dong-tai-nei-cun-fen-pei-yu-shi-fang/"/>
    <id>https://wangjunstf.github.io/2021/11/09/linux-xu-ni-nei-cun-xi-tong-nei-cun-ying-she-fork-execve-malloc-free-dong-tai-nei-cun-fen-pei-yu-shi-fang/</id>
    <published>2021-11-09T10:02:08.000Z</published>
    <updated>2024-10-01T14:17:56.611Z</updated>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;
&lt;p&gt;Linux 为每个进程维护一个单独的虚拟地址空间，如下图所示。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核虚拟内存包含内核中的代码和数据结构。&lt;/li&gt;
&lt;li&gt;内核虚拟内存的某些区域被映射到所有进程共享的物理页面，例如每个进程都共享内核的代码和全局数据结构。&lt;/li&gt;
&lt;li&gt;Linux 也将一组连续的虚拟页面(大小等于系统中 DRAM 的总量)映射到相应的一组连续的物理页面。例如：访问页表，或对设备执行IO操作，这些设备被映射到特定物理内存位置时。&lt;/li&gt;
&lt;li&gt;内核虚拟内存的其它区域包含每个进程的独有数据，例如页表，内核在进程的上下文中执行代码时使用的栈，以及记录虚拟地址空间当前组织的各种数据结构。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="深入理解计算机系统" scheme="https://wangjunstf.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="动态内存" scheme="https://wangjunstf.github.io/tags/%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/"/>
    
    <category term="Linux" scheme="https://wangjunstf.github.io/tags/Linux/"/>
    
    <category term="虚拟内存" scheme="https://wangjunstf.github.io/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
    <category term="内存映射" scheme="https://wangjunstf.github.io/tags/%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84/"/>
    
    <category term="fork" scheme="https://wangjunstf.github.io/tags/fork/"/>
    
    <category term="execve" scheme="https://wangjunstf.github.io/tags/execve/"/>
    
  </entry>
  
  <entry>
    <title>虚拟内存的作用，虚拟地址，页表，TLB，缓存原理</title>
    <link href="https://wangjunstf.github.io/2021/11/09/xu-ni-nei-cun-de-zuo-yong-xu-ni-di-zhi-ye-biao-tlb-huan-cun-yuan-li/"/>
    <id>https://wangjunstf.github.io/2021/11/09/xu-ni-nei-cun-de-zuo-yong-xu-ni-di-zhi-ye-biao-tlb-huan-cun-yuan-li/</id>
    <published>2021-11-09T09:55:22.000Z</published>
    <updated>2024-10-01T14:17:56.618Z</updated>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;
&lt;h2 id=&quot;9-1-物理地址和虚拟地址&quot;&gt;9.1 物理地址和虚拟地址&lt;/h2&gt;
&lt;p&gt;计算机系统的主存是由 M 个连续的字节大小的单元组成的数组。每个字节都有一个唯一的物理地址，地址范围从 0 到 M-1。计算机使用内存最自然的方式是使用物理地址，我们将这种方式称为物理寻址。&lt;/p&gt;
&lt;p&gt;CPU 向内存发送一个地址，内存将该地址开始的四个字节信息传送到 CPU 中的一个 4字节寄存器。&lt;/p&gt;</summary>
    
    
    
    <category term="深入理解计算机系统" scheme="https://wangjunstf.github.io/categories/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="虚拟内存" scheme="https://wangjunstf.github.io/tags/%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98/"/>
    
    <category term="虚拟地址" scheme="https://wangjunstf.github.io/tags/%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80/"/>
    
    <category term="页表" scheme="https://wangjunstf.github.io/tags/%E9%A1%B5%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>解决 hexo 博客在 chrome 下无法正常显示图片的问题</title>
    <link href="https://wangjunstf.github.io/2021/11/05/jie-jue-hexo-bo-ke-zai-chrome-xia-wu-fa-zheng-chang-xian-shi-tu-pian-de-wen-ti/"/>
    <id>https://wangjunstf.github.io/2021/11/05/jie-jue-hexo-bo-ke-zai-chrome-xia-wu-fa-zheng-chang-xian-shi-tu-pian-de-wen-ti/</id>
    <published>2021-11-05T12:09:05.000Z</published>
    <updated>2024-10-01T14:17:56.618Z</updated>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;
&lt;h2 id=&quot;出现的问题&quot;&gt;出现的问题&lt;/h2&gt;
&lt;p&gt;最近发现一个奇怪的问题， hexo 发的博客图片 在 Google Chrome 下无法正常显示，但在 Safari 和 FireFox 下确可以正常显示。&lt;/p&gt;</summary>
    
    
    
    <category term="疑难杂症" scheme="https://wangjunstf.github.io/categories/%E7%96%91%E9%9A%BE%E6%9D%82%E7%97%87/"/>
    
    
    <category term="chrome" scheme="https://wangjunstf.github.io/tags/chrome/"/>
    
    <category term="hexo" scheme="https://wangjunstf.github.io/tags/hexo/"/>
    
    <category term="next主题" scheme="https://wangjunstf.github.io/tags/next%E4%B8%BB%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Parallels Desktop 最小安装 CentOS 7</title>
    <link href="https://wangjunstf.github.io/2021/11/05/parallels-desktop-zui-xiao-an-zhuang-centos-7/"/>
    <id>https://wangjunstf.github.io/2021/11/05/parallels-desktop-zui-xiao-an-zhuang-centos-7/</id>
    <published>2021-11-05T09:36:45.000Z</published>
    <updated>2024-10-01T14:17:56.611Z</updated>
    
    
    <summary type="html">&lt;meta name=&quot;referrer&quot; content=&quot;no-referrer&quot;/&gt;
&lt;h2 id=&quot;镜像文件下载&quot;&gt;镜像文件下载&lt;/h2&gt;
&lt;p&gt;下载地址：&lt;a href=&quot;http://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/&quot;&gt;http://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;BT种子：&lt;a href=&quot;http://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/CentOS-7-x86_64-DVD-2009.torrent&quot;&gt;http://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/CentOS-7-x86_64-DVD-2009.torrent&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://wangjunstf.github.io/categories/Linux/"/>
    
    
    <category term="CentOS7" scheme="https://wangjunstf.github.io/tags/CentOS7/"/>
    
  </entry>
  
  <entry>
    <title>快速排序的变种——快速选择算法</title>
    <link href="https://wangjunstf.github.io/2021/10/24/kuai-su-pai-xu-de-bian-chong-kuai-su-xuan-ze-suan-fa/"/>
    <id>https://wangjunstf.github.io/2021/10/24/kuai-su-pai-xu-de-bian-chong-kuai-su-xuan-ze-suan-fa/</id>
    <published>2021-10-24T09:58:56.000Z</published>
    <updated>2024-10-01T14:17:56.616Z</updated>
    
    
    <summary type="html">&lt;h1&gt;快速排序的变种——快速选择算法&lt;/h1&gt;
&lt;p&gt;给出一个数组，例如[1,4,2,6,8,3]，现在要求出第 k 大的数字，即将数组从大到小排列，选择第k个数。用什么算法更快找到这个数？&lt;/p&gt;
&lt;p&gt;最容易想到的就是先将数组排序，就可以很容易找到第 k 大的数字。就算用快速排序，时间复杂度为 O(nlgn)。有没有更快的算法？&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="https://wangjunstf.github.io/categories/LeetCode/"/>
    
    
    <category term="快速排序" scheme="https://wangjunstf.github.io/tags/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    
    <category term="快速选择" scheme="https://wangjunstf.github.io/tags/%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9/"/>
    
  </entry>
  
  <entry>
    <title>C++ 智能指针需要注意的点</title>
    <link href="https://wangjunstf.github.io/2021/10/24/c-zhi-neng-zhi-zhen-xu-yao-zhu-yi-de-dian/"/>
    <id>https://wangjunstf.github.io/2021/10/24/c-zhi-neng-zhi-zhen-xu-yao-zhu-yi-de-dian/</id>
    <published>2021-10-24T03:10:21.000Z</published>
    <updated>2024-10-01T14:17:56.607Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++11提供了三种智能指针：std::shared_ptr, std::unique_ptr, std::weak_ptr，使用时需添加头&lt;code&gt;&amp;lt;memory&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;h2 id=&quot;智能指针与普通指针混用&quot;&gt;智能指针与普通指针混用&lt;/h2&gt;</summary>
    
    
    
    <category term="CPP" scheme="https://wangjunstf.github.io/categories/CPP/"/>
    
    
    <category term="CPP" scheme="https://wangjunstf.github.io/tags/CPP/"/>
    
    <category term="指针指针" scheme="https://wangjunstf.github.io/tags/%E6%8C%87%E9%92%88%E6%8C%87%E9%92%88/"/>
    
    <category term="weak_ptr" scheme="https://wangjunstf.github.io/tags/weak-ptr/"/>
    
  </entry>
  
</feed>
