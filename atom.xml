<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>编程之禅</title>
  
  
  <link href="https://wangjunstf.github.io/atom.xml" rel="self"/>
  
  <link href="https://wangjunstf.github.io/"/>
  <updated>2025-09-30T12:56:50.437Z</updated>
  <id>https://wangjunstf.github.io/</id>
  
  <author>
    <name>编程之禅</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++中 bitset 用法总结</title>
    <link href="https://wangjunstf.github.io/2025/09/30/cpp-zhong-bitset-yong-fa-zong-jie/"/>
    <id>https://wangjunstf.github.io/2025/09/30/cpp-zhong-bitset-yong-fa-zong-jie/</id>
    <published>2025-09-30T12:53:22.000Z</published>
    <updated>2025-09-30T12:56:50.437Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;bitset&lt;/code&gt; 是 C++ 标准库中的固定大小位集合容器，用于高效处理二进制位操作。&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://wangjunstf.github.io/categories/cpp/"/>
    
    
    <category term="bitset" scheme="https://wangjunstf.github.io/tags/bitset/"/>
    
  </entry>
  
  <entry>
    <title>C++中short, int, long, long long以及对应unsigned的范围</title>
    <link href="https://wangjunstf.github.io/2025/09/26/cpp-zhong-short-int-long-long-long-yi-ji-dui-ying-unsigned-de-fan-wei/"/>
    <id>https://wangjunstf.github.io/2025/09/26/cpp-zhong-short-int-long-long-long-yi-ji-dui-ying-unsigned-de-fan-wei/</id>
    <published>2025-09-26T15:10:54.000Z</published>
    <updated>2025-09-27T01:34:49.860Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 C++ 中，&lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;类型的大小由​&lt;strong&gt;​编译器和目标平台共同决定&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://wangjunstf.github.io/categories/cpp/"/>
    
    
    <category term="cpp" scheme="https://wangjunstf.github.io/tags/cpp/"/>
    
    <category term="short" scheme="https://wangjunstf.github.io/tags/short/"/>
    
    <category term="int" scheme="https://wangjunstf.github.io/tags/int/"/>
    
    <category term="long" scheme="https://wangjunstf.github.io/tags/long/"/>
    
    <category term="long long" scheme="https://wangjunstf.github.io/tags/long-long/"/>
    
  </entry>
  
  <entry>
    <title>原码 反码 补码的原理</title>
    <link href="https://wangjunstf.github.io/2025/09/26/yuan-ma-fan-ma-bu-ma-de-yuan-li/"/>
    <id>https://wangjunstf.github.io/2025/09/26/yuan-ma-fan-ma-bu-ma-de-yuan-li/</id>
    <published>2025-09-26T13:33:28.000Z</published>
    <updated>2025-09-26T13:55:44.390Z</updated>
    
    
    <summary type="html">&lt;p&gt;CPU中以二进制来表示和计算数据，为了进行算数运算，先后出现了以下三种编码：原码，反码和补码。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://wangjunstf.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="原码" scheme="https://wangjunstf.github.io/tags/%E5%8E%9F%E7%A0%81/"/>
    
    <category term="反码" scheme="https://wangjunstf.github.io/tags/%E5%8F%8D%E7%A0%81/"/>
    
    <category term="补码" scheme="https://wangjunstf.github.io/tags/%E8%A1%A5%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Emacs 配置C++开发环境</title>
    <link href="https://wangjunstf.github.io/2025/09/23/emacs-pei-zhi-cpp-kai-fa-huan-jing/"/>
    <id>https://wangjunstf.github.io/2025/09/23/emacs-pei-zhi-cpp-kai-fa-huan-jing/</id>
    <published>2025-09-23T09:06:50.000Z</published>
    <updated>2025-09-23T09:09:34.858Z</updated>
    
    
    <summary type="html">&lt;p&gt;Emacs 入门和命令查询：&lt;a href=&quot;https://wangjunstf.github.io/2025/09/22/emacs-ru-men-jiao-cheng/&quot;&gt;Emacs 入门教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;熟悉了Emacs的基本使用之后，我们现在来尝试使用 Emacs 配置一个比较现代、实用的C++开发环境（包括代码补全、跳转、语法检查、调试等）&lt;/p&gt;</summary>
    
    
    
    <category term="Emacs" scheme="https://wangjunstf.github.io/categories/Emacs/"/>
    
    
    <category term="Emacs" scheme="https://wangjunstf.github.io/tags/Emacs/"/>
    
  </entry>
  
  <entry>
    <title>Emacs 入门教程</title>
    <link href="https://wangjunstf.github.io/2025/09/22/emacs-ru-men-jiao-cheng/"/>
    <id>https://wangjunstf.github.io/2025/09/22/emacs-ru-men-jiao-cheng/</id>
    <published>2025-09-22T10:17:40.000Z</published>
    <updated>2025-09-23T09:10:44.965Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Emacs-命令格式&quot;&gt;Emacs 命令格式&lt;/h2&gt;
&lt;p&gt;Emacs 按键命令通常包含 CONTROL 键（有时候以CTRL标识）和 META 键（有时以ALT标识）。Emacs 中的命令以以下方式给出&lt;br&gt;
&lt;code&gt;c-&amp;lt;chr&amp;gt;&lt;/code&gt;  表示当输入字符&lt;code&gt;&amp;lt;chr&amp;gt;&lt;/code&gt;时按住 CONTROL 键，因此&lt;code&gt;C-f&lt;/code&gt;表示：按住 CONTROL 键再输入 f。&lt;/p&gt;</summary>
    
    
    
    <category term="Emacs" scheme="https://wangjunstf.github.io/categories/Emacs/"/>
    
    
    <category term="Emacs" scheme="https://wangjunstf.github.io/tags/Emacs/"/>
    
  </entry>
  
  <entry>
    <title>业余无线电——相对值单位</title>
    <link href="https://wangjunstf.github.io/2025/09/18/ye-yu-wu-xian-dian-xiang-dui-zhi-dan-wei/"/>
    <id>https://wangjunstf.github.io/2025/09/18/ye-yu-wu-xian-dian-xiang-dui-zhi-dan-wei/</id>
    <published>2025-09-18T06:31:59.000Z</published>
    <updated>2025-09-18T06:49:10.747Z</updated>
    
    
    <summary type="html">&lt;p&gt;本质上就是&lt;strong&gt;用对数（log）来表示比值&lt;/strong&gt;，这样方便比较非常大的功率或电压范围。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;绝对值&lt;/strong&gt;：直接告诉你功率有多大，例如 1 W、5 W、50 W。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;相对值&lt;/strong&gt;：告诉你和某个参考值相比有多大，例如比 1 W 大 10 倍、或小 10 倍。&lt;br&gt;
在无线电里，功率、电压、场强常常跨越 &lt;strong&gt;10⁶～10¹² 倍&lt;/strong&gt;的范围，直接写数字会非常大，所以大家用&lt;strong&gt;对数刻度&lt;/strong&gt;（dB）来表达。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="无线电" scheme="https://wangjunstf.github.io/categories/%E6%97%A0%E7%BA%BF%E7%94%B5/"/>
    
    
    <category term="dB" scheme="https://wangjunstf.github.io/tags/dB/"/>
    
    <category term="dBm" scheme="https://wangjunstf.github.io/tags/dBm/"/>
    
    <category term="dBW" scheme="https://wangjunstf.github.io/tags/dBW/"/>
    
    <category term="dBi" scheme="https://wangjunstf.github.io/tags/dBi/"/>
    
    <category term="dBd" scheme="https://wangjunstf.github.io/tags/dBd/"/>
    
    <category term="dBc" scheme="https://wangjunstf.github.io/tags/dBc/"/>
    
  </entry>
  
  <entry>
    <title>C++中auto类型推导的常见用法</title>
    <link href="https://wangjunstf.github.io/2025/09/18/cpp-zhong-auto-lei-xing-tui-dao-de-chang-jian-yong-fa/"/>
    <id>https://wangjunstf.github.io/2025/09/18/cpp-zhong-auto-lei-xing-tui-dao-de-chang-jian-yong-fa/</id>
    <published>2025-09-18T01:56:16.000Z</published>
    <updated>2025-09-27T01:34:51.956Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++ 中的 &lt;code&gt;auto&lt;/code&gt; 关键字是一个强大的类型推导工具，它能显著简化代码并提高可读性。下面我将为你详细解析它的各种用法、注意事项和最佳实践。&lt;/p&gt;
&lt;h3 id=&quot;🧠-一、auto-的基本概念&quot;&gt;🧠 一、auto 的基本概念&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt; 是 C++11 标准引入的关键字，用于在声明变量时​&lt;strong&gt;​自动推导变量的类型​&lt;/strong&gt;​，推导依据是变量的初始化表达式。&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://wangjunstf.github.io/categories/cpp/"/>
    
    
    <category term="cpp" scheme="https://wangjunstf.github.io/tags/cpp/"/>
    
    <category term="auto" scheme="https://wangjunstf.github.io/tags/auto/"/>
    
  </entry>
  
  <entry>
    <title>【算法解析】巧用哈希表与组合公式：高效统计数组中相同数对的数量</title>
    <link href="https://wangjunstf.github.io/2025/09/18/qiao-yong-ha-xi-biao-yu-zu-he-gong-shi-gao-xiao-tong-ji-shu-zu-zhong-xiang-tong-shu-dui-de-shu-liang/"/>
    <id>https://wangjunstf.github.io/2025/09/18/qiao-yong-ha-xi-biao-yu-zu-he-gong-shi-gao-xiao-tong-ji-shu-zu-zhong-xiang-tong-shu-dui-de-shu-liang/</id>
    <published>2025-09-18T00:33:06.000Z</published>
    <updated>2025-09-18T05:16:32.410Z</updated>
    
    
    <summary type="html">&lt;p&gt;现有以下题目：&lt;a href=&quot;https://leetcode.cn/problems/number-of-good-pairs/&quot;&gt;1512. 好数对的数目&lt;/a&gt;&lt;br&gt;
现有一个整数数组，要求统计数组中满足条件的索引对 (i, j)（其中 i &amp;lt; j 且 nums[i] = nums[j]）数量。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://wangjunstf.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://wangjunstf.github.io/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
    <category term="哈希表" scheme="https://wangjunstf.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="组合公式" scheme="https://wangjunstf.github.io/tags/%E7%BB%84%E5%90%88%E5%85%AC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>求两数最小公倍数的通解（通用方法解法）</title>
    <link href="https://wangjunstf.github.io/2025/09/17/qiu-liang-shu-zui-xiao-gong-bei-shu-de-tong-jie/"/>
    <id>https://wangjunstf.github.io/2025/09/17/qiu-liang-shu-zui-xiao-gong-bei-shu-de-tong-jie/</id>
    <published>2025-09-17T01:30:54.000Z</published>
    <updated>2025-09-18T02:06:12.358Z</updated>
    
    
    <summary type="html">&lt;p&gt;求两个数&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;的最小公倍数，最常用和最有效的方法是利用它们与最大公约数（Greatest Common Divisor, GCD）之间的关系。&lt;/p&gt;
&lt;h2 id=&quot;核心公式&quot;&gt;核心公式&lt;/h2&gt;
&lt;p&gt;两个数的最小公倍数等于这两个数的乘积除以它们的最大公约数。用数学公式表示为：&lt;br&gt;
$$LCM(a,b)=&#92;frac{|a * b|}{GCD(a,b)}$$&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://wangjunstf.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://wangjunstf.github.io/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
    <category term="最小公倍数" scheme="https://wangjunstf.github.io/tags/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"/>
    
    <category term="LCM" scheme="https://wangjunstf.github.io/tags/LCM/"/>
    
    <category term="GCD" scheme="https://wangjunstf.github.io/tags/GCD/"/>
    
  </entry>
  
  <entry>
    <title>C++中auto与decltype的区别</title>
    <link href="https://wangjunstf.github.io/2025/09/12/cpp-zhong-auto-yu-decltype-de-qu-bie/"/>
    <id>https://wangjunstf.github.io/2025/09/12/cpp-zhong-auto-yu-decltype-de-qu-bie/</id>
    <published>2025-09-12T14:40:38.000Z</published>
    <updated>2025-09-27T01:34:53.496Z</updated>
    
    
    <summary type="html">&lt;p&gt;理解 &lt;code&gt;decltype&lt;/code&gt; 和 &lt;code&gt;auto&lt;/code&gt; 的区别对掌握现代 C++ 编程很重要。它们虽然都用于类型推导，但&lt;strong&gt;规则和初衷不同&lt;/strong&gt;。下面这个表格汇总了它们的核心区别，帮你快速把握要点。&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://wangjunstf.github.io/categories/cpp/"/>
    
    
    <category term="cpp" scheme="https://wangjunstf.github.io/tags/cpp/"/>
    
    <category term="auto" scheme="https://wangjunstf.github.io/tags/auto/"/>
    
    <category term="decltype" scheme="https://wangjunstf.github.io/tags/decltype/"/>
    
  </entry>
  
  <entry>
    <title>导数的概念和应用</title>
    <link href="https://wangjunstf.github.io/2025/01/19/dao-shu-de-gai-nian-he-ying-yong/"/>
    <id>https://wangjunstf.github.io/2025/01/19/dao-shu-de-gai-nian-he-ying-yong/</id>
    <published>2025-01-19T15:15:16.000Z</published>
    <updated>2025-01-19T15:32:50.925Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;一-什么是导数&quot;&gt;一 什么是导数&lt;/h2&gt;
&lt;p&gt;导数是微积分中的一个重要概念，它描述了一个函数$f(x)$在某一点的变化率或斜率，斜率越大，函数图像越陡，$x$增加相同的数值，$f(x)$变化更快。&lt;/p&gt;
&lt;p&gt;如果一个函数$f(x)$在某一点$x=a$可导，那么导数就是$f(x)$在$x=a$这一点的变化率。从几何上看，导数可以看作是曲线$y=f(x)$在点$a,f(a)$处的切线的斜率。&lt;/p&gt;</summary>
    
    
    
    <category term="Math" scheme="https://wangjunstf.github.io/categories/Math/"/>
    
    
    <category term="导数" scheme="https://wangjunstf.github.io/tags/%E5%AF%BC%E6%95%B0/"/>
    
    <category term="导数法则" scheme="https://wangjunstf.github.io/tags/%E5%AF%BC%E6%95%B0%E6%B3%95%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>Common Lisp实践：建立单元测试框架</title>
    <link href="https://wangjunstf.github.io/2025/01/16/common-lisp-shi-jian-jian-li-dan-yuan-ce-shi-kuang-jia/"/>
    <id>https://wangjunstf.github.io/2025/01/16/common-lisp-shi-jian-jian-li-dan-yuan-ce-shi-kuang-jia/</id>
    <published>2025-01-16T10:44:23.000Z</published>
    <updated>2025-01-16T10:45:49.523Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;单元测试框架&lt;/strong&gt;是一种工具或库，用于帮助开发人员创建、组织、运行和报告代码的单元测试。&lt;br&gt;
&lt;strong&gt;单元测试&lt;/strong&gt;是指对软件系统中最小的可测试单元（通常是一个函数或方法）进行的验证测试。&lt;/p&gt;</summary>
    
    
    
    <category term="Lisp" scheme="https://wangjunstf.github.io/categories/Lisp/"/>
    
    
    <category term="Common Lisp" scheme="https://wangjunstf.github.io/tags/Common-Lisp/"/>
    
    <category term="单元测试" scheme="https://wangjunstf.github.io/tags/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Common Lisp如何编写宏</title>
    <link href="https://wangjunstf.github.io/2025/01/16/common-lisp-ru-he-bian-xie-hong/"/>
    <id>https://wangjunstf.github.io/2025/01/16/common-lisp-ru-he-bian-xie-hong/</id>
    <published>2025-01-16T10:41:56.000Z</published>
    <updated>2025-01-16T10:43:32.701Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;一-宏展开期和运行期&quot;&gt;一 宏展开期和运行期&lt;/h2&gt;
&lt;p&gt;编写宏就是在编写那些将被编译器用来生成代码并随后编译的程序，只有当所有宏都被完全展开并且产生的代码被编译后，程序才可以实际运行。宏运行的时期被称为宏展开期(macro expansion time)，这和运行期(runtime)是不同的，宏展开期无法访问运行期的数据。&lt;/p&gt;</summary>
    
    
    
    <category term="Lisp" scheme="https://wangjunstf.github.io/categories/Lisp/"/>
    
    
    <category term="Common Lisp" scheme="https://wangjunstf.github.io/tags/Common-Lisp/"/>
    
    <category term="宏" scheme="https://wangjunstf.github.io/tags/%E5%AE%8F/"/>
    
  </entry>
  
  <entry>
    <title>解构Common Lisp宏：从基本语法到高级用法</title>
    <link href="https://wangjunstf.github.io/2025/01/16/jie-gou-common-lisp-hong-cong-ji-ben-yu-fa-dao-gao-ji-yong-fa/"/>
    <id>https://wangjunstf.github.io/2025/01/16/jie-gou-common-lisp-hong-cong-ji-ben-yu-fa-dao-gao-ji-yong-fa/</id>
    <published>2025-01-16T10:33:41.000Z</published>
    <updated>2025-01-16T10:39:21.127Z</updated>
    
    
    <summary type="html">&lt;p&gt;其余自Lisp的许多编程思想，从条件表达式到垃圾收集，都已经被吸取进其他语言，但Lisp的宏系统却始终使它保持了在语言风格上的独特性。Lisp的宏和大多数其他语言中的也叫宏的东西是完全不一样的，要完全认识Lisp中的宏系统，就需要重新看待它。&lt;/p&gt;</summary>
    
    
    
    <category term="Lisp" scheme="https://wangjunstf.github.io/categories/Lisp/"/>
    
    
    <category term="Common Lisp" scheme="https://wangjunstf.github.io/tags/Common-Lisp/"/>
    
    <category term="宏" scheme="https://wangjunstf.github.io/tags/%E5%AE%8F/"/>
    
    <category term="WHEN" scheme="https://wangjunstf.github.io/tags/WHEN/"/>
    
    <category term="COND" scheme="https://wangjunstf.github.io/tags/COND/"/>
    
    <category term="DO" scheme="https://wangjunstf.github.io/tags/DO/"/>
    
    <category term="DOLIST" scheme="https://wangjunstf.github.io/tags/DOLIST/"/>
    
    <category term="DOTIMES" scheme="https://wangjunstf.github.io/tags/DOTIMES/"/>
    
  </entry>
  
  <entry>
    <title>uiop-run-program 基本使用教程</title>
    <link href="https://wangjunstf.github.io/2025/01/16/uiop-run-program-ji-ben-shi-yong-jiao-cheng/"/>
    <id>https://wangjunstf.github.io/2025/01/16/uiop-run-program-ji-ben-shi-yong-jiao-cheng/</id>
    <published>2025-01-16T10:28:41.000Z</published>
    <updated>2025-01-16T10:39:38.970Z</updated>
    
    
    <summary type="html">&lt;p&gt;uiop:run-program 是 Common Lisp 中 UIOP (Utilities for Implementation- and OS- Portability) 库的一部分，用于在 Lisp 环境中执行外部程序和命令。这个函数提供了一个强大的接口来启动外部进程，并可以处理进程的输入、输出和退出状态。以下是一个关于如何使用 uiop:run-program 的入门教程：&lt;/p&gt;</summary>
    
    
    
    <category term="Lisp" scheme="https://wangjunstf.github.io/categories/Lisp/"/>
    
    
    <category term="Common Lisp" scheme="https://wangjunstf.github.io/tags/Common-Lisp/"/>
    
    <category term="uiop:run-program" scheme="https://wangjunstf.github.io/tags/uiop-run-program/"/>
    
  </entry>
  
  <entry>
    <title>Common Lisp 变量</title>
    <link href="https://wangjunstf.github.io/2025/01/16/common-lisp-bian-liang/"/>
    <id>https://wangjunstf.github.io/2025/01/16/common-lisp-bian-liang/</id>
    <published>2025-01-16T10:17:39.000Z</published>
    <updated>2025-01-16T10:25:54.570Z</updated>
    
    
    <summary type="html">&lt;p&gt;Common Lisp 支持两种类型的变量：词法变量(lexical)和动态变量(dynamic)&lt;/p&gt;
&lt;h2 id=&quot;一-变量的基础知识&quot;&gt;一 变量的基础知识&lt;/h2&gt;
&lt;p&gt;和常见的编程语言一样，Common Lisp中的变量是一些可以保存值的具名位置，但在Common Lisp 中，变量并不像在C++或Java那样带有确定的类型，一个变量可以保存任何类型的值，并且这些变量带有可用于运行期类型检查的类型信息。因此，Common Lisp是动态类型的，如果将某个并非数字的对象传给了+函数，那么Common Lisp将会报类型错误。&lt;/p&gt;</summary>
    
    
    
    <category term="Lisp" scheme="https://wangjunstf.github.io/categories/Lisp/"/>
    
    
    <category term="Common Lisp 变量" scheme="https://wangjunstf.github.io/tags/Common-Lisp-%E5%8F%98%E9%87%8F/"/>
    
  </entry>
  
  <entry>
    <title>The Rust Slice Type</title>
    <link href="https://wangjunstf.github.io/2023/01/28/the-rust-slice-type/"/>
    <id>https://wangjunstf.github.io/2023/01/28/the-rust-slice-type/</id>
    <published>2023-01-28T09:22:10.000Z</published>
    <updated>2024-10-01T14:17:56.613Z</updated>
    
    
    <summary type="html">&lt;h1&gt;The Rust Slice Type&lt;/h1&gt;
&lt;p&gt;Slice is a kind of data structure that store heap memory, it contains two fields, one representing the memory address and the other representing the length. Our most common string literal is a kind of slice.&lt;/p&gt;
&lt;p&gt;Slice let us reference a contiguous sequence of elements in a collection rather than the whole collection. A slice is a kind of reference, so it does not have ownership. And the slice ensures that the data it references is always valid.&lt;/p&gt;
&lt;h2 id=&quot;String-Slices&quot;&gt;String Slices&lt;/h2&gt;
&lt;p&gt;A string slice is a reference to part of a String, and it looks like this:&lt;/p&gt;
&lt;figure class=&quot;highlight rust&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;s&lt;/span&gt; = &lt;span class=&quot;type&quot;&gt;String&lt;/span&gt;::&lt;span class=&quot;title function_ invoke__&quot;&gt;from&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;quot;hello world&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;variable&quot;&gt;world&lt;/span&gt; = &amp;amp;s[&lt;span class=&quot;number&quot;&gt;6&lt;/span&gt;..&lt;span class=&quot;number&quot;&gt;11&lt;/span&gt;];&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Rust" scheme="https://wangjunstf.github.io/categories/Rust/"/>
    
    
    <category term="Rust" scheme="https://wangjunstf.github.io/tags/Rust/"/>
    
    <category term="slice" scheme="https://wangjunstf.github.io/tags/slice/"/>
    
  </entry>
  
  <entry>
    <title>Effective C++总结</title>
    <link href="https://wangjunstf.github.io/2023/01/12/effective-cpp/"/>
    <id>https://wangjunstf.github.io/2023/01/12/effective-cpp/</id>
    <published>2023-01-12T09:31:47.000Z</published>
    <updated>2024-10-01T14:17:56.609Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;导读&quot;&gt;&lt;strong&gt;导读&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;学习程序语言根本大法是一回事；学习如何以某种语言设计并实现高效程序则是令一会事。&lt;/p&gt;
&lt;p&gt;一组明智选择并精心设计的 classes，functions 和 templates 可使程序编写容易，直观，高效，并且远离错误。&lt;/p&gt;
&lt;h3 id=&quot;1-explicit&quot;&gt;&lt;strong&gt;1 explicit&lt;/strong&gt;&lt;/h3&gt;
&lt;p&gt;default 构造函数：一个可被调用而不带任何实参的函数，这样的构造函数要不没有参数，要不就是每个参数都有缺省值。&lt;/p&gt;</summary>
    
    
    
    <category term="编程语言" scheme="https://wangjunstf.github.io/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"/>
    
    
    <category term="C++" scheme="https://wangjunstf.github.io/tags/C/"/>
    
    <category term="Effective C++" scheme="https://wangjunstf.github.io/tags/Effective-C/"/>
    
  </entry>
  
  <entry>
    <title>ARM 移位指令</title>
    <link href="https://wangjunstf.github.io/2022/01/20/arm-yi-wei-zhi-ling/"/>
    <id>https://wangjunstf.github.io/2022/01/20/arm-yi-wei-zhi-ling/</id>
    <published>2022-01-20T03:36:23.000Z</published>
    <updated>2024-10-01T14:17:56.604Z</updated>
    
    
    <summary type="html">&lt;p&gt;移位指令是一组经常使用的指令，它包括移位指令（含算术移位指令，逻辑移位指令），循环移位指令（含带进位循环移位指令），其作用就是将目的操作数的所有位按操作符规定的方式移动指定的位数。&lt;/p&gt;
&lt;p&gt;ARM 中的移位指令如下：ASR, LSR, LSL, ROR和 RRX，直接写入目标寄存器中。&lt;/p&gt;</summary>
    
    
    
    <category term="ARM" scheme="https://wangjunstf.github.io/categories/ARM/"/>
    
    
    <category term="ARM" scheme="https://wangjunstf.github.io/tags/ARM/"/>
    
    <category term="移位指令" scheme="https://wangjunstf.github.io/tags/%E7%A7%BB%E4%BD%8D%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>用 Lisp 实现一个简单的数据库</title>
    <link href="https://wangjunstf.github.io/2021/11/16/yong-lisp-shi-xian-yi-ge-jian-dan-de-shu-ju-ku/"/>
    <id>https://wangjunstf.github.io/2021/11/16/yong-lisp-shi-xian-yi-ge-jian-dan-de-shu-ju-ku/</id>
    <published>2021-11-16T03:12:14.000Z</published>
    <updated>2024-10-01T14:17:56.617Z</updated>
    
    
    <summary type="html">&lt;p&gt;第一次认识 Lisp 是通过《黑客与画家》这本书，书中对 Lisp 赞不绝口，声称现在编程语言的发展也只是赶上了 1958 年的 Lisp 语言的水平。很多人就有疑问了，一个诞生于 1958 年的语言，计算机技术不是日新月异吗，为什么 Lisp 还没有过时？书中是这样说的，Lisp 是数学，数学是不会过时的。在书的作者 Paul Graham 的力荐下，对 Lisp 充满了浓厚的兴趣，就开始了 Lisp 的学习之旅。由于之前学习的繁忙，加上 Lisp 在&amp;quot;主流编程界&amp;quot; 好像并不受待见，我也没有一直持续学习，而是学习更加受欢迎的 C，Python 等语言，毕竟以后是要吃饭的嘛。在大学生涯的最后一段时间里，计算机基础知识学的越多，越发觉得编程语言的有趣之处，也明白了所有编程语言其实都是图灵等价的，即一个功能可以用任何编程语言实现，只不过是实现方式不一样。编程语言学的越多，越来越感受到 Lisp 本身设计的优雅，怀着一份好奇心，我又重新走进了 Lisp 的世界。&lt;/p&gt;</summary>
    
    
    
    <category term="Lisp" scheme="https://wangjunstf.github.io/categories/Lisp/"/>
    
    
    <category term="Lisp" scheme="https://wangjunstf.github.io/tags/Lisp/"/>
    
    <category term="数据结构" scheme="https://wangjunstf.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
