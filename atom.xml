<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>编程之禅</title>
  
  
  <link href="https://wangjunstf.github.io/atom.xml" rel="self"/>
  
  <link href="https://wangjunstf.github.io/"/>
  <updated>2025-10-08T01:14:49.868Z</updated>
  <id>https://wangjunstf.github.io/</id>
  
  <author>
    <name>编程之禅</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CPP函数如何安全返回数组</title>
    <link href="https://wangjunstf.github.io/2025/10/08/cpp-han-shu-ru-he-an-quan-fan-hui-shu-zu/"/>
    <id>https://wangjunstf.github.io/2025/10/08/cpp-han-shu-ru-he-an-quan-fan-hui-shu-zu/</id>
    <published>2025-10-08T01:13:41.000Z</published>
    <updated>2025-10-08T01:14:49.868Z</updated>
    
    
    <summary type="html">&lt;p&gt;因为数组不能拷贝，所以函数不能返回数组，不过，函数可以返回数组的指针或引用。在现代 C++ 中，我们应该&lt;strong&gt;优先使用标准库容器&lt;/strong&gt;而不是 C 风格的原始数组和指针，比如&lt;code&gt;std::array&lt;/code&gt;和&lt;code&gt;std::vector&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://wangjunstf.github.io/categories/cpp/"/>
    
    
    <category term="数组指针" scheme="https://wangjunstf.github.io/tags/%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88/"/>
    
    <category term="std::array" scheme="https://wangjunstf.github.io/tags/std-array/"/>
    
    <category term="std::vector" scheme="https://wangjunstf.github.io/tags/std-vector/"/>
    
  </entry>
  
  <entry>
    <title>C++列表初始化的常见用法</title>
    <link href="https://wangjunstf.github.io/2025/10/07/cpp-lie-biao-chu-shi-hua-de-chang-jian-yong-fa/"/>
    <id>https://wangjunstf.github.io/2025/10/07/cpp-lie-biao-chu-shi-hua-de-chang-jian-yong-fa/</id>
    <published>2025-10-07T14:00:05.000Z</published>
    <updated>2025-10-07T14:10:49.249Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++提供了一种&lt;strong&gt;更安全、更统一&lt;/strong&gt;的初始化方法，尤其在初始化容器和防止类型窄化方面非常有用。&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://wangjunstf.github.io/categories/cpp/"/>
    
    
    <category term="列表初始化" scheme="https://wangjunstf.github.io/tags/%E5%88%97%E8%A1%A8%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>C++安全使用可变参数</title>
    <link href="https://wangjunstf.github.io/2025/10/07/cpp-an-quan-shi-yong-ke-bian-can-shu/"/>
    <id>https://wangjunstf.github.io/2025/10/07/cpp-an-quan-shi-yong-ke-bian-can-shu/</id>
    <published>2025-10-07T08:43:39.000Z</published>
    <updated>2025-10-07T08:51:19.407Z</updated>
    
    
    <summary type="html">&lt;p&gt;C语言中的省略符形参 (&lt;code&gt;...&lt;/code&gt;) 在现代 C++ (C++11 及以后) 中主要指&lt;strong&gt;可变参数模板 (Variadic Templates)&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://wangjunstf.github.io/categories/cpp/"/>
    
    
    <category term="可变参数模板" scheme="https://wangjunstf.github.io/tags/%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0%E6%A8%A1%E6%9D%BF/"/>
    
    <category term="省略符形参，varargs" scheme="https://wangjunstf.github.io/tags/%E7%9C%81%E7%95%A5%E7%AC%A6%E5%BD%A2%E5%8F%82%EF%BC%8Cvarargs/"/>
    
  </entry>
  
  <entry>
    <title>C++ dynamic_cast与static_cast安全性与性能对比</title>
    <link href="https://wangjunstf.github.io/2025/10/04/cpp-zhong-dynamic-cast-yu-static-cast-an-quan-xing-yu-xing-neng-dui-bi/"/>
    <id>https://wangjunstf.github.io/2025/10/04/cpp-zhong-dynamic-cast-yu-static-cast-an-quan-xing-yu-xing-neng-dui-bi/</id>
    <published>2025-10-04T15:22:56.000Z</published>
    <updated>2025-10-05T01:41:13.990Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;dynamic_cast&lt;/code&gt;是在运行时进行类型安全检查的转换，主要用于多态类层次间的安全向下转换；而 &lt;code&gt;static_cast&lt;/code&gt;是在编译时进行的通用类型转换，适用于各种明确的类型转换但不提供运行时安全检查。&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://wangjunstf.github.io/categories/cpp/"/>
    
    
    <category term="dynamic_cast" scheme="https://wangjunstf.github.io/tags/dynamic-cast/"/>
    
    <category term="static_cast" scheme="https://wangjunstf.github.io/tags/static-cast/"/>
    
  </entry>
  
  <entry>
    <title>C++四种强制类型转换：static_cast，dynamic_cast，const_cast，reinterpret_cast</title>
    <link href="https://wangjunstf.github.io/2025/10/04/cpp-si-chong-qiang-zhi-lei-xing-zhuan-huan-static-cast-dynamic-cast-const-cast-reinterpret-cast/"/>
    <id>https://wangjunstf.github.io/2025/10/04/cpp-si-chong-qiang-zhi-lei-xing-zhuan-huan-static-cast-dynamic-cast-const-cast-reinterpret-cast/</id>
    <published>2025-10-04T15:16:40.000Z</published>
    <updated>2025-10-04T15:26:27.523Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;static_cast&lt;/code&gt;用于编译时相关的类型转换，&lt;code&gt;dynamic_cast&lt;/code&gt;用于运行时多态类的安全向下转换，&lt;code&gt;const_cast&lt;/code&gt;用于移除或添加&lt;code&gt;const&lt;/code&gt;/&lt;code&gt;volatile&lt;/code&gt;属性，而&lt;code&gt;reinterpret_cast&lt;/code&gt;则用于低级别的位模式重新解释。&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://wangjunstf.github.io/categories/cpp/"/>
    
    
    <category term="dynamic_cast" scheme="https://wangjunstf.github.io/tags/dynamic-cast/"/>
    
    <category term="static_cast" scheme="https://wangjunstf.github.io/tags/static-cast/"/>
    
    <category term="const_cast" scheme="https://wangjunstf.github.io/tags/const-cast/"/>
    
    <category term="reinterpret_cast" scheme="https://wangjunstf.github.io/tags/reinterpret-cast/"/>
    
  </entry>
  
  <entry>
    <title>C++虚函数表与 type_info 直观解释</title>
    <link href="https://wangjunstf.github.io/2025/10/04/cpp-xu-han-shu-biao-yu-type-info-zhi-guan-jie-shi/"/>
    <id>https://wangjunstf.github.io/2025/10/04/cpp-xu-han-shu-biao-yu-type-info-zhi-guan-jie-shi/</id>
    <published>2025-10-04T09:30:00.000Z</published>
    <updated>2025-10-04T09:30:44.672Z</updated>
    
    
    <summary type="html">&lt;p&gt;虚函数、虚函数表和 type_info共同构成了 C++ 运行时多态和类型识别的核心机制。&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://wangjunstf.github.io/categories/cpp/"/>
    
    
    <category term="虚函数表" scheme="https://wangjunstf.github.io/tags/%E8%99%9A%E5%87%BD%E6%95%B0%E8%A1%A8/"/>
    
    <category term="type_info" scheme="https://wangjunstf.github.io/tags/type-info/"/>
    
  </entry>
  
  <entry>
    <title>C++面向对象之多态示例——代码抽象和封装</title>
    <link href="https://wangjunstf.github.io/2025/10/04/cpp-mian-xiang-dui-xiang-zhi-duo-tai-shi-li-dai-ma-chou-xiang-he-feng-zhuang/"/>
    <id>https://wangjunstf.github.io/2025/10/04/cpp-mian-xiang-dui-xiang-zhi-duo-tai-shi-li-dai-ma-chou-xiang-he-feng-zhuang/</id>
    <published>2025-10-04T07:00:59.000Z</published>
    <updated>2025-10-04T07:13:40.642Z</updated>
    
    
    <summary type="html">&lt;p&gt;通过将派生类指针转换为基类指针可以实现很多功能，例如多态，接口抽象与实现分离，回调机制设计，工厂模式等。&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://wangjunstf.github.io/categories/cpp/"/>
    
    
    <category term="类继承" scheme="https://wangjunstf.github.io/tags/%E7%B1%BB%E7%BB%A7%E6%89%BF/"/>
    
    <category term="类派生" scheme="https://wangjunstf.github.io/tags/%E7%B1%BB%E6%B4%BE%E7%94%9F/"/>
    
    <category term="多态" scheme="https://wangjunstf.github.io/tags/%E5%A4%9A%E6%80%81/"/>
    
    <category term="工厂模式" scheme="https://wangjunstf.github.io/tags/%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>C++智能指针使用示例</title>
    <link href="https://wangjunstf.github.io/2025/10/03/cpp-zhi-neng-zhi-zhen-shi-yong-shi-li/"/>
    <id>https://wangjunstf.github.io/2025/10/03/cpp-zhi-neng-zhi-zhen-shi-yong-shi-li/</id>
    <published>2025-10-03T12:20:20.000Z</published>
    <updated>2025-10-03T12:47:26.963Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;智能指针所需头文件&quot;&gt;智能指针所需头文件&lt;/h2&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&amp;lt;memory&amp;gt;&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;// 主要头文件，包含所有智能指针&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://wangjunstf.github.io/categories/cpp/"/>
    
    
    <category term="智能指针" scheme="https://wangjunstf.github.io/tags/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/"/>
    
    <category term="weak_ptr" scheme="https://wangjunstf.github.io/tags/weak-ptr/"/>
    
    <category term="unique_ptr" scheme="https://wangjunstf.github.io/tags/unique-ptr/"/>
    
    <category term="shared_ptr" scheme="https://wangjunstf.github.io/tags/shared-ptr/"/>
    
  </entry>
  
  <entry>
    <title>SIMD扩展指令集以及C++使用示例</title>
    <link href="https://wangjunstf.github.io/2025/10/02/simd-kuo-zhan-zhi-ling-ji-yi-ji-cpp-shi-yong-shi-li/"/>
    <id>https://wangjunstf.github.io/2025/10/02/simd-kuo-zhan-zhi-ling-ji-yi-ji-cpp-shi-yong-shi-li/</id>
    <published>2025-10-02T03:22:22.000Z</published>
    <updated>2025-10-02T14:39:55.596Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是SIMD扩展指令集&quot;&gt;什么是SIMD扩展指令集&lt;/h2&gt;
&lt;p&gt;SIMD（单指令多数据）扩展指令集是一种并行计算技术，允许一条指令同时处理多个数据元素，提升数据密集型任务的执行效率。常见示例包括：&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://wangjunstf.github.io/categories/cpp/"/>
    
    
    <category term="SIMD" scheme="https://wangjunstf.github.io/tags/SIMD/"/>
    
  </entry>
  
  <entry>
    <title>C++左结合，右结合的概念，与运算符的优先级有什么关系</title>
    <link href="https://wangjunstf.github.io/2025/10/01/cpp-zuo-jie-he-yu-you-jie-he-de-gai-nian-yu-yun-suan-fu-de-you-xian-ji-you-shi-me-guan-xi/"/>
    <id>https://wangjunstf.github.io/2025/10/01/cpp-zuo-jie-he-yu-you-jie-he-de-gai-nian-yu-yun-suan-fu-de-you-xian-ji-you-shi-me-guan-xi/</id>
    <published>2025-10-01T03:20:02.000Z</published>
    <updated>2025-10-01T04:00:48.718Z</updated>
    
    
    <summary type="html">&lt;h3 id=&quot;什么是结合性？&quot;&gt;什么是结合性？&lt;/h3&gt;
&lt;p&gt;结合性决定了当&lt;strong&gt;同一个表达式&lt;/strong&gt;中出现&lt;strong&gt;多个相同优先级&lt;/strong&gt;的运算符时，运算的执行顺序。&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://wangjunstf.github.io/categories/cpp/"/>
    
    
    <category term="左结合" scheme="https://wangjunstf.github.io/tags/%E5%B7%A6%E7%BB%93%E5%90%88/"/>
    
    <category term="右结合" scheme="https://wangjunstf.github.io/tags/%E5%8F%B3%E7%BB%93%E5%90%88/"/>
    
    <category term="运算符优先级表" scheme="https://wangjunstf.github.io/tags/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>C++中前置++和后置++的区别</title>
    <link href="https://wangjunstf.github.io/2025/10/01/cpp-qian-zhi-jia-jie-he-hou-zhi-jia-jia-de-qu-bie/"/>
    <id>https://wangjunstf.github.io/2025/10/01/cpp-qian-zhi-jia-jie-he-hou-zhi-jia-jia-de-qu-bie/</id>
    <published>2025-10-01T02:10:58.000Z</published>
    <updated>2025-10-01T02:22:44.212Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 C++ 中，前置 &lt;code&gt;++&lt;/code&gt; 和后置 &lt;code&gt;++&lt;/code&gt; 的主要区别如下（以下内容同样适用于&lt;code&gt;--&lt;/code&gt;）：&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://wangjunstf.github.io/categories/cpp/"/>
    
    
  </entry>
  
  <entry>
    <title>C++中 bitset 用法总结</title>
    <link href="https://wangjunstf.github.io/2025/09/30/cpp-zhong-bitset-yong-fa-zong-jie/"/>
    <id>https://wangjunstf.github.io/2025/09/30/cpp-zhong-bitset-yong-fa-zong-jie/</id>
    <published>2025-09-30T12:53:22.000Z</published>
    <updated>2025-09-30T13:19:51.888Z</updated>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;bitset&lt;/code&gt; 是 C++ 标准库中的固定大小位集合容器，用于高效处理二进制位操作。&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://wangjunstf.github.io/categories/cpp/"/>
    
    
    <category term="bitset" scheme="https://wangjunstf.github.io/tags/bitset/"/>
    
  </entry>
  
  <entry>
    <title>C++中short, int, long, long long以及对应unsigned的范围</title>
    <link href="https://wangjunstf.github.io/2025/09/26/cpp-zhong-short-int-long-long-long-yi-ji-dui-ying-unsigned-de-fan-wei/"/>
    <id>https://wangjunstf.github.io/2025/09/26/cpp-zhong-short-int-long-long-long-yi-ji-dui-ying-unsigned-de-fan-wei/</id>
    <published>2025-09-26T15:10:54.000Z</published>
    <updated>2025-09-30T13:20:02.640Z</updated>
    
    
    <summary type="html">&lt;p&gt;在 C++ 中，&lt;code&gt;short&lt;/code&gt;, &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;long&lt;/code&gt;类型的大小由​&lt;strong&gt;​编译器和目标平台共同决定&lt;/strong&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://wangjunstf.github.io/categories/cpp/"/>
    
    
    <category term="short" scheme="https://wangjunstf.github.io/tags/short/"/>
    
    <category term="int" scheme="https://wangjunstf.github.io/tags/int/"/>
    
    <category term="long" scheme="https://wangjunstf.github.io/tags/long/"/>
    
    <category term="long long" scheme="https://wangjunstf.github.io/tags/long-long/"/>
    
  </entry>
  
  <entry>
    <title>原码 反码 补码的原理</title>
    <link href="https://wangjunstf.github.io/2025/09/26/yuan-ma-fan-ma-bu-ma-de-yuan-li/"/>
    <id>https://wangjunstf.github.io/2025/09/26/yuan-ma-fan-ma-bu-ma-de-yuan-li/</id>
    <published>2025-09-26T13:33:28.000Z</published>
    <updated>2025-09-26T13:55:44.390Z</updated>
    
    
    <summary type="html">&lt;p&gt;CPU中以二进制来表示和计算数据，为了进行算数运算，先后出现了以下三种编码：原码，反码和补码。&lt;/p&gt;</summary>
    
    
    
    <category term="操作系统" scheme="https://wangjunstf.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="原码" scheme="https://wangjunstf.github.io/tags/%E5%8E%9F%E7%A0%81/"/>
    
    <category term="反码" scheme="https://wangjunstf.github.io/tags/%E5%8F%8D%E7%A0%81/"/>
    
    <category term="补码" scheme="https://wangjunstf.github.io/tags/%E8%A1%A5%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Emacs 配置C++开发环境</title>
    <link href="https://wangjunstf.github.io/2025/09/23/emacs-pei-zhi-cpp-kai-fa-huan-jing/"/>
    <id>https://wangjunstf.github.io/2025/09/23/emacs-pei-zhi-cpp-kai-fa-huan-jing/</id>
    <published>2025-09-23T09:06:50.000Z</published>
    <updated>2025-09-23T09:09:34.858Z</updated>
    
    
    <summary type="html">&lt;p&gt;Emacs 入门和命令查询：&lt;a href=&quot;https://wangjunstf.github.io/2025/09/22/emacs-ru-men-jiao-cheng/&quot;&gt;Emacs 入门教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;熟悉了Emacs的基本使用之后，我们现在来尝试使用 Emacs 配置一个比较现代、实用的C++开发环境（包括代码补全、跳转、语法检查、调试等）&lt;/p&gt;</summary>
    
    
    
    <category term="Emacs" scheme="https://wangjunstf.github.io/categories/Emacs/"/>
    
    
    <category term="Emacs" scheme="https://wangjunstf.github.io/tags/Emacs/"/>
    
  </entry>
  
  <entry>
    <title>Emacs 入门教程</title>
    <link href="https://wangjunstf.github.io/2025/09/22/emacs-ru-men-jiao-cheng/"/>
    <id>https://wangjunstf.github.io/2025/09/22/emacs-ru-men-jiao-cheng/</id>
    <published>2025-09-22T10:17:40.000Z</published>
    <updated>2025-09-30T13:22:33.671Z</updated>
    
    
    <summary type="html">&lt;h2 id=&quot;Emacs-命令格式&quot;&gt;Emacs 命令格式&lt;/h2&gt;
&lt;p&gt;Emacs 按键命令通常包含 CONTROL 键（有时候以CTRL标识）和 META 键（有时以ALT标识）。Emacs 中的命令以以下方式给出&lt;br&gt;
&lt;code&gt;c-&amp;lt;chr&amp;gt;&lt;/code&gt;  表示当输入字符&lt;code&gt;&amp;lt;chr&amp;gt;&lt;/code&gt;时按住 CONTROL 键，因此&lt;code&gt;C-f&lt;/code&gt;表示：按住 CONTROL 键再输入 f。&lt;/p&gt;</summary>
    
    
    
    <category term="Emacs" scheme="https://wangjunstf.github.io/categories/Emacs/"/>
    
    
    <category term="Emacs" scheme="https://wangjunstf.github.io/tags/Emacs/"/>
    
  </entry>
  
  <entry>
    <title>业余无线电——相对值单位</title>
    <link href="https://wangjunstf.github.io/2025/09/18/ye-yu-wu-xian-dian-xiang-dui-zhi-dan-wei/"/>
    <id>https://wangjunstf.github.io/2025/09/18/ye-yu-wu-xian-dian-xiang-dui-zhi-dan-wei/</id>
    <published>2025-09-18T06:31:59.000Z</published>
    <updated>2025-09-18T06:49:10.747Z</updated>
    
    
    <summary type="html">&lt;p&gt;本质上就是&lt;strong&gt;用对数（log）来表示比值&lt;/strong&gt;，这样方便比较非常大的功率或电压范围。例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;绝对值&lt;/strong&gt;：直接告诉你功率有多大，例如 1 W、5 W、50 W。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;相对值&lt;/strong&gt;：告诉你和某个参考值相比有多大，例如比 1 W 大 10 倍、或小 10 倍。&lt;br&gt;
在无线电里，功率、电压、场强常常跨越 &lt;strong&gt;10⁶～10¹² 倍&lt;/strong&gt;的范围，直接写数字会非常大，所以大家用&lt;strong&gt;对数刻度&lt;/strong&gt;（dB）来表达。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="无线电" scheme="https://wangjunstf.github.io/categories/%E6%97%A0%E7%BA%BF%E7%94%B5/"/>
    
    
    <category term="dB" scheme="https://wangjunstf.github.io/tags/dB/"/>
    
    <category term="dBm" scheme="https://wangjunstf.github.io/tags/dBm/"/>
    
    <category term="dBW" scheme="https://wangjunstf.github.io/tags/dBW/"/>
    
    <category term="dBi" scheme="https://wangjunstf.github.io/tags/dBi/"/>
    
    <category term="dBd" scheme="https://wangjunstf.github.io/tags/dBd/"/>
    
    <category term="dBc" scheme="https://wangjunstf.github.io/tags/dBc/"/>
    
  </entry>
  
  <entry>
    <title>C++中auto类型推导的常见用法</title>
    <link href="https://wangjunstf.github.io/2025/09/18/cpp-zhong-auto-lei-xing-tui-dao-de-chang-jian-yong-fa/"/>
    <id>https://wangjunstf.github.io/2025/09/18/cpp-zhong-auto-lei-xing-tui-dao-de-chang-jian-yong-fa/</id>
    <published>2025-09-18T01:56:16.000Z</published>
    <updated>2025-09-30T13:20:07.869Z</updated>
    
    
    <summary type="html">&lt;p&gt;C++ 中的 &lt;code&gt;auto&lt;/code&gt; 关键字是一个强大的类型推导工具，它能显著简化代码并提高可读性。下面我将为你详细解析它的各种用法、注意事项和最佳实践。&lt;/p&gt;
&lt;h3 id=&quot;🧠-一、auto-的基本概念&quot;&gt;🧠 一、auto 的基本概念&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;auto&lt;/code&gt; 是 C++11 标准引入的关键字，用于在声明变量时​&lt;strong&gt;​自动推导变量的类型​&lt;/strong&gt;​，推导依据是变量的初始化表达式。&lt;/p&gt;</summary>
    
    
    
    <category term="cpp" scheme="https://wangjunstf.github.io/categories/cpp/"/>
    
    
    <category term="auto" scheme="https://wangjunstf.github.io/tags/auto/"/>
    
  </entry>
  
  <entry>
    <title>【算法解析】巧用哈希表与组合公式：高效统计数组中相同数对的数量</title>
    <link href="https://wangjunstf.github.io/2025/09/18/qiao-yong-ha-xi-biao-yu-zu-he-gong-shi-gao-xiao-tong-ji-shu-zu-zhong-xiang-tong-shu-dui-de-shu-liang/"/>
    <id>https://wangjunstf.github.io/2025/09/18/qiao-yong-ha-xi-biao-yu-zu-he-gong-shi-gao-xiao-tong-ji-shu-zu-zhong-xiang-tong-shu-dui-de-shu-liang/</id>
    <published>2025-09-18T00:33:06.000Z</published>
    <updated>2025-09-18T05:16:32.410Z</updated>
    
    
    <summary type="html">&lt;p&gt;现有以下题目：&lt;a href=&quot;https://leetcode.cn/problems/number-of-good-pairs/&quot;&gt;1512. 好数对的数目&lt;/a&gt;&lt;br&gt;
现有一个整数数组，要求统计数组中满足条件的索引对 (i, j)（其中 i &amp;lt; j 且 nums[i] = nums[j]）数量。&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://wangjunstf.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://wangjunstf.github.io/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
    <category term="哈希表" scheme="https://wangjunstf.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="组合公式" scheme="https://wangjunstf.github.io/tags/%E7%BB%84%E5%90%88%E5%85%AC%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>求两数最小公倍数的通解（通用方法解法）</title>
    <link href="https://wangjunstf.github.io/2025/09/17/qiu-liang-shu-zui-xiao-gong-bei-shu-de-tong-jie/"/>
    <id>https://wangjunstf.github.io/2025/09/17/qiu-liang-shu-zui-xiao-gong-bei-shu-de-tong-jie/</id>
    <published>2025-09-17T01:30:54.000Z</published>
    <updated>2025-09-18T02:06:12.358Z</updated>
    
    
    <summary type="html">&lt;p&gt;求两个数&lt;code&gt;a&lt;/code&gt;和&lt;code&gt;b&lt;/code&gt;的最小公倍数，最常用和最有效的方法是利用它们与最大公约数（Greatest Common Divisor, GCD）之间的关系。&lt;/p&gt;
&lt;h2 id=&quot;核心公式&quot;&gt;核心公式&lt;/h2&gt;
&lt;p&gt;两个数的最小公倍数等于这两个数的乘积除以它们的最大公约数。用数学公式表示为：&lt;br&gt;
$$LCM(a,b)=&#92;frac{|a * b|}{GCD(a,b)}$$&lt;/p&gt;</summary>
    
    
    
    <category term="算法" scheme="https://wangjunstf.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    <category term="LeetCode" scheme="https://wangjunstf.github.io/categories/%E7%AE%97%E6%B3%95/LeetCode/"/>
    
    
    <category term="最小公倍数" scheme="https://wangjunstf.github.io/tags/%E6%9C%80%E5%B0%8F%E5%85%AC%E5%80%8D%E6%95%B0/"/>
    
    <category term="LCM" scheme="https://wangjunstf.github.io/tags/LCM/"/>
    
    <category term="GCD" scheme="https://wangjunstf.github.io/tags/GCD/"/>
    
  </entry>
  
</feed>
