<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CPP安全使用可变参数</title>
      <link href="/2025/10/07/cpp-an-quan-shi-yong-ke-bian-can-shu/"/>
      <url>/2025/10/07/cpp-an-quan-shi-yong-ke-bian-can-shu/</url>
      
        <content type="html"><![CDATA[<p>C语言中的省略符形参 (<code>...</code>) 在现代 C++ (C++11 及以后) 中主要指<strong>可变参数模板 (Variadic Templates)</strong>。</p><span id="more"></span><p>它允许你创建可以接受<strong>任意数量、任意类型</strong>参数的函数或类模板。</p><p><strong>核心概念：</strong></p><ul><li><strong>参数包 (Parameter Pack)</strong>: <code>...</code> 用来表示一个可以包含零个或多个模板参数的包。</li><li><strong>包展开 (Pack Expansion)</strong>: 使用 <code>...</code> 将参数包展开，以便对其中的每个参数进行操作，通常通过递归实现。</li></ul><p><strong>示例：一个类型安全的 <code>print</code> 函数</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归的终止函数 (当参数包为空时调用)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可变参数模板函数</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(T first, Args... rest)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; first &lt;&lt; <span class="string">&quot; &quot;</span>; <span class="comment">// 处理第一个参数</span></span><br><span class="line">    <span class="built_in">print</span>(rest...);           <span class="comment">// 递归调用，处理剩余参数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Hello&quot;</span>, <span class="number">1</span>, <span class="number">3.14</span>); <span class="comment">// 输出: Hello 1 3.14 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这与 C 语言中的 <code>printf</code> (使用 <code>&lt;cstdarg&gt;</code>) 不同，可变参数模板是完全<strong>类型安全</strong>的。</p><h2 id="C语言中的省略符形参">C语言中的省略符形参</h2><p>在 C 语言中，处理可变参数 (variadic arguments) 的功能由标准库 <code>&lt;stdarg.h&gt;</code> 提供。它依赖于一组宏来访问参数列表。</p><p><strong>核心组件：</strong></p><ol><li><strong><code>va_list</code></strong>: 一个类型，用于声明一个变量来持有参数列表。</li><li><strong><code>va_start(ap, last_arg)</code></strong>: 初始化 <code>va_list</code> 变量 (<code>ap</code>)。它需要知道函数最后一个<strong>固定</strong>参数 (<code>last_arg</code>)，以便确定可变参数在栈上的起始位置。</li><li><strong><code>va_arg(ap, type)</code></strong>: 从 <code>va_list</code> (<code>ap</code>) 中检索下一个参数，并指定其<strong>类型</strong> (<code>type</code>)。每次调用，它都会返回当前参数并将内部指针移至下一个。</li><li><strong><code>va_end(ap)</code></strong>: 在函数返回前，清理 <code>va_list</code> 变量 (<code>ap</code>)。</li></ol><p><strong>使用步骤：</strong></p><ol><li>函数定义中必须至少有一个固定的命名参数，其后跟省略号 <code>...</code>。</li><li>在函数内部，创建一个 <code>va_list</code> 类型的变量。</li><li>使用 <code>va_start</code> 初始化该变量。</li><li>使用 <code>va_arg</code> 循环获取每个参数。</li><li>使用 <code>va_end</code> 进行清理。</li></ol><p><strong>关键点：</strong> 函数无法自动知道有多少个可变参数或它们的类型。你必须通过某种机制来传递这些信息，常见的方式有两种：</p><ul><li><strong>计数值</strong>: 将参数的数量作为固定参数传入。</li><li><strong>格式化字符串</strong>: 像 <code>printf</code> 那样，用一个字符串来描述后续参数的类型和数量。</li></ul><p><strong>示例：实现一个整数求和函数</strong></p><p>这个函数将第一个参数作为要相加的整数数量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数 count 是固定的，表示后面有多少个整数</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">sum_ints</span><span class="params">(<span class="type">int</span> count, ...)</span> &#123;</span><br><span class="line">    <span class="type">int</span> total = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 1. 创建 va_list 变量</span></span><br><span class="line">    va_list args;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 初始化 va_list，&#x27;count&#x27; 是最后一个固定参数</span></span><br><span class="line">    va_start(args, count);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 循环获取参数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="comment">// 使用 va_arg 获取一个 int 类型的参数</span></span><br><span class="line">        <span class="type">int</span> num = va_arg(args, <span class="type">int</span>);</span><br><span class="line">        total += num;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 清理</span></span><br><span class="line">    va_end(args);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 调用 sum_ints，传入 3 个可变参数</span></span><br><span class="line">    <span class="type">int</span> result1 = sum_ints(<span class="number">3</span>, <span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>); <span class="comment">// 10 + 20 + 30</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum 1: %d\n&quot;</span>, result1); <span class="comment">// 输出: Sum 1: 60</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 sum_ints，传入 5 个可变参数</span></span><br><span class="line">    <span class="type">int</span> result2 = sum_ints(<span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>); <span class="comment">// 1 + 2 + 3 + 4 + 5</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum 2: %d\n&quot;</span>, result2); <span class="comment">// 输出: Sum 2: 15</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>警告：</strong> 使用 <code>&lt;stdarg.h&gt;</code> 是<strong>非类型安全</strong>的。如果你在 <code>va_arg</code> 中提供了错误的类型（例如，参数是 <code>double</code> 但你请求 <code>int</code>），会导致未定义行为。</p><h2 id="C-和C语言实现可变参数的区别">C++和C语言实现可变参数的区别</h2><p>C++ 的可变参数模板和 C 语言的 <code>varargs</code> (<code>&lt;stdarg.h&gt;</code>) 的核心区别在于<strong>类型安全</strong>和<strong>实现机制</strong>。</p><p>简单来说，C++ 版本是<strong>编译时</strong>的、<strong>类型安全</strong>的“魔法”；而 C 语言版本是<strong>运行时</strong>的、<strong>不安全</strong>的“约定”。</p><p>下面是详细对比：</p><table><thead><tr><th style="text-align:left">特性</th><th style="text-align:left">C++ 可变参数模板 (Variadic Templates)</th><th style="text-align:left">C 语言 <code>varargs</code> (<code>&lt;stdarg.h&gt;</code>)</th></tr></thead><tbody><tr><td style="text-align:left"><strong>类型安全</strong></td><td style="text-align:left"><strong>完全类型安全</strong></td><td style="text-align:left"><strong>非类型安全</strong></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">编译器在编译时知道每个参数的准确类型。</td><td style="text-align:left">编译器不知道可变参数的类型或数量，完全依赖程序员提供正确的信息。</td></tr><tr><td style="text-align:left"><strong>错误检测</strong></td><td style="text-align:left"><strong>编译时</strong></td><td style="text-align:left"><strong>运行时</strong></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">如果类型不匹配，代码无法编译通过。</td><td style="text-align:left">如果传入的类型与 <code>va_arg</code> 中指定的类型不符，会导致未定义行为（如程序崩溃、数据损坏）。</td></tr><tr><td style="text-align:left"><strong>实现机制</strong></td><td style="text-align:left"><strong>模板元编程</strong></td><td style="text-align:left"><strong>宏和指针操作</strong></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">通过模板实例化和递归（或 C++17 的折叠表达式）在编译期生成处理不同参数的代码。</td><td style="text-align:left">通过 <code>va_start</code>, <code>va_arg</code> 等宏在运行时像操作指针一样在函数调用栈上移动，以获取参数。</td></tr><tr><td style="text-align:left"><strong>参数信息</strong></td><td style="text-align:left"><strong>自动推导</strong></td><td style="text-align:left"><strong>手动传递</strong></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">参数的数量和类型由编译器自动推导。</td><td style="text-align:left">必须手动提供参数的数量（如 <code>count</code> 参数）或类型信息（如 <code>printf</code> 的格式化字符串）。</td></tr><tr><td style="text-align:left"><strong>灵活性</strong></td><td style="text-align:left"><strong>极高</strong></td><td style="text-align:left"><strong>有限</strong></td></tr><tr><td style="text-align:left"></td><td style="text-align:left">不仅能用于函数，还能用于类模板（如 <code>std::tuple</code>），并能实现完美转发等高级功能。</td><td style="text-align:left">只能用于函数参数。</td></tr></tbody></table><hr><h3 id="一个形象的比喻">一个形象的比喻</h3><ul><li><p><strong>C++ 可变参数模板</strong> 就像一个<strong>智能机器人裁缝</strong>。你给它一堆不同材质的布料（不同类型的参数），它会在制作前就精确测量每一块布料，为你量身定做一件完美的衣服（生成一个特定的函数实例）。如果布料有问题，它会当场拒绝制作。</p></li><li><p><strong>C 语言 <code>varargs</code></strong> 就像一个<strong>老式的邮政信箱</strong>。你把一堆包裹（参数）塞进去，然后在另一头取件。你必须自己记住塞了几个包裹、每个包裹里装的是什么。如果你记错了，想从一个装了“书”（<code>double</code>）的包裹里取出“苹果”（<code>int</code>），那结果就是一团糟。邮局本身对此一无所知。</p></li></ul><p><strong>总结：</strong></p><p>在 C++ 中，应始终优先使用<strong>可变参数模板</strong>。它更安全、更强大、更符合现代 C++ 的编程思想。C 语言的 <code>varargs</code> 主要是为了与 C 库（如 <code>printf</code>）兼容而保留的。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 可变参数模板 </tag>
            
            <tag> 省略符形参，varargs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ dynamic_cast与static_cast安全性与性能对比</title>
      <link href="/2025/10/04/cpp-zhong-dynamic-cast-yu-static-cast-an-quan-xing-yu-xing-neng-dui-bi/"/>
      <url>/2025/10/04/cpp-zhong-dynamic-cast-yu-static-cast-an-quan-xing-yu-xing-neng-dui-bi/</url>
      
        <content type="html"><![CDATA[<p><code>dynamic_cast</code>是在运行时进行类型安全检查的转换，主要用于多态类层次间的安全向下转换；而 <code>static_cast</code>是在编译时进行的通用类型转换，适用于各种明确的类型转换但不提供运行时安全检查。</p><span id="more"></span><h2 id="安全性对比">安全性对比</h2><h3 id="static-cast-的危险性"><code>static_cast</code> 的危险性</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>; </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">derivedMethod</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Derived method&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Unrelated</span> : <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">unrelatedMethod</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Unrelated method&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 危险情况1：错误的向下转换</span></span><br><span class="line">Base* base1 = <span class="keyword">new</span> <span class="built_in">Base</span>();  <span class="comment">// 实际上是 Base 对象</span></span><br><span class="line">Derived* derived1 = <span class="built_in">static_cast</span>&lt;Derived*&gt;(base1);  <span class="comment">// 编译通过，但危险！</span></span><br><span class="line">derived1-&gt;<span class="built_in">derivedMethod</span>();  <span class="comment">// 未定义行为！内存布局不匹配</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 危险情况2：混淆派生类型</span></span><br><span class="line">Base* base2 = <span class="keyword">new</span> <span class="built_in">Unrelated</span>();  <span class="comment">// 实际上是 Unrelated 对象</span></span><br><span class="line">Derived* derived2 = <span class="built_in">static_cast</span>&lt;Derived*&gt;(base2);  <span class="comment">// 编译通过，但完全错误！</span></span><br><span class="line">derived2-&gt;<span class="built_in">derivedMethod</span>();  <span class="comment">// 灾难性的未定义行为</span></span><br></pre></td></tr></table></figure><h3 id="dynamic-cast-的安全性"><code>dynamic_cast</code> 的安全性</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安全情况1：错误的向下转换</span></span><br><span class="line">Base* base1 = <span class="keyword">new</span> <span class="built_in">Base</span>();  <span class="comment">// 实际上是 Base 对象</span></span><br><span class="line">Derived* derived1 = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(base1);</span><br><span class="line"><span class="keyword">if</span> (derived1) &#123;</span><br><span class="line">    derived1-&gt;<span class="built_in">derivedMethod</span>();  <span class="comment">// 不会执行，因为 derived1 == nullptr</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;安全：转换失败&quot;</span> &lt;&lt; endl;  <span class="comment">// 执行这里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全情况2：混淆派生类型</span></span><br><span class="line">Base* base2 = <span class="keyword">new</span> <span class="built_in">Unrelated</span>();  <span class="comment">// 实际上是 Unrelated 对象</span></span><br><span class="line">Derived* derived2 = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(base2);</span><br><span class="line"><span class="keyword">if</span> (derived2) &#123;</span><br><span class="line">    derived2-&gt;<span class="built_in">derivedMethod</span>();  <span class="comment">// 不会执行</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;安全：转换失败&quot;</span> &lt;&lt; endl;  <span class="comment">// 执行这里</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确情况：有效的向下转换</span></span><br><span class="line">Base* base3 = <span class="keyword">new</span> <span class="built_in">Derived</span>();  <span class="comment">// 实际上是 Derived 对象</span></span><br><span class="line">Derived* derived3 = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(base3);</span><br><span class="line"><span class="keyword">if</span> (derived3) &#123;</span><br><span class="line">    derived3-&gt;<span class="built_in">derivedMethod</span>();  <span class="comment">// 安全执行：输出 &quot;Derived method&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能开销分析">性能开销分析</h2><h3 id="运行时类型检查机制">运行时类型检查机制</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dynamic_cast 的底层工作原理（概念性）</span></span><br><span class="line"><span class="function">Derived* <span class="title">dynamic_cast_to_Derived</span><span class="params">(Base* ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 1. 检查指针是否为 nullptr</span></span><br><span class="line">    <span class="keyword">if</span> (ptr == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2. 通过虚函数表查找 RTTI 信息</span></span><br><span class="line">    <span class="type">const</span> std::type_info&amp; actual_type = <span class="built_in">typeid</span>(*ptr);</span><br><span class="line">    <span class="type">const</span> std::type_info&amp; target_type = <span class="built_in">typeid</span>(Derived);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 3. 类型比较（可能需要遍历继承树）</span></span><br><span class="line">    <span class="keyword">if</span> (actual_type == target_type || </span><br><span class="line">        <span class="built_in">is_base_of</span>&lt;Derived&gt;(actual_type)) &#123;  <span class="comment">// 简化表示</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;Derived*&gt;(ptr);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 4. 类型不匹配</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="性能开销来源">性能开销来源</h3><h4 id="1-RTTI-查询开销">1. <strong>RTTI 查询开销</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要访问虚函数表获取类型信息</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;</span><br><span class="line">    <span class="comment">// 编译器生成的虚函数表包含：</span></span><br><span class="line">    <span class="comment">// - 虚函数指针</span></span><br><span class="line">    <span class="comment">// - type_info 指针（用于 RTTI）</span></span><br><span class="line">    <span class="comment">// - 继承关系信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-类型比较开销">2. <strong>类型比较开销</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 可能涉及复杂的继承关系检查</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; <span class="keyword">virtual</span> ~<span class="built_in">A</span>() &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> : <span class="keyword">virtual</span> <span class="keyword">public</span> A &#123;&#125;; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B, <span class="keyword">public</span> C &#123;&#125;;</span><br><span class="line"></span><br><span class="line">A* ptr = <span class="keyword">new</span> <span class="built_in">D</span>();</span><br><span class="line">D* d_ptr = <span class="built_in">dynamic_cast</span>&lt;D*&gt;(ptr);  <span class="comment">// 需要检查复杂的菱形继承</span></span><br></pre></td></tr></table></figure><h4 id="3-缓存不友好">3. <strong>缓存不友好</strong></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 虚函数表访问可能导致缓存未命中</span></span><br><span class="line"><span class="keyword">for</span> (Base* obj : object_collection) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Derived* d = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(obj)) &#123;</span><br><span class="line">        d-&gt;<span class="built_in">process</span>();  <span class="comment">// 每次 dynamic_cast 都可能访问不同内存位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="性能基准测试示例">性能基准测试示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() = <span class="keyword">default</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;&#125;  <span class="comment">// 确保是多态类型</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test_performance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> iterations = <span class="number">1000000</span>;</span><br><span class="line">    <span class="function">std::vector&lt;Base*&gt; <span class="title">objects</span><span class="params">(iterations)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 填充对象（75% Derived, 25% Base）</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; iterations; ++i) &#123;</span><br><span class="line">        objects[i] = (i % <span class="number">4</span> != <span class="number">0</span>) ? <span class="keyword">new</span> <span class="built_in">Derived</span>() : <span class="keyword">new</span> <span class="built_in">Base</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试 dynamic_cast</span></span><br><span class="line">    <span class="keyword">auto</span> start1 = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="type">int</span> derived_count1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Base* obj : objects) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(obj)) &#123;</span><br><span class="line">            ++derived_count1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> end1 = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 测试 static_cast（假设我们知道类型）</span></span><br><span class="line">    <span class="keyword">auto</span> start2 = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="type">int</span> derived_count2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Base* obj : objects) &#123;</span><br><span class="line">        <span class="comment">// 危险！但在性能测试中假设我们知道类型</span></span><br><span class="line">        Derived* d = <span class="built_in">static_cast</span>&lt;Derived*&gt;(obj);</span><br><span class="line">        ++derived_count2;  <span class="comment">// 错误计数，因为包含 Base 对象</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> end2 = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">auto</span> time1 = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end1 - start1);</span><br><span class="line">    <span class="keyword">auto</span> time2 = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end2 - start2);</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;dynamic_cast: &quot;</span> &lt;&lt; time<span class="number">1.</span><span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; μs, found &quot;</span> &lt;&lt; derived_count1 &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;static_cast:  &quot;</span> &lt;&lt; time<span class="number">2.</span><span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; μs, found &quot;</span> &lt;&lt; derived_count2 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用建议">使用建议</h2><h3 id="使用-dynamic-cast-的情况：">使用 <code>dynamic_cast</code> 的情况：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 不确定对象实际类型时</span></span><br><span class="line">Base* obj = <span class="built_in">getObjectFromExternalSource</span>();</span><br><span class="line"><span class="keyword">if</span> (Derived* d = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(obj)) &#123;</span><br><span class="line">    <span class="comment">// 安全使用派生类功能</span></span><br><span class="line">    d-&gt;<span class="built_in">specialMethod</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 处理多种可能的派生类型</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">auto</span> d1 = <span class="built_in">dynamic_cast</span>&lt;Derived1*&gt;(obj)) &#123;</span><br><span class="line">    d1-&gt;<span class="built_in">method1</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">auto</span> d2 = <span class="built_in">dynamic_cast</span>&lt;Derived2*&gt;(obj)) &#123;</span><br><span class="line">    d2-&gt;<span class="built_in">method2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-static-cast-的情况：">使用 <code>static_cast</code> 的情况：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 确定类型安全时（通过设计保证）</span></span><br><span class="line">Base* obj = <span class="keyword">new</span> <span class="built_in">Derived</span>();  <span class="comment">// 我们知道这是 Derived</span></span><br><span class="line">Derived* d = <span class="built_in">static_cast</span>&lt;Derived*&gt;(obj);  <span class="comment">// 安全，性能更好</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 性能关键路径，且有其他方式确保安全</span></span><br><span class="line"><span class="keyword">if</span> (obj-&gt;<span class="built_in">getType</span>() == DERIVED_TYPE) &#123;  <span class="comment">// 自定义类型检查</span></span><br><span class="line">    Derived* d = <span class="built_in">static_cast</span>&lt;Derived*&gt;(obj);  <span class="comment">// 快速转换</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结">总结</h2><table><thead><tr><th>方面</th><th><code>dynamic_cast</code></th><th><code>static_cast</code></th></tr></thead><tbody><tr><td><strong>安全性</strong></td><td>高（运行时检查）</td><td>低（无检查）</td></tr><tr><td><strong>性能</strong></td><td>有开销（RTTI查询）</td><td>无开销（编译时）</td></tr><tr><td><strong>适用场景</strong></td><td>不确定类型时</td><td>确定类型安全时</td></tr><tr><td><strong>失败处理</strong></td><td>返回 <code>nullptr</code></td><td>未定义行为</td></tr></tbody></table><p><strong>核心权衡</strong>：用性能开销换取类型安全。在需要处理未知类型或复杂继承关系时，<code>dynamic_cast</code> 的安全性价值远超其性能成本。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic_cast </tag>
            
            <tag> static_cast </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++四种强制类型转换：static_cast，dynamic_cast，const_cast，reinterpret_cast</title>
      <link href="/2025/10/04/cpp-si-chong-qiang-zhi-lei-xing-zhuan-huan-static-cast-dynamic-cast-const-cast-reinterpret-cast/"/>
      <url>/2025/10/04/cpp-si-chong-qiang-zhi-lei-xing-zhuan-huan-static-cast-dynamic-cast-const-cast-reinterpret-cast/</url>
      
        <content type="html"><![CDATA[<p><code>static_cast</code>用于编译时相关的类型转换，<code>dynamic_cast</code>用于运行时多态类的安全向下转换，<code>const_cast</code>用于移除或添加<code>const</code>/<code>volatile</code>属性，而<code>reinterpret_cast</code>则用于低级别的位模式重新解释。</p><span id="more"></span><h2 id="static-cast-静态类型转换"><code>static_cast</code> - 静态类型转换</h2><h3 id="用途">用途</h3><ul><li><strong>相关类型间的合理转换</strong></li><li><strong>编译时检查</strong></li></ul><h3 id="示例">示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基础类型转换</span></span><br><span class="line"><span class="type">double</span> d = <span class="number">3.14</span>;</span><br><span class="line"><span class="type">int</span> i = <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(d);  <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类层次转换（向上转换）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123;&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line">Derived derived;</span><br><span class="line">Base* base = <span class="built_in">static_cast</span>&lt;Base*&gt;(&amp;derived);  <span class="comment">// 安全</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 向下转换（不安全！）</span></span><br><span class="line">Base* base_ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line">Derived* derived_ptr = <span class="built_in">static_cast</span>&lt;Derived*&gt;(base_ptr);  <span class="comment">// 危险！</span></span><br></pre></td></tr></table></figure><h3 id="特点">特点</h3><ul><li>编译时完成</li><li>不进行运行时检查</li><li>相对安全（在合理范围内）</li></ul><hr><h2 id="dynamic-cast-动态类型转换"><code>dynamic_cast</code> - 动态类型转换</h2><h3 id="用途-2">用途</h3><ul><li><strong>多态类型的安全向下转换</strong></li><li><strong>运行时类型检查</strong></li></ul><h3 id="示例-2">示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125; &#125;;  <span class="comment">// 必须有虚函数</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base* base_ptr = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 安全向下转换</span></span><br><span class="line">Derived* derived_ptr = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(base_ptr);</span><br><span class="line"><span class="keyword">if</span> (derived_ptr) &#123;</span><br><span class="line">    <span class="comment">// 转换成功</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 转换失败，返回 nullptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用转换（失败时抛出 std::bad_cast）</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    Derived&amp; derived_ref = <span class="built_in">dynamic_cast</span>&lt;Derived&amp;&gt;(*base_ptr);</span><br><span class="line">&#125; <span class="built_in">catch</span> (std::bad_cast&amp; e) &#123;</span><br><span class="line">    <span class="comment">// 处理转换失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="特点-2">特点</h3><ul><li>运行时检查</li><li>需要 RTTI（运行时类型信息）</li><li>只适用于多态类型（有虚函数）</li><li>安全但性能开销较大</li></ul><hr><h2 id="const-cast-常量性转换"><code>const_cast</code> - 常量性转换</h2><h3 id="用途-3">用途</h3><ul><li><strong>添加或移除 const/volatile 限定符</strong></li></ul><h3 id="示例-3">示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 移除 const</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span>* modifiable = <span class="built_in">const_cast</span>&lt;<span class="type">int</span>*&gt;(&amp;ci);</span><br><span class="line">*modifiable = <span class="number">20</span>;  <span class="comment">// 未定义行为！原对象是 const</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 合法使用：调用旧式 API</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">legacy_func</span><span class="params">(<span class="type">char</span>* str)</span></span>;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span>* hello = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">legacy_func</span>(<span class="built_in">const_cast</span>&lt;<span class="type">char</span>*&gt;(hello));  <span class="comment">// 已知字符串不会被修改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加 const</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span>* cx = <span class="built_in">const_cast</span>&lt;<span class="type">const</span> <span class="type">int</span>*&gt;(&amp;x);</span><br></pre></td></tr></table></figure><h3 id="特点-3">特点</h3><ul><li>只改变常量性，不改变类型</li><li>移除 const 后修改原对象是未定义行为</li><li>主要用于接口兼容</li></ul><hr><h2 id="reinterpret-cast-重新解释转换"><code>reinterpret_cast</code> - 重新解释转换</h2><h3 id="用途-4">用途</h3><ul><li><strong>底层、不相关的二进制转换</strong></li><li><strong>最危险的转换</strong></li></ul><h3 id="示例-4">示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指针类型转换</span></span><br><span class="line"><span class="type">int</span> x = <span class="number">0x12345678</span>;</span><br><span class="line"><span class="type">char</span>* bytes = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">char</span>*&gt;(&amp;x);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (std::<span class="type">size_t</span> index = <span class="number">0</span>; index &lt; <span class="number">4</span>; ++index) &#123;</span><br><span class="line">   cout &lt;&lt; hex &lt;&lt; <span class="built_in">int</span>(bytes[<span class="number">0</span> + index]) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 对于常见的小端序，输出 78 56 34 12</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指针与整数转换</span></span><br><span class="line"><span class="type">uintptr_t</span> addr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">uintptr_t</span>&gt;(&amp;x); </span><br><span class="line"><span class="comment">// 将x的地址值转换为 uintptr_t 类型</span></span><br><span class="line"><span class="comment">//uintptr_t是C标准库（&lt;stdint.h&gt;）中定义的一种无符号整数类型，它的关键特性是​​足够大，能够无损地存储任何指针值​，这比直接转换为 unsigned long等类型更安全、可移植性更好</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果需要将其恢复为指针</span></span><br><span class="line"><span class="type">int</span>* ptr = <span class="built_in">reinterpret_cast</span>&lt;<span class="type">int</span>*&gt;(addr);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不相关类型转换</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">A</span> &#123; <span class="type">int</span> a; &#125;;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">B</span> &#123; <span class="type">double</span> b; &#125;;</span><br><span class="line">A a&#123;<span class="number">42</span>&#125;;</span><br><span class="line">B* bp = <span class="built_in">reinterpret_cast</span>&lt;B*&gt;(&amp;a);  <span class="comment">// 极其危险！</span></span><br></pre></td></tr></table></figure><h3 id="特点-4">特点</h3><ul><li>最低层的转换</li><li>高度平台相关</li><li>几乎不做任何检查</li><li>最后的选择</li></ul><hr><h2 id="对比总结">对比总结</h2><table><thead><tr><th>特性</th><th><code>static_cast</code></th><th><code>dynamic_cast</code></th><th><code>const_cast</code></th><th><code>reinterpret_cast</code></th></tr></thead><tbody><tr><td><strong>安全性</strong></td><td>中等</td><td>高</td><td>低</td><td>极低</td></tr><tr><td><strong>检查时机</strong></td><td>编译时</td><td>运行时</td><td>编译时</td><td>无检查</td></tr><tr><td><strong>性能开销</strong></td><td>无</td><td>有</td><td>无</td><td>无</td></tr><tr><td><strong>主要用途</strong></td><td>相关类型转换</td><td>多态类型安全转换</td><td>常量性修改</td><td>底层二进制转换</td></tr><tr><td><strong>失败行为</strong></td><td>可能未定义行为</td><td>返回 nullptr（指针）或抛出异常（引用）</td><td>未定义行为（如果错误使用）</td><td>几乎总是成功但危险</td></tr></tbody></table><hr><h2 id="使用指南">使用指南</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 推荐的使用顺序</span></span><br><span class="line"><span class="comment">// 1. 首先尝试 static_cast（如果类型相关）</span></span><br><span class="line"><span class="comment">// 2. 对于多态类型向下转换，使用 dynamic_cast</span></span><br><span class="line"><span class="comment">// 3. 需要修改常量性时，使用 const_cast</span></span><br><span class="line"><span class="comment">// 4. 最后才考虑 reinterpret_cast</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Base</span> &#123; <span class="keyword">virtual</span> ~<span class="built_in">Base</span>() &#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Derived</span> : <span class="keyword">public</span> Base &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Base* base = <span class="keyword">new</span> <span class="built_in">Derived</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 好的实践</span></span><br><span class="line">Derived* derived1 = <span class="built_in">dynamic_cast</span>&lt;Derived*&gt;(base);  <span class="comment">// 安全检查</span></span><br><span class="line"><span class="keyword">if</span> (derived1) &#123; <span class="comment">/* 使用 */</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 坏的实践  </span></span><br><span class="line">Derived* derived2 = <span class="built_in">reinterpret_cast</span>&lt;Derived*&gt;(base);  <span class="comment">// 危险！</span></span><br></pre></td></tr></table></figure><p><strong>核心原则</strong>：优先使用安全的转换，只在必要时使用危险的转换，并充分了解其风险。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dynamic_cast </tag>
            
            <tag> static_cast </tag>
            
            <tag> const_cast </tag>
            
            <tag> reinterpret_cast </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++虚函数表与 type_info 直观解释</title>
      <link href="/2025/10/04/cpp-xu-han-shu-biao-yu-type-info-zhi-guan-jie-shi/"/>
      <url>/2025/10/04/cpp-xu-han-shu-biao-yu-type-info-zhi-guan-jie-shi/</url>
      
        <content type="html"><![CDATA[<p>虚函数、虚函数表和 type_info共同构成了 C++ 运行时多态和类型识别的核心机制。</p><span id="more"></span><h2 id="虚函数表-“餐厅菜单系统”">虚函数表 - “餐厅菜单系统”</h2><h3 id="现实比喻">现实比喻</h3><p>想象一家<strong>多主题餐厅</strong>：</p><ul><li>每个餐桌有一个<strong>菜单架</strong>（虚函数表指针）</li><li>不同主题区域有<strong>不同的菜单</strong>（虚函数表）</li><li>顾客点菜时，看菜单架找到对应菜单</li></ul><h3 id="代码示例">代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Restaurant</span> &#123;  <span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> 特色菜() &#123; cout &lt;&lt; <span class="string">&quot;普通套餐&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> 甜点()   &#123; cout &lt;&lt; <span class="string">&quot;水果拼盘&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Restaurant</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> 中餐厅 : <span class="keyword">public</span> Restaurant &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> 特色菜() <span class="keyword">override</span> &#123; cout &lt;&lt; <span class="string">&quot;北京烤鸭&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="type">void</span> 甜点() <span class="keyword">override</span>   &#123; cout &lt;&lt; <span class="string">&quot;芝麻汤圆&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> 西餐厅 : <span class="keyword">public</span> Restaurant &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> 特色菜() <span class="keyword">override</span> &#123; cout &lt;&lt; <span class="string">&quot;牛排&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="type">void</span> 甜点() <span class="keyword">override</span>   &#123; cout &lt;&lt; <span class="string">&quot;提拉米苏&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="内存布局">内存布局</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">中餐厅 餐厅<span class="number">1</span>;</span><br><span class="line">西餐厅 餐厅<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存中的虚函数表：</span></span><br><span class="line"><span class="comment">// 中餐厅虚表：[中餐厅::特色菜, 中餐厅::甜点]</span></span><br><span class="line"><span class="comment">// 西餐厅虚表：[西餐厅::特色菜, 西餐厅::甜点]</span></span><br><span class="line"></span><br><span class="line">Restaurant* 当前餐厅 = &amp;餐厅<span class="number">1</span>;</span><br><span class="line">当前餐厅-&gt;特色菜();  <span class="comment">// 输出&quot;北京烤鸭&quot; - 通过虚表找到正确函数</span></span><br><span class="line"></span><br><span class="line">当前餐厅 = &amp;餐厅<span class="number">2</span>;  </span><br><span class="line">当前餐厅-&gt;特色菜();  <span class="comment">// 输出&quot;牛排&quot; - 通过另一个虚表找到函数</span></span><br></pre></td></tr></table></figure><hr><h2 id="type-info-“身份证识别系统”">type_info - “身份证识别系统”</h2><h3 id="现实比喻-2">现实比喻</h3><p>想象一个<strong>人员管理系统</strong>：</p><ul><li>每个人有<strong>身份证</strong>（type_info）</li><li>系统可以检查：“这是学生吗？” “这是老师吗？”</li><li>用于安全地确定人员类型</li></ul><h3 id="代码示例-2">代码示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> 人员 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~人员() &#123;&#125;  <span class="comment">// 必须有虚函数才有 type_info</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> 学生 : <span class="keyword">public</span> 人员 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> 学习() &#123; cout &lt;&lt; <span class="string">&quot;正在学习&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> 老师 : <span class="keyword">public</span> 人员 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> 教学() &#123; cout &lt;&lt; <span class="string">&quot;正在教学&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> 处理人员(人员* 某人) &#123;</span><br><span class="line">    <span class="comment">// 检查身份证（type_info）</span></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;实际类型: &quot;</span> &lt;&lt; <span class="built_in">typeid</span>(*某人).<span class="built_in">name</span>() &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">typeid</span>(*某人) == <span class="built_in">typeid</span>(学生)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;这是一个学生&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">static_cast</span>&lt;学生*&gt;(某人)-&gt;学习();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">typeid</span>(*某人) == <span class="built_in">typeid</span>(老师)) &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;这是一个老师&quot;</span> &lt;&lt; endl; </span><br><span class="line">        <span class="built_in">static_cast</span>&lt;老师*&gt;(某人)-&gt;教学();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="两者配合使用-dynamic-cast-的工作原理">两者配合使用 - dynamic_cast 的工作原理</h2><h3 id="完整系统比喻">完整系统比喻</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">人员* 未知人员 = 获取未知人员();  <span class="comment">// 可能是学生或老师</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dynamic_cast 的工作过程：</span></span><br><span class="line"><span class="comment">// 1. 查看身份证（type_info）确认类型</span></span><br><span class="line"><span class="comment">// 2. 如果是目标类型，安全转换</span></span><br><span class="line"><span class="comment">// 3. 如果不是，返回nullptr</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (学生* 学生指针 = <span class="built_in">dynamic_cast</span>&lt;学生*&gt;(未知人员)) &#123;</span><br><span class="line">    学生指针-&gt;学习();  <span class="comment">// 安全调用学生特有方法</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (老师* 老师指针 = <span class="built_in">dynamic_cast</span>&lt;老师*&gt;(未知人员)) &#123;</span><br><span class="line">    老师指针-&gt;教学();  <span class="comment">// 安全调用老师特有方法</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;未知人员类型&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="实际内存结构可视化">实际内存结构可视化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Woof!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fetch</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Fetching ball&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Meow!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">climb</span><span class="params">()</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Climbing tree&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 内存布局示例：</span></span><br><span class="line">Dog dog;</span><br><span class="line"><span class="comment">// dog对象包含：</span></span><br><span class="line"><span class="comment">// [vptr] → Dog虚表 [Dog::speak地址, Dog::~Dog地址, Dog的type_info地址]</span></span><br><span class="line"><span class="comment">// [Dog特有数据]</span></span><br><span class="line"></span><br><span class="line">Cat cat;  </span><br><span class="line"><span class="comment">// cat对象包含：</span></span><br><span class="line"><span class="comment">// [vptr] → Cat虚表 [Cat::speak地址, Cat::~Cat地址, Cat的type_info地址]</span></span><br><span class="line"><span class="comment">// [Cat特有数据]</span></span><br></pre></td></tr></table></figure><hr><h2 id="实际应用场景">实际应用场景</h2><h3 id="场景1：游戏角色系统">场景1：游戏角色系统</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 游戏角色 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> <span class="type">void</span> 攻击() = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~游戏角色() &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> 战士 : <span class="keyword">public</span> 游戏角色 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> 攻击() <span class="keyword">override</span> &#123; cout &lt;&lt; <span class="string">&quot;剑攻击&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="type">void</span> 盾牌格挡() &#123; cout &lt;&lt; <span class="string">&quot;格挡攻击&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> 法师 : <span class="keyword">public</span> 游戏角色 &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">void</span> 攻击() <span class="keyword">override</span> &#123; cout &lt;&lt; <span class="string">&quot;火球术&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="type">void</span> 治疗() &#123; cout &lt;&lt; <span class="string">&quot;恢复生命&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> 处理战斗(游戏角色* 角色) &#123;</span><br><span class="line">    角色-&gt;攻击();  <span class="comment">// 虚函数调用 - 看菜单点菜</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 需要特殊技能时检查类型[意味着基类中没有定义这个虚函数]</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">auto</span> 战士指针 = <span class="built_in">dynamic_cast</span>&lt;战士*&gt;(角色)) &#123;</span><br><span class="line">        战士指针-&gt;盾牌格挡();  <span class="comment">// 只有战士会格挡</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">auto</span> 法师指针 = <span class="built_in">dynamic_cast</span>&lt;法师*&gt;(角色)) &#123;</span><br><span class="line">        法师指针-&gt;治疗();  <span class="comment">// 只有法师会治疗</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结比喻">总结比喻</h2><ul><li><p><strong>虚函数表</strong> = <strong>餐厅菜单系统</strong></p><ul><li>每个餐厅类型有自己的菜单</li><li>顾客通过菜单架找到正确菜单</li><li>实现&quot;不同对象，相同接口，不同行为&quot;</li></ul></li><li><p><strong>type_info</strong> = <strong>身份证识别系统</strong></p><ul><li>每个人有唯一身份证</li><li>系统可以安全地识别人员类型</li><li>防止&quot;让学生去教书&quot;这样的错误</li></ul></li></ul><p>两者配合实现了C++的多态性和安全的运行时类型识别！</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚函数表 </tag>
            
            <tag> type_info </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++面向对象之多态示例——代码抽象和封装</title>
      <link href="/2025/10/04/cpp-mian-xiang-dui-xiang-zhi-duo-tai-shi-li-dai-ma-chou-xiang-he-feng-zhuang/"/>
      <url>/2025/10/04/cpp-mian-xiang-dui-xiang-zhi-duo-tai-shi-li-dai-ma-chou-xiang-he-feng-zhuang/</url>
      
        <content type="html"><![CDATA[<p>通过将派生类指针转换为基类指针可以实现很多功能，例如多态，接口抽象与实现分离，回调机制设计，工厂模式等。</p><span id="more"></span><h2 id="多态性实现">多态性实现</h2><p>多态是指同一操作（如方法调用）作用于不同的对象时，可以产生不同的行为，具体行为由对象自身的类型决定。</p><h3 id="函数参数通用化">函数参数通用化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Animal</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Woof!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Meow!&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 单一函数处理所有动物类型</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">makeAnimalSpeak</span><span class="params">(Animal* animal)</span> </span>&#123;</span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>();  <span class="comment">// 多态调用</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Dog dog;</span><br><span class="line">Cat cat;</span><br><span class="line"><span class="built_in">makeAnimalSpeak</span>(&amp;dog);  <span class="comment">// 输出 &quot;Woof!&quot;</span></span><br><span class="line"><span class="built_in">makeAnimalSpeak</span>(&amp;cat);  <span class="comment">// 输出 &quot;Meow!&quot;</span></span><br></pre></td></tr></table></figure><h2 id="容器存储异构对象">容器存储异构对象</h2><h3 id="统一容器管理">统一容器管理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;Animal*&gt; zoo;</span><br><span class="line">zoo.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Dog</span>());</span><br><span class="line">zoo.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Cat</span>());</span><br><span class="line">zoo.<span class="built_in">push_back</span>(<span class="keyword">new</span> <span class="built_in">Dog</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 统一处理所有动物</span></span><br><span class="line"><span class="keyword">for</span> (Animal* animal : zoo) &#123;</span><br><span class="line">    animal-&gt;<span class="built_in">speak</span>();  <span class="comment">// 各自调用正确的实现</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清理资源</span></span><br><span class="line"><span class="keyword">for</span> (Animal* animal : zoo) &#123;</span><br><span class="line">    <span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="接口抽象与实现分离">接口抽象与实现分离</h2><h3 id="设计模式应用">设计模式应用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Shape</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line">    <span class="type">double</span> radius;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Circle</span>(<span class="type">double</span> r) : <span class="built_in">radius</span>(r) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> <span class="number">3.14</span> * radius * radius; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Drawing circle&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span> : <span class="keyword">public</span> Shape &#123;</span><br><span class="line">    <span class="type">double</span> width, height;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Rectangle</span>(<span class="type">double</span> w, <span class="type">double</span> h) : <span class="built_in">width</span>(w), <span class="built_in">height</span>(h) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">area</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; <span class="keyword">return</span> width * height; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">draw</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Drawing rectangle&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 图形编辑器可以统一处理所有形状</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GraphicsEditor</span> &#123;</span><br><span class="line">    vector&lt;Shape*&gt; shapes;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addShape</span><span class="params">(Shape* shape)</span> </span>&#123;</span><br><span class="line">        shapes.<span class="built_in">push_back</span>(shape);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">totalArea</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="type">double</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Shape* shape : shapes) &#123;</span><br><span class="line">            total += shape-&gt;<span class="built_in">area</span>();  <span class="comment">// 多态调用</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Application myText;</span><br><span class="line">Application mySpred;</span><br><span class="line"></span><br><span class="line">myText.<span class="built_in">createDocument</span>(<span class="string">&quot;text&quot;</span>);</span><br><span class="line">mySpred.<span class="built_in">createDocument</span>(<span class="string">&quot;spreadsheet&quot;</span>);</span><br><span class="line"></span><br><span class="line">myText.<span class="built_in">workWithDocument</span>();</span><br><span class="line">mySpred.<span class="built_in">workWithDocument</span>();</span><br></pre></td></tr></table></figure><h2 id="回调机制与事件处理">回调机制与事件处理</h2><h3 id="事件系统">事件系统</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">EventListener</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">onEvent</span><span class="params">(<span class="type">const</span> string&amp; event)</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">EventListener</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Button</span> &#123;</span><br><span class="line">    EventListener* listener;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setListener</span><span class="params">(EventListener* l)</span> </span>&#123; listener = l; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">click</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listener) &#123;</span><br><span class="line">            listener-&gt;<span class="built_in">onEvent</span>(<span class="string">&quot;button_clicked&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyApp</span> : <span class="keyword">public</span> EventListener &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">onEvent</span><span class="params">(<span class="type">const</span> string&amp; event)</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Handling event: &quot;</span> &lt;&lt; event &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">MyApp app;</span><br><span class="line">Button button;</span><br><span class="line">button.<span class="built_in">setListener</span>(&amp;app);  <span class="comment">// 派生类指针转为基类指针</span></span><br><span class="line">button.<span class="built_in">click</span>();  <span class="comment">// 输出 &quot;Handling event: button_clicked&quot;</span></span><br></pre></td></tr></table></figure><h2 id="工厂模式与对象创建">工厂模式与对象创建</h2><h3 id="灵活的对象创建">灵活的对象创建</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Document</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">open</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">save</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">virtual</span> ~<span class="built_in">Document</span>() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TextDocument</span> : <span class="keyword">public</span> Document &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Opening text document&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Saving text document&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SpreadsheetDocument</span> : <span class="keyword">public</span> Document &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Opening spreadsheet&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123; cout &lt;&lt; <span class="string">&quot;Saving spreadsheet&quot;</span> &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    Document* currentDoc;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">createDocument</span><span class="params">(<span class="type">const</span> string&amp; type)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="string">&quot;text&quot;</span>) &#123;</span><br><span class="line">            currentDoc = <span class="keyword">new</span> <span class="built_in">TextDocument</span>();  <span class="comment">// 派生类→基类</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="string">&quot;spreadsheet&quot;</span>) &#123;</span><br><span class="line">            currentDoc = <span class="keyword">new</span> <span class="built_in">SpreadsheetDocument</span>();  <span class="comment">// 派生类→基类</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">workWithDocument</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentDoc) &#123;</span><br><span class="line">            currentDoc-&gt;<span class="built_in">open</span>();</span><br><span class="line">            currentDoc-&gt;<span class="built_in">save</span>();  <span class="comment">// 多态行为</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">Application myText;</span><br><span class="line">Application mySpred;</span><br><span class="line"></span><br><span class="line">myText.<span class="built_in">createDocument</span>(<span class="string">&quot;text&quot;</span>);</span><br><span class="line">mySpred.<span class="built_in">createDocument</span>(<span class="string">&quot;spreadsheet&quot;</span>);</span><br><span class="line"></span><br><span class="line">myText.<span class="built_in">workWithDocument</span>();</span><br><span class="line">mySpred.<span class="built_in">workWithDocument</span>();</span><br></pre></td></tr></table></figure><h2 id="这样做的好处？">这样做的好处？</h2><p><strong>指的是将派生类指针转换为基类指针</strong></p><h3 id="抽象和封装"><strong>抽象和封装</strong></h3><ul><li>客户端代码只需要了解基类接口</li><li>隐藏具体实现细节</li></ul><h3 id="扩展性"><strong>扩展性</strong></h3><ul><li>添加新的派生类不需要修改现有代码</li><li>符合开闭原则</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加新的动物类型不需要修改现有代码</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">speak</span><span class="params">()</span> <span class="type">const</span> <span class="keyword">override</span> </span>&#123; std::cout &lt;&lt; <span class="string">&quot;Chirp!\n&quot;</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 现有代码自动支持新类型</span></span><br><span class="line">Bird bird;</span><br><span class="line"><span class="built_in">makeAnimalSpeak</span>(&amp;bird);  <span class="comment">// 输出: Chirp!</span></span><br></pre></td></tr></table></figure><h3 id="维护性"><strong>维护性</strong></h3><ul><li>逻辑集中在基类接口</li><li>降低代码耦合度</li></ul><h3 id="设计灵活性"><strong>设计灵活性</strong></h3><p>支持各种设计模式：</p><ul><li>策略模式</li><li>观察者模式</li><li>命令模式</li><li>等等…</li></ul><h3 id="类型安全"><strong>类型安全</strong></h3><ul><li>编译时检查接口一致性</li><li>比 C 风格强制转换更安全</li></ul><h3 id="设计清晰"><strong>设计清晰</strong></h3><ul><li>明确表达&quot;是一个&quot;的关系</li><li>符合面向对象设计原则</li></ul><p><strong>总结</strong>：向上转换（派生类→基类）是面向对象编程的基石，它实现了多态性、代码复用和灵活的软件架构，是编写可维护、可扩展代码的关键技术。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 类继承 </tag>
            
            <tag> 类派生 </tag>
            
            <tag> 多态 </tag>
            
            <tag> 工厂模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++智能指针使用示例</title>
      <link href="/2025/10/03/cpp-zhi-neng-zhi-zhen-shi-yong-shi-li/"/>
      <url>/2025/10/03/cpp-zhi-neng-zhi-zhen-shi-yong-shi-li/</url>
      
        <content type="html"><![CDATA[<h2 id="智能指针所需头文件">智能指针所需头文件</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>  <span class="comment">// 主要头文件，包含所有智能指针</span></span></span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="完整示例">完整示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span>      <span class="comment">// 智能指针头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> value) : <span class="built_in">data</span>(value) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass 构造函数: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~<span class="built_in">MyClass</span>() &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;MyClass 析构函数: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;数据: &quot;</span> &lt;&lt; data &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;=== unique_ptr 示例 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 1. unique_ptr - 独占所有权</span></span><br><span class="line">        std::unique_ptr&lt;MyClass&gt; ptr1 = std::<span class="built_in">make_unique</span>&lt;MyClass&gt;(<span class="number">100</span>);</span><br><span class="line">        ptr1-&gt;<span class="built_in">print</span>();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 所有权转移</span></span><br><span class="line">        std::unique_ptr&lt;MyClass&gt; ptr2 = std::<span class="built_in">move</span>(ptr1);</span><br><span class="line">        <span class="keyword">if</span> (!ptr1) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;ptr1 已为空&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        ptr2-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125; <span class="comment">// ptr2 自动释放</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n=== shared_ptr 示例 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 2. shared_ptr - 共享所有权</span></span><br><span class="line">        std::shared_ptr&lt;MyClass&gt; shared1 = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(<span class="number">200</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;引用计数: &quot;</span> &lt;&lt; shared<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        &#123;</span><br><span class="line">            std::shared_ptr&lt;MyClass&gt; shared2 = shared1;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;引用计数: &quot;</span> &lt;&lt; shared<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">            shared2-&gt;<span class="built_in">print</span>();</span><br><span class="line">        &#125; <span class="comment">// shared2 析构</span></span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;引用计数: &quot;</span> &lt;&lt; shared<span class="number">1.</span><span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">        shared1-&gt;<span class="built_in">print</span>();</span><br><span class="line">    &#125; <span class="comment">// shared1 自动释放</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n=== weak_ptr 示例 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 3. weak_ptr - 观察而不拥有</span></span><br><span class="line">        std::shared_ptr&lt;MyClass&gt; shared = std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(<span class="number">300</span>);</span><br><span class="line">        std::weak_ptr&lt;MyClass&gt; weak = shared;</span><br><span class="line">        </span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;共享引用计数: &quot;</span> &lt;&lt; shared.<span class="built_in">use_count</span>() &lt;&lt; std::endl;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">auto</span> locked = weak.<span class="built_in">lock</span>()) &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;weak_ptr 锁定成功&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            locked-&gt;<span class="built_in">print</span>();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;对象已被销毁&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// shared 释放，weak 自动失效</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n=== 数组管理示例 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 4. 管理动态数组</span></span><br><span class="line">        std::unique_ptr&lt;<span class="type">int</span>[]&gt; arr = std::<span class="built_in">make_unique</span>&lt;<span class="type">int</span>[]&gt;(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">            arr[i] = i * <span class="number">10</span>;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;arr[&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; arr[i] &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="comment">// 数组自动释放</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;\n=== 在容器中使用 ===&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 5. 在标准容器中使用</span></span><br><span class="line">        std::vector&lt;std::shared_ptr&lt;MyClass&gt;&gt; objects;</span><br><span class="line">        objects.<span class="built_in">push_back</span>(std::<span class="built_in">make_shared</span>&lt;MyClass&gt;(<span class="number">400</span>));</span><br><span class="line">        objects.<span class="built_in">push_back</span>(std::make_shared&lt;MyClass <span class="comment">// vector 中所有对象自动释放</span></span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;程序结束&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出示例">输出示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">=== unique_ptr 示例 ===</span><br><span class="line">MyClass 构造函数: 100</span><br><span class="line">数据: 100</span><br><span class="line">ptr1 已为空</span><br><span class="line">数据: 100</span><br><span class="line">MyClass 析构函数: 100</span><br><span class="line"></span><br><span class="line">=== shared_ptr 示例 ===</span><br><span class="line">MyClass 构造函数: 200</span><br><span class="line">引用计数: 1</span><br><span class="line">引用计数: 2</span><br><span class="line">数据: 200</span><br><span class="line">引用计数: 1</span><br><span class="line">数据: 200</span><br><span class="line">MyClass 析构函数: 200</span><br><span class="line"></span><br><span class="line">=== weak_ptr 示例 ===</span><br><span class="line">MyClass 构造函数: 300</span><br><span class="line">共享引用计数: 1</span><br><span class="line">weak_ptr 锁定成功</span><br><span class="line">数据: 300</span><br><span class="line">MyClass 析构函数: 300</span><br><span class="line"></span><br><span class="line">=== 数组管理示例 ===</span><br><span class="line">arr[0] = 0</span><br><span class="line">arr[1] = 10</span><br><span class="line">arr[2] = 20</span><br><span class="line">arr[3] = 30</span><br><span class="line">arr[4] = 40</span><br><span class="line"></span><br><span class="line">=== 在容器中使用 ===</span><br><span class="line">MyClass 构造函数: 400</span><br><span class="line">MyClass 构造函数: 500</span><br><span class="line">数据: 400</span><br><span class="line">数据: 500</span><br><span class="line">MyClass 析构函数: 500</span><br><span class="line">MyClass 析构函数: 400</span><br><span class="line">程序结束</span><br></pre></td></tr></table></figure><h2 id="关键要点">关键要点</h2><ul><li><strong><code>#include &lt;memory&gt;</code></strong> 包含所有智能指针类型</li><li><strong><code>std::make_unique</code></strong> (C++14) 和 <strong><code>std::make_shared</code></strong> 是推荐的创建方式</li><li>智能指针在作用域结束时自动释放内存，无需手动 <code>delete</code></li></ul><h2 id="C-14以前智能指针的创建方式">C++14以前智能指针的创建方式</h2><p><code>std::unique_ptr</code> (C++11)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++11 方式</span></span><br><span class="line"><span class="function">std::unique_ptr&lt;MyClass&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> MyClass(<span class="number">42</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用 reset</span></span><br><span class="line">std::unique_ptr&lt;MyClass&gt; ptr2;</span><br><span class="line">ptr<span class="number">2.</span><span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">MyClass</span>(<span class="number">42</span>));</span><br></pre></td></tr></table></figure><p><code>std::shared_ptr</code> (C++11)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接构造</span></span><br><span class="line"><span class="function">std::shared_ptr&lt;MyClass&gt; <span class="title">ptr1</span><span class="params">(<span class="keyword">new</span> MyClass(<span class="number">42</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用 reset</span></span><br><span class="line">std::shared_ptr&lt;MyClass&gt; ptr2;</span><br><span class="line">ptr<span class="number">2.</span><span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">MyClass</span>(<span class="number">42</span>));</span><br></pre></td></tr></table></figure><p>问题与缺点<br><strong>可能的内存泄漏</strong>：如果 new 成功但构造函数抛出异常</p>   <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">func</span>(std::<span class="built_in">shared_ptr</span>&lt;MyClass&gt;(<span class="keyword">new</span> MyClass), <span class="built_in">other_func</span>()); <span class="comment">// 危险！</span></span><br></pre></td></tr></table></figure><p><strong>C++14 引入的 <code>make_unique</code> 和 <code>make_shared</code> 解决了这些问题</strong>，提供异常安全性和更好的性能。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 智能指针 </tag>
            
            <tag> weak_ptr </tag>
            
            <tag> unique_ptr </tag>
            
            <tag> shared_ptr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SIMD扩展指令集以及C++使用示例</title>
      <link href="/2025/10/02/simd-kuo-zhan-zhi-ling-ji-yi-ji-cpp-shi-yong-shi-li/"/>
      <url>/2025/10/02/simd-kuo-zhan-zhi-ling-ji-yi-ji-cpp-shi-yong-shi-li/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是SIMD扩展指令集">什么是SIMD扩展指令集</h2><p>SIMD（单指令多数据）扩展指令集是一种并行计算技术，允许一条指令同时处理多个数据元素，提升数据密集型任务的执行效率。常见示例包括：</p><span id="more"></span><ul><li><strong>x86架构</strong>：MMX、SSE、AVX系列</li><li><strong>ARM架构</strong>：NEON、SVE</li><li><strong>PowerPC</strong>：AltiVec</li></ul><p><strong>核心特点</strong>：</p><ol><li><strong>并行处理</strong>：单指令操作多个数据（如4个浮点数同时相加）</li><li><strong>适用场景</strong>：多媒体处理、科学计算、机器学习推理等</li></ol><p>例如，AVX2可在一条指令中完成8个32位浮点数的加法，相比标量指令提升吞吐量。现代CPU普遍集成SIMD单元以加速向量化计算。</p><p><strong>关键特性</strong>：</p><ul><li>数据级并行：单指令处理多个数据元素</li><li>专用寄存器：不同指令集使用不同宽度寄存器</li><li>数据类型：支持整数、单/双精度浮点数</li><li>编译器支持：可通过内联函数、自动向量化或汇编使用</li></ul><p>现代编译器（GCC/Clang/MSVC）提供 intrinsic 函数直接调用 SIMD 指令，无需编写汇编代码。</p><h2 id="SIMD-指令使用示例">SIMD 指令使用示例</h2><p>以下是 C++ 中使用 SIMD 指令的详细示例：</p><h3 id="1-基础头文件和设置">1. 基础头文件和设置</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;immintrin.h&gt;</span>  <span class="comment">// 包含所有 SIMD intrinsic</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对齐内存分配（重要！）</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNED_16 __attribute__((aligned(16)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNED_32 __attribute__((aligned(32)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNED_64 __attribute__((aligned(64)))</span></span><br></pre></td></tr></table></figure><h3 id="2-SSE-浮点向量加法">2. SSE 浮点向量加法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sse_float_addition</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ALIGNED_16 <span class="type">float</span> a[<span class="number">4</span>] = &#123;<span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">4.0f</span>&#125;;</span><br><span class="line">    ALIGNED_16 <span class="type">float</span> b[<span class="number">4</span>] = &#123;<span class="number">5.0f</span>, <span class="number">6.0f</span>, <span class="number">7.0f</span>, <span class="number">8.0f</span>&#125;;</span><br><span class="line">    ALIGNED_16 <span class="type">float</span> result[<span class="number">4</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 加载数据到 SSE 寄存器</span></span><br><span class="line">    __m128 vec_a = _mm_load_ps(a);</span><br><span class="line">    __m128 vec_b = _mm_load_ps(b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// SIMD 加法（一次处理4个float）</span></span><br><span class="line">    __m128 vec_result = _mm_add_ps(vec_a, vec_b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 存储结果</span></span><br><span class="line">    _mm_store_ps(result, vec_result);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;SSE Float Addition: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; result[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl; <span class="comment">// 输出: 6 8 10 12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-AVX-双精度向量运算">3. AVX 双精度向量运算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">avx_double_operations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ALIGNED_32 <span class="type">double</span> a[<span class="number">4</span>] = &#123;<span class="number">1.0</span>, <span class="number">2.0</span>, <span class="number">3.0</span>, <span class="number">4.0</span>&#125;;</span><br><span class="line">    ALIGNED_32 <span class="type">double</span> b[<span class="number">4</span>] = &#123;<span class="number">5.0</span>, <span class="number">6.0</span>, <span class="number">7.0</span>, <span class="number">8.0</span>&#125;;</span><br><span class="line">    ALIGNED_32 <span class="type">double</span> result[<span class="number">4</span>];</span><br><span class="line">    </span><br><span class="line">    __m256d vec_a = _mm256_load_pd(a);</span><br><span class="line">    __m256d vec_b = _mm256_load_pd(b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 多种运算</span></span><br><span class="line">    __m256d add_result = _mm256_add_pd(vec_a, vec_b);</span><br><span class="line">    __m256d mul_result = _mm256_mul_pd(vec_a, vec_b);</span><br><span class="line">    __m256d sub_result = _mm256_sub_pd(vec_b, vec_a);</span><br><span class="line">    </span><br><span class="line">    _mm256_store_pd(result, add_result);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;AVX Double Addition: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; result[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-整数向量处理">4. 整数向量处理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sse_integer_operations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ALIGNED_16 <span class="type">int32_t</span> a[<span class="number">4</span>] = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>&#125;;</span><br><span class="line">    ALIGNED_16 <span class="type">int32_t</span> b[<span class="number">4</span>] = &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    ALIGNED_16 <span class="type">int32_t</span> result[<span class="number">4</span>];</span><br><span class="line">    </span><br><span class="line">    __m128i vec_a = _mm_load_si128((__m128i*)a);</span><br><span class="line">    __m128i vec_b = _mm_load_si128((__m128i*)b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 整数加法</span></span><br><span class="line">    __m128i add_result = _mm_add_epi32(vec_a, vec_b);</span><br><span class="line">    <span class="comment">// 整数乘法（注意：SSE4.1）</span></span><br><span class="line">    __m128i mul_result = _mm_mullo_epi32(vec_a, vec_b);</span><br><span class="line">    </span><br><span class="line">    _mm_store_si128((__m128i*)result, add_result);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;SSE Integer Addition: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; result[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-向量点积优化">5. 向量点积优化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">float</span> <span class="title">sse_dot_product</span><span class="params">(<span class="type">const</span> <span class="type">float</span>* a, <span class="type">const</span> <span class="type">float</span>* b, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    __m128 sum = _mm_setzero_ps();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">4</span>) &#123;</span><br><span class="line">        __m128 vec_a = _mm_load_ps(a + i);</span><br><span class="line">        __m128 vec_b = _mm_load_ps(b + i);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 乘积累加：sum += a * b</span></span><br><span class="line">        __m128 product = _mm_mul_ps(vec_a, vec_b);</span><br><span class="line">        sum = _mm_add_ps(sum, product);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 水平求和：sum[0] + sum[1] + sum[2] + sum[3]</span></span><br><span class="line">    __m128 shuf = _mm_shuffle_ps(sum, sum, _MM_SHUFFLE(<span class="number">2</span>, <span class="number">3</span>, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">    __m128 sums = _mm_add_ps(sum, shuf);</span><br><span class="line">    shuf = _mm_movehl_ps(shuf, sums);</span><br><span class="line">    sums = _mm_add_ss(sums, shuf);</span><br><span class="line">    </span><br><span class="line">    <span class="type">float</span> result;</span><br><span class="line">    _mm_store_ss(&amp;result, sums);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-AVX2-整数向量化">6. AVX2 整数向量化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">avx2_integer_operations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ALIGNED_32 <span class="type">int32_t</span> a[<span class="number">8</span>] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;;</span><br><span class="line">    ALIGNED_32 <span class="type">int32_t</span> b[<span class="number">8</span>] = &#123;<span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    ALIGNED_32 <span class="type">int32_t</span> result[<span class="number">8</span>];</span><br><span class="line">    </span><br><span class="line">    __m256i vec_a = _mm256_load_si256((__m256i*)a);</span><br><span class="line">    __m256i vec_b = _mm256_load_si256((__m256i*)b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// AVX2 整数运算</span></span><br><span class="line">    __m256i add_result = _mm256_add_epi32(vec_a, vec_b);</span><br><span class="line">    __m256i sub_result = _mm256_sub_epi32(vec_a, vec_b);</span><br><span class="line">    __m256i max_result = _mm256_max_epi32(vec_a, vec_b);</span><br><span class="line">    </span><br><span class="line">    _mm256_store_si256((__m256i*)result, add_result);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;AVX2 Integer Addition: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; result[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-条件选择和混合操作">7. 条件选择和混合操作</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">sse_conditional_operations</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ALIGNED_16 <span class="type">float</span> a[<span class="number">4</span>] = &#123;<span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">4.0f</span>&#125;;</span><br><span class="line">    ALIGNED_16 <span class="type">float</span> b[<span class="number">4</span>] = &#123;<span class="number">5.0f</span>, <span class="number">6.0f</span>, <span class="number">7.0f</span>, <span class="number">8.0f</span>&#125;;</span><br><span class="line">    ALIGNED_16 <span class="type">float</span> mask_val[<span class="number">4</span>] = &#123;<span class="number">0.0f</span>, <span class="number">2.5f</span>, <span class="number">3.5f</span>, <span class="number">0.0f</span>&#125;;</span><br><span class="line">    ALIGNED_16 <span class="type">float</span> result[<span class="number">4</span>];</span><br><span class="line">    </span><br><span class="line">    __m128 vec_a = _mm_load_ps(a);</span><br><span class="line">    __m128 vec_b = _mm_load_ps(b);</span><br><span class="line">    __m128 mask = _mm_load_ps(mask_val);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建比较掩码：如果 a &gt; mask 则全1，否则全0</span></span><br><span class="line">    __m128 cmp_mask = _mm_cmpgt_ps(vec_a, mask);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 根据掩码选择：mask为真选a，否则选b</span></span><br><span class="line">    __m128 blended = _mm_blendv_ps(vec_b, vec_a, cmp_mask);</span><br><span class="line">    </span><br><span class="line">    _mm_store_ps(result, blended);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;SSE Conditional Blend: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">        std::cout &lt;&lt; result[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-性能测试示例">8. 性能测试示例</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">performance_comparison</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> size = <span class="number">1000000</span>;</span><br><span class="line">    ALIGNED_16 <span class="type">float</span>* a = (<span class="type">float</span>*)_mm_malloc(size * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">16</span>);</span><br><span class="line">    ALIGNED_16 <span class="type">float</span>* b = (<span class="type">float</span>*)_mm_malloc(size * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">16</span>);</span><br><span class="line">    ALIGNED_16 <span class="type">float</span>* result = (<span class="type">float</span>*)_mm_malloc(size * <span class="built_in">sizeof</span>(<span class="type">float</span>), <span class="number">16</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        a[i] = i * <span class="number">0.1f</span>;</span><br><span class="line">        b[i] = i * <span class="number">0.2f</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 标量版本</span></span><br><span class="line">    <span class="keyword">auto</span> start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        result[i] = a[i] + b[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">auto</span> end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> scalar_time = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// SIMD 版本</span></span><br><span class="line">    start = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; size; i += <span class="number">4</span>) &#123;</span><br><span class="line">        __m128 vec_a = _mm_load_ps(a + i);</span><br><span class="line">        __m128 vec_b = _mm_load_ps(b + i);</span><br><span class="line">        __m128 vec_result = _mm_add_ps(vec_a, vec_b);</span><br><span class="line">        _mm_store_ps(result + i, vec_result);</span><br><span class="line">    &#125;</span><br><span class="line">    end = std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">    <span class="keyword">auto</span> simd_time = std::chrono::<span class="built_in">duration_cast</span>&lt;std::chrono::microseconds&gt;(end - start);</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Scalar time: &quot;</span> &lt;&lt; scalar_time.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; μs\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;SIMD time: &quot;</span> &lt;&lt; simd_time.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot; μs\n&quot;</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Speedup: &quot;</span> &lt;&lt; (<span class="type">double</span>)scalar_time.<span class="built_in">count</span>() / simd_time.<span class="built_in">count</span>() &lt;&lt; <span class="string">&quot;x\n&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    _mm_free(a);</span><br><span class="line">    _mm_free(b);</span><br><span class="line">    _mm_free(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="9-主函数调用">9. 主函数调用</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;=== SIMD Instruction Examples ===\n&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sse_float_addition</span>();</span><br><span class="line">    <span class="built_in">avx_double_operations</span>();</span><br><span class="line">    <span class="built_in">sse_integer_operations</span>();</span><br><span class="line">    <span class="built_in">avx2_integer_operations</span>();</span><br><span class="line">    <span class="built_in">sse_conditional_operations</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 点积示例</span></span><br><span class="line">    ALIGNED_16 <span class="type">float</span> vec1[<span class="number">4</span>] = &#123;<span class="number">1.0f</span>, <span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">4.0f</span>&#125;;</span><br><span class="line">    ALIGNED_16 <span class="type">float</span> vec2[<span class="number">4</span>] = &#123;<span class="number">2.0f</span>, <span class="number">3.0f</span>, <span class="number">4.0f</span>, <span class="number">5.0f</span>&#125;;</span><br><span class="line">    <span class="type">float</span> dot = <span class="built_in">sse_dot_product</span>(vec1, vec2, <span class="number">4</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;SSE Dot Product: &quot;</span> &lt;&lt; dot &lt;&lt; std::endl;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">performance_comparison</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译命令">编译命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基础 SSE 支持</span></span><br><span class="line">g++ -msse -msse2 -O3 simd_example.cpp -o simd_example</span><br><span class="line"></span><br><span class="line"><span class="comment"># 包含 AVX 和 AVX2</span></span><br><span class="line">g++ -mavx -mavx2 -O3 simd_example.cpp -o simd_example</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检测 CPU 特性</span></span><br><span class="line">g++ -march=native -O3 simd_example.cpp -o simd_example</span><br></pre></td></tr></table></figure><h3 id="关键要点">关键要点</h3><ol><li><strong>内存对齐</strong>：SIMD 操作需要16/32/64字节对齐的内存</li><li><strong>数据布局</strong>：连续内存访问模式性能最佳</li><li><strong>指令集检测</strong>：运行时检查 CPU 支持的指令集</li><li><strong>编译器优化</strong>：使用 <code>-O3</code> 和架构特定标志</li><li><strong>避免函数调用</strong>：在热循环中尽量减少函数调用</li></ol><p>这些示例展示了 SIMD 在数值计算、信号处理、图像处理等领域的强大性能优势。</p><h2 id="AVX和SSE的区别">AVX和SSE的区别</h2><p><strong>主要区别：</strong></p><ol><li><p><strong>指令集支持范围不同</strong></p><ul><li><code>-msse -msse2</code>：仅支持 SSE/SSE2 指令（128位寄存器）</li><li><code>-mavx -mavx2</code>：支持 AVX/AVX2 指令（256位寄存器），<strong>自动包含 SSE/SSE2</strong></li></ul></li><li><p><strong>寄存器宽度不同</strong></p><ul><li>SSE：128位，一次处理4个float或2个double</li><li>AVX：256位，一次处理8个float或4个double</li></ul></li><li><p><strong>性能差异</strong></p><ul><li>AVX2 相比 SSE 理论上有2倍的吞吐量提升</li><li>但需要CPU硬件支持（Haswell架构及以后）</li></ul></li><li><p><strong>兼容性</strong></p><ul><li>SSE/SSE2：几乎所有现代x86 CPU都支持</li><li>AVX/AVX2：需要较新的CPU（2011年后的Intel，2013年后的AMD）</li></ul></li></ol><p><strong>推荐做法</strong>：使用 <code>-march=native</code> 自动检测并启用当前CPU支持的所有指令集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">```cpp</span><br><span class="line">#ifdef __AVX__</span><br><span class="line">void avx_double_operations() &#123;</span><br><span class="line">    // AVX 代码</span><br><span class="line">&#125;</span><br><span class="line">#else</span><br><span class="line">void avx_double_operations() &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;AVX not supported&quot; &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只编译 SSE 版本（移除 AVX 函数）</span></span><br><span class="line">g++ -msse -msse2 -O3 1.cpp -o sse_example</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者编译 AVX 版本</span></span><br><span class="line">g++ -mavx -mavx2 -O3 1.cpp -o avx_example</span><br></pre></td></tr></table></figure><p><strong>关键原则</strong>：编译选项必须与代码中使用的 SIMD 指令集匹配。</p><p>sse和AVX的区别</p><p><strong>SSE 与 AVX 核心区别对比</strong></p><table><thead><tr><th>特性</th><th>SSE (Streaming SIMD Extensions)</th><th>AVX (Advanced Vector Extensions)</th></tr></thead><tbody><tr><td><strong>发布时间</strong></td><td>1999年 (SSE)</td><td>2011年 (AVX)</td></tr><tr><td><strong>寄存器宽度</strong></td><td>128位</td><td>256位</td></tr><tr><td><strong>数据并行度</strong></td><td>4个float / 2个double</td><td>8个float / 4个double</td></tr><tr><td><strong>寄存器数量</strong></td><td>8个 (xmm0-xmm7)</td><td>16个 (ymm0-ymm15)</td></tr><tr><td><strong>指令格式</strong></td><td>2操作数: <code>dst = op(dst, src)</code></td><td>3操作数: <code>dst = op(src1, src2)</code></td></tr><tr><td><strong>性能提升</strong></td><td>2-4倍</td><td>4-8倍 (相比标量)</td></tr></tbody></table><h3 id="具体差异示例">具体差异示例</h3><h3 id="1-寄存器类型">1. 寄存器类型</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SSE (128位)</span></span><br><span class="line">__m128  sse_float;   <span class="comment">// 4个float</span></span><br><span class="line">__m128d sse_double;  <span class="comment">// 2个double  </span></span><br><span class="line">__m128i sse_int;     <span class="comment">// 各种整数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AVX (256位)</span></span><br><span class="line">__m256  avx_float;   <span class="comment">// 8个float</span></span><br><span class="line">__m256d avx_double;  <span class="comment">// 4个double</span></span><br><span class="line">__m256i avx_int;     <span class="comment">// 各种整数</span></span><br></pre></td></tr></table></figure><h3 id="2-指令前缀">2. 指令前缀</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SSE 指令</span></span><br><span class="line">_mm_add_ps()    <span class="comment">// 4个float相加</span></span><br><span class="line">_mm_add_pd()    <span class="comment">// 2个double相加</span></span><br><span class="line">_mm_load_ps()   <span class="comment">// 加载4个float</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// AVX 指令  </span></span><br><span class="line">_mm256_add_ps() <span class="comment">// 8个float相加</span></span><br><span class="line">_mm256_add_pd() <span class="comment">// 4个double相加</span></span><br><span class="line">_mm256_load_ps() <span class="comment">// 加载8个float</span></span><br></pre></td></tr></table></figure><h3 id="3-实际性能对比">3. 实际性能对比</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SSE: 一次处理4个float</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sse_vector_add</span><span class="params">(<span class="type">float</span>* a, <span class="type">float</span>* b, <span class="type">float</span>* out, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">4</span>) &#123;</span><br><span class="line">        __m128 va = _mm_load_ps(a + i);</span><br><span class="line">        __m128 vb = _mm_load_ps(b + i);</span><br><span class="line">        __m128 vc = _mm_add_ps(va, vb);</span><br><span class="line">        _mm_store_ps(out + i, vc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AVX: 一次处理8个float  </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">avx_vector_add</span><span class="params">(<span class="type">float</span>* a, <span class="type">float</span>* b, <span class="type">float</span>* out, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i += <span class="number">8</span>) &#123;</span><br><span class="line">        __m256 va = _mm256_load_ps(a + i);</span><br><span class="line">        __m256 vb = _mm256_load_ps(b + i);</span><br><span class="line">        __m256 vc = _mm256_add_ps(va, vb);</span><br><span class="line">        _mm256_store_ps(out + i, vc);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-内存对齐要求">4. 内存对齐要求</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SSE: 16字节对齐</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNED_16 __attribute__((aligned(16)))</span></span><br><span class="line">ALIGNED_16 <span class="type">float</span> sse_data[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// AVX: 32字节对齐  </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ALIGNED_32 __attribute__((aligned(32)))</span></span><br><span class="line">ALIGNED_32 <span class="type">float</span> avx_data[<span class="number">8</span>];</span><br></pre></td></tr></table></figure><h3 id="5-编译器标志">5. 编译器标志</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SSE 支持</span></span><br><span class="line">g++ -msse -msse2 -msse3 -msse4.1 -msse4.2</span><br><span class="line"></span><br><span class="line"><span class="comment"># AVX 支持</span></span><br><span class="line">g++ -mavx -mavx2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自动检测最佳指令集</span></span><br><span class="line">g++ -march=native</span><br></pre></td></tr></table></figure><h3 id="选择建议">选择建议</h3><ul><li><strong>SSE</strong>: 兼容性要求高，老硬件支持</li><li><strong>AVX</strong>: 性能优先，现代CPU（2011年后）</li><li><strong>最佳实践</strong>: 使用 <code>-march=native</code> 让编译器自动选择</li></ul><p><strong>总结</strong>: AVX 是 SSE 的扩展，提供更宽的寄存器和更优的指令格式，性能更好但需要更新的硬件支持。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SIMD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++左结合，右结合的概念，与运算符的优先级有什么关系</title>
      <link href="/2025/10/01/cpp-zuo-jie-he-yu-you-jie-he-de-gai-nian-yu-yun-suan-fu-de-you-xian-ji-you-shi-me-guan-xi/"/>
      <url>/2025/10/01/cpp-zuo-jie-he-yu-you-jie-he-de-gai-nian-yu-yun-suan-fu-de-you-xian-ji-you-shi-me-guan-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是结合性？">什么是结合性？</h3><p>结合性决定了当<strong>同一个表达式</strong>中出现<strong>多个相同优先级</strong>的运算符时，运算的执行顺序。</p><span id="more"></span><p>它主要解决两种问题：</p><ul><li><strong>左结合</strong>：从左向右计算。</li><li><strong>右结合</strong>：从右向左计算。</li></ul><hr><h3 id="左结合">左结合</h3><p>大多数运算符是左结合的。这意味着运算从表达式的<strong>最左边</strong>开始。</p><p><strong>例子：<code>a - b - c</code></strong></p><ul><li>运算符 <code>-</code> 是左结合的。</li><li>它被解释为 <code>(a - b) - c</code>。</li><li>先计算 <code>a - b</code>，然后用其结果减去 <code>c</code>。</li></ul><p><strong>其他左结合运算符的例子：</strong></p><ul><li><code>a + b + c</code> → <code>(a + b) + c</code></li><li><code>a * b * c</code> → <code>(a * b) * c</code></li><li><code>a / b / c</code> → <code>(a / b) / c</code></li><li><code>a &amp;&amp; b &amp;&amp; c</code> → <code>(a &amp;&amp; b) &amp;&amp; c</code></li></ul><hr><h3 id="右结合">右结合</h3><p>少数运算符是右结合的。这意味着运算从表达式的<strong>最右边</strong>开始。</p><p><strong>例子1：<code>a = b = c</code></strong></p><ul><li>运算符 <code>=</code> 是右结合的。</li><li>它被解释为 <code>a = (b = c)</code>。</li><li>先执行 <code>b = c</code>，然后将这个赋值表达式的结果（即 <code>c</code> 的值）再赋给 <code>a</code>。</li></ul><p><strong>例子2：<code>*p++</code></strong></p><ul><li>这里 <code>*</code> 和 <code>++</code>（后缀）优先级相同，但它们是右结合的。</li><li>它被解释为 <code>*(p++)</code>，而不是 <code>(*p)++</code>。先执行 <code>p++</code>，然后对自增前的地址解引用。</li></ul><p><strong>其他右结合运算符的例子：</strong></p><ul><li><code>!~a</code> → <code>!(~a)</code> （一元运算符）</li><li><code>a ? b : c ? d : e</code> → <code>a ? b : (c ? d : e)</code> （条件运算符）</li></ul><hr><h3 id="结合性与优先级的关系">结合性与优先级的关系</h3><p>这是一个关键区别：</p><table><thead><tr><th>特性</th><th>优先级</th><th>结合性</th></tr></thead><tbody><tr><td><strong>解决的问题</strong></td><td>不同运算符之间，谁先执行？</td><td>相同优先级的运算符之间，谁先执行？</td></tr><tr><td><strong>类比</strong></td><td>乘法和加法，先算乘法</td><td>多个连加的加法，从左往右算</td></tr><tr><td><strong>例子</strong></td><td><code>a + b * c</code> → <code>a + (b * c)</code></td><td><code>a + b + c</code> → <code>(a + b) + c</code></td></tr></tbody></table><p><strong>总结关系：</strong></p><ol><li><strong>优先级第一</strong>：首先根据优先级确定哪些操作先绑定。</li><li><strong>结合性第二</strong>：当优先级无法决定顺序时（即运算符相同时），再用结合性来决定。</li></ol><hr><h3 id="经典示例分析">经典示例分析</h3><p><code>x = a + b * c &gt; d &amp;&amp; e || f</code></p><ol><li><strong>优先级最高</strong>：<code>*</code> → <code>b * c</code></li><li><strong>优先级次高</strong>：<code>+</code> → <code>a + (b * c)</code></li><li><strong>优先级第三</strong>：<code>&gt;</code> → <code>(a + b * c) &gt; d</code></li><li><strong>优先级第四</strong>：<code>&amp;&amp;</code> → <code>((a + b * c) &gt; d) &amp;&amp; e</code></li><li><strong>优先级第五</strong>：<code>||</code>（左结合） → <code>[((a + b * c) &gt; d) &amp;&amp; e] || f</code></li><li><strong>优先级最低</strong>：<code>=</code>（右结合） → <code>x = ([((a + b * c) &gt; d) &amp;&amp; e] || f)</code></li></ol><p>最终等价于：<code>x = ( ( (a + (b * c)) &gt; d ) &amp;&amp; e ) || f )</code></p><hr><h3 id="核心要点">核心要点</h3><ul><li><strong>优先级</strong>解决“先乘除后加减”的问题。</li><li><strong>结合性</strong>解决“多个相同运算符如何分组”的问题。</li><li>当不确定时，<strong>使用括号</strong>是确保表达式按你意图执行的最佳实践。</li></ul><h3 id="运算符优先级表">运算符优先级表</h3><table><thead><tr><th>优先级</th><th>运算符</th><th>描述</th><th>结合性</th></tr></thead><tbody><tr><td>1</td><td><code>::</code></td><td>作用域解析</td><td>从左到右</td></tr><tr><td>2</td><td><code>a++</code> <code>a--</code></td><td>后缀自增/自减</td><td>从左到右</td></tr><tr><td></td><td><code>type()</code> <code>type&#123;&#125;</code></td><td>函数风格转换</td><td>从左到右</td></tr><tr><td></td><td><code>a()</code></td><td>函数调用</td><td>从左到右</td></tr><tr><td></td><td><code>a[]</code></td><td>下标</td><td>从左到右</td></tr><tr><td></td><td><code>.</code> <code>-&gt;</code></td><td>成员访问</td><td>从左到右</td></tr><tr><td>3</td><td><code>++a</code> <code>--a</code></td><td>前缀自增/自减</td><td>从右到左</td></tr><tr><td></td><td><code>+a</code> <code>-a</code></td><td>一元正负</td><td>从右到左</td></tr><tr><td></td><td><code>!</code> <code>~</code></td><td>逻辑非、按位非</td><td>从右到左</td></tr><tr><td></td><td><code>(type)</code></td><td>C风格转换</td><td>从右到左</td></tr><tr><td></td><td><code>*a</code></td><td>解引用</td><td>从右到左</td></tr><tr><td></td><td><code>&amp;a</code></td><td>取地址</td><td>从右到左</td></tr><tr><td></td><td><code>sizeof</code></td><td>大小查询</td><td>从右到左</td></tr><tr><td></td><td><code>new</code> <code>new[]</code> <code>delete</code> <code>delete[]</code></td><td>动态内存</td><td>从右到左</td></tr><tr><td>4</td><td><code>.*</code> <code>-&gt;*</code></td><td>成员指针访问</td><td>从左到右</td></tr><tr><td>5</td><td><code>*</code> <code>/</code> <code>%</code></td><td>乘、除、取模</td><td>从左到右</td></tr><tr><td>6</td><td><code>+</code> <code>-</code></td><td>加、减</td><td>从左到右</td></tr><tr><td>7</td><td><code>&lt;&lt;</code> <code>&gt;&gt;</code></td><td>位左移、右移</td><td>从左到右</td></tr><tr><td>8</td><td><code>&lt;=&gt;</code></td><td>三路比较(C++20)</td><td>从左到右</td></tr><tr><td>9</td><td><code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code></td><td>关系比较</td><td>从左到右</td></tr><tr><td>10</td><td><code>==</code> <code>!=</code></td><td>相等比较</td><td>从左到右</td></tr><tr><td>11</td><td><code>&amp;</code></td><td>按位与</td><td>从左到右</td></tr><tr><td>12</td><td><code>^</code></td><td>按位异或</td><td>从左到右</td></tr><tr><td>13</td><td><code>|</code></td><td>按位或</td><td>从左到右</td></tr><tr><td>14</td><td><code>&amp;&amp;</code></td><td>逻辑与</td><td>从左到右</td></tr><tr><td>15</td><td><code>||</code></td><td>逻辑或</td><td>从左到右</td></tr><tr><td>16</td><td><code>?:</code></td><td>条件运算符</td><td>从右到左</td></tr><tr><td></td><td><code>=</code></td><td>赋值</td><td>从右到左</td></tr><tr><td></td><td><code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code></td><td>复合赋值</td><td>从右到左</td></tr><tr><td></td><td><code>&lt;&lt;=</code> <code>&gt;&gt;=</code></td><td>位运算复合赋值</td><td>从右到左</td></tr><tr><td></td><td><code>&amp;=</code> <code>^=</code> <code>|=</code></td><td>位运算复合赋值</td><td>从右到左</td></tr><tr><td>17</td><td><code>,</code></td><td>逗号运算符</td><td>从左到右</td></tr></tbody></table><h3 id="重要说明"><strong>重要说明</strong></h3><ol><li><p><strong>结合性</strong>：</p><ul><li>大部分从左到右</li><li>一元、赋值、条件运算符从右到左</li></ul></li><li><p><strong>记忆技巧</strong>：</p><ul><li>算术 &gt; 移位 &gt; 比较 &gt; 位运算 &gt; 逻辑 &gt; 条件 &gt; 赋值 &gt; 逗号</li><li>一元运算符优先级很高</li><li>后缀高于前缀</li></ul></li><li><p><strong>最佳实践</strong>：</p><ul><li>不确定时使用括号明确优先级</li><li>避免编写过于复杂的表达式</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 左结合 </tag>
            
            <tag> 右结合 </tag>
            
            <tag> 运算符优先级表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中前置++和后置++的区别</title>
      <link href="/2025/10/01/cpp-qian-zhi-jia-jie-he-hou-zhi-jia-jia-de-qu-bie/"/>
      <url>/2025/10/01/cpp-qian-zhi-jia-jie-he-hou-zhi-jia-jia-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>在 C++ 中，前置 <code>++</code> 和后置 <code>++</code> 的主要区别如下（以下内容同样适用于<code>--</code>）：</p><span id="more"></span><h2 id="语法和返回值">语法和返回值</h2><p><strong>前置 <code>++</code>（Prefix increment）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">++variable</span><br></pre></td></tr></table></figure><ul><li><strong>先递增</strong>，后返回值</li><li><strong>返回引用</strong>：返回递增后的对象本身</li></ul><p><strong>后置 <code>++</code>（Postfix increment）</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable++</span><br></pre></td></tr></table></figure><ul><li><strong>先返回值</strong>，后递增</li><li><strong>返回副本</strong>：返回递增前的对象副本</li></ul><h2 id="性能差异">性能差异</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyInt</span> &#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 前置++：效率更高</span></span><br><span class="line">    MyInt&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        ++value;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后置++：需要创建临时对象</span></span><br><span class="line">    MyInt <span class="keyword">operator</span>++(<span class="type">int</span>) &#123;  <span class="comment">// int 是哑元参数，用于区分</span></span><br><span class="line">        MyInt temp = *<span class="keyword">this</span>;  <span class="comment">// 保存原值</span></span><br><span class="line">        ++value;             <span class="comment">// 递增</span></span><br><span class="line">        <span class="keyword">return</span> temp;         <span class="comment">// 返回原值的副本</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="使用示例">使用示例</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 前置++</span></span><br><span class="line"><span class="type">int</span> x = ++a;  <span class="comment">// a=6, x=6</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 后置++</span></span><br><span class="line"><span class="type">int</span> y = b++;  <span class="comment">// b=6, y=5</span></span><br></pre></td></tr></table></figure><h2 id="推荐用法">推荐用法</h2><ul><li><strong>优先使用前置 <code>++</code></strong>：性能更好，不需要创建临时对象</li><li>在循环中尤其重要：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)  <span class="comment">// 推荐：前置++</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; i++)  <span class="comment">// 可用：后置++</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="关键区别总结">关键区别总结</h2><table><thead><tr><th>特性</th><th>前置 <code>++</code></th><th>后置 <code>++</code></th></tr></thead><tbody><tr><td>操作顺序</td><td>先递增后使用</td><td>先使用后递增</td></tr><tr><td>返回值</td><td>对象本身（引用）</td><td>原值副本（临时对象）</td></tr><tr><td>性能</td><td>更高</td><td>较低（有拷贝开销）</td></tr><tr><td>适用场景</td><td>大多数情况</td><td>需要原值参与运算时</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>C++中 bitset 用法总结</title>
      <link href="/2025/09/30/cpp-zhong-bitset-yong-fa-zong-jie/"/>
      <url>/2025/09/30/cpp-zhong-bitset-yong-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<p><code>bitset</code> 是 C++ 标准库中的固定大小位集合容器，用于高效处理二进制位操作。</p><span id="more"></span><h2 id="基本特性">基本特性</h2><ul><li><strong>固定大小</strong>：在编译时确定大小</li><li><strong>高效存储</strong>：每个位只占 1 bit</li><li><strong>支持位运算</strong>：直接支持与、或、异或等位操作</li></ul><h2 id="常用操作">常用操作</h2><h3 id="1-构造和初始化">1. 构造和初始化</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"></span><br><span class="line">bitset&lt;8&gt; b1;           <span class="comment">// 全0：00000000</span></span><br><span class="line"><span class="function">bitset&lt;8&gt; <span class="title">b2</span><span class="params">(<span class="number">0xAF</span>)</span></span>;     <span class="comment">// 十六进制：10101111</span></span><br><span class="line"><span class="function">bitset&lt;8&gt; <span class="title">b3</span><span class="params">(<span class="string">&quot;1100&quot;</span>)</span></span>;   <span class="comment">// 字符串：00001100</span></span><br></pre></td></tr></table></figure><h3 id="2-访问和修改">2. 访问和修改</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bitset&lt;8&gt; <span class="title">bs</span><span class="params">(<span class="string">&quot;10101010&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">bs[<span class="number">0</span>] = <span class="number">1</span>;              <span class="comment">// 设置第0位</span></span><br><span class="line"><span class="type">bool</span> bit = bs[<span class="number">2</span>];       <span class="comment">// 获取第2位</span></span><br><span class="line">bs.<span class="built_in">set</span>(<span class="number">3</span>);              <span class="comment">// 设置第3位为1</span></span><br><span class="line">bs.<span class="built_in">reset</span>(<span class="number">1</span>);            <span class="comment">// 设置第1位为0</span></span><br><span class="line">bs.<span class="built_in">flip</span>(<span class="number">4</span>);             <span class="comment">// 翻转第4位</span></span><br></pre></td></tr></table></figure><h3 id="3-查询信息">3. 查询信息</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bs.<span class="built_in">size</span>();              <span class="comment">// 返回位数：8</span></span><br><span class="line">bs.<span class="built_in">count</span>();             <span class="comment">// 返回1的个数</span></span><br><span class="line">bs.<span class="built_in">any</span>();               <span class="comment">// 是否有1存在</span></span><br><span class="line">bs.<span class="built_in">none</span>();              <span class="comment">// 是否全为0</span></span><br><span class="line">bs.<span class="built_in">all</span>();               <span class="comment">// 是否全为1</span></span><br></pre></td></tr></table></figure><h3 id="4-位运算">4. 位运算</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bitset&lt;8&gt; <span class="title">a</span><span class="params">(<span class="string">&quot;11001100&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">bitset&lt;8&gt; <span class="title">b</span><span class="params">(<span class="string">&quot;10101010&quot;</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> c = a &amp; b;         <span class="comment">// 按位与</span></span><br><span class="line"><span class="keyword">auto</span> d = a | b;         <span class="comment">// 按位或  </span></span><br><span class="line"><span class="keyword">auto</span> e = a ^ b;         <span class="comment">// 按位异或</span></span><br><span class="line"><span class="keyword">auto</span> f = ~a;            <span class="comment">// 按位取反</span></span><br></pre></td></tr></table></figure><h3 id="5-转换">5. 转换</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bs.<span class="built_in">to_string</span>();         <span class="comment">// 转为字符串</span></span><br><span class="line">bs.<span class="built_in">to_ulong</span>();          <span class="comment">// 转为unsigned long</span></span><br><span class="line">bs.<span class="built_in">to_ullong</span>();         <span class="comment">// 转为unsigned long long</span></span><br></pre></td></tr></table></figure><h2 id="应用场景">应用场景</h2><ul><li>状态标志存储</li><li>位掩码操作</li><li>集合运算（最多64个元素）</li><li>位级算法优化</li></ul>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bitset </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中short, int, long, long long以及对应unsigned的范围</title>
      <link href="/2025/09/26/cpp-zhong-short-int-long-long-long-yi-ji-dui-ying-unsigned-de-fan-wei/"/>
      <url>/2025/09/26/cpp-zhong-short-int-long-long-long-yi-ji-dui-ying-unsigned-de-fan-wei/</url>
      
        <content type="html"><![CDATA[<p>在 C++ 中，<code>short</code>, <code>int</code>, <code>long</code>类型的大小由​<strong>​编译器和目标平台共同决定</strong>。</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">short</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">int</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line">  cout &lt;&lt; <span class="built_in">sizeof</span>(<span class="type">long</span> <span class="type">long</span>) &lt;&lt; endl;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例如在64位Ubuntu中使用g++编译并运行输出以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">8</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>在64位windows11中使用g++编译并运行输出以下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">4</span><br><span class="line">4</span><br><span class="line">8</span><br></pre></td></tr></table></figure><p>区别在于long，在ubuntu下它是8字节，在windows下它和int一样是4字节。</p><p>下面基于Ubuntu来计算short, int, long的取值范围。</p><p>现代的CPU都采用补码来表示有符号整数，关于补码的介绍参考：<a href="https://wangjunstf.github.io/2025/09/26/yuan-ma-fan-ma-bu-ma-de-yuan-li/">原码 反码 补码的原理</a></p><h2 id="short">short</h2><p>short 和 unsigned short都只占16bit，区别是short为有符号类型，unsigned short为无符号类型。有符号数在计算机内部用补码表示，即最高位表示符号位，0为正数，1为负数。</p><p>对于有符号数，除了最高位为符号位，还可以使用15位来表示数字</p><p>能表示的最小数字（补码）是：1000 0000 0000 0000，即 -32768<br>其能表示的最大数字（补码）是：0111 1111 1111 1111 ，即32767<br>所以 shor的范围为：[-$2^{15}$ ，$2^{15}-1$ ]即 [-32768, 32767]</p><p>unsigned short没有符号，所以可以用16bit来表示数据。最小值是<code>0000 0000 0000 0000</code>即0，最大值是<code>1111 1111 1111 1111</code>即65535<br>所以 short 的范围为：[0, $2^{16}-1$]即[0,65535]</p><p>为了方便表示二进制数，下面统一用十六进制数，每4位二进制数表示1位十六进制数。、<br>例如 <code>0111 1111 1111 1111</code>用十六进制表示为：<code>7FFF</code></p><h2 id="int">int</h2><p>int 和 unsigned int都占32位，前者为有符号类型，后者为无符号类型。在计算机中有符号数都用补码表示。</p><p>int 能表示的最小数字（十六进制补码）为：8000 0000，即-2147483648<br>int 能表示的最大数字（十六进制补码）为：7FFF FFFF，即2147483647<br>所以int的范围为：[$-2^{31}, 2^{31}-1$]即[-2147483648, 2147483647]</p><p>同理，unsigned int没有符号位。最小值（十六进制）：<code>0000 0000</code>即0 ，最大值（十六进制）：<code>FFFF FFFF</code>即<code>4,294,967,295</code><br>所以 unsigned int 的范围为：[0, $2^{32}-1$]即[0,4,294,967,295 ]</p><h2 id="long">long</h2><p>long 和 unsigned long都占64位，前者为有符号类型，后者为无符号类型。在计算机中有符号数都用补码表示。</p><p>long 能表示的最小数字（十六进制补码）为：<code>8000 0000 0000 0000</code>即-9,223,372,036,854,775,808 读作负的九百二十二京三千三百七十二兆三百六十八亿五千四百七十七万五千八百零八<br>long 能表示的最大数字（十六进制补码）为：<code>7FFF FFFF FFFF FFFF</code> ，即9,223,372,036,854,775,807<br>所以 long的范围为：[$-2^{63}, 2^{63}-1$]</p><p>同理，unsigned long没有符号位，最小值（十六进制）：<code>0000 0000 0000 00000</code>，最大值（十六进制）：<code>FFFF FFFF FFFF FFFF</code> 即<code>18,446,744,073,709,551,615</code> 读作 一千八百四十四京…<br>所以unsigned long的范围为：[0,$2^{64}-1$ ]</p><h2 id="long-long">long long</h2><p>long long 的大小是跨平台固定的，不管在Linux 还是 Windows下它都是64位。范围参考上述的long 的范围。</p><h2 id="公式">公式</h2><p>对于 n 位二进制数。<br>有符号数的范围为：[$-2^{n-1}$, $2^{n-1}-1$]<br>无符号数的范围为：[0, $2^n-1$]</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> short </tag>
            
            <tag> int </tag>
            
            <tag> long </tag>
            
            <tag> long long </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原码 反码 补码的原理</title>
      <link href="/2025/09/26/yuan-ma-fan-ma-bu-ma-de-yuan-li/"/>
      <url>/2025/09/26/yuan-ma-fan-ma-bu-ma-de-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>CPU中以二进制来表示和计算数据，为了进行算数运算，先后出现了以下三种编码：原码，反码和补码。</p><span id="more"></span><table><thead><tr><th>名称</th><th>英文</th><th>用途</th></tr></thead><tbody><tr><td>原码</td><td>Sign-Magnitude</td><td>最直观的人类写法</td></tr><tr><td>反码</td><td>Ones’ Complement</td><td>过渡形式，历史上用过</td></tr><tr><td>补码</td><td>Two’s Complement</td><td>现代计算机通用</td></tr></tbody></table><h3 id="原码">原码</h3><p><strong>最高位</strong>表示符号：0=正，1=负<br><strong>剩下的位</strong>表示数值大小<br>优点：直观<br>缺点：有“+0”和“-0”两个表示方式，需要专门的减法电路<br>这里的+0和-0没有数学上的意义，单纯是表示上的差别<br><code>00000000</code> 表示 <code>+0</code>，<code>10000000</code>表示<code>-0</code> 有时候做两数相等比较的时候会比较麻烦<br>如果要实现 A-B，则必须：</p><ol><li>检查符号位</li><li>做加法或减法</li><li>根据符号位调整结果</li></ol><p>例如对于8位二进制数：</p><table><thead><tr><th>十进制</th><th>原码二进制</th></tr></thead><tbody><tr><td>+5</td><td><code>00000101</code></td></tr><tr><td>-5</td><td><code>10000101</code></td></tr></tbody></table><p>例1： -1 + -1 （原码）<br>步骤：</p><ul><li><strong>+1（原码）</strong>：<code>0000 0001</code></li><li><strong>-1（原码）</strong>：<code>1000 0001</code></li></ul><p>两数相加（原码）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1000 0001</span><br><span class="line">+1000 0001</span><br><span class="line">-----------</span><br><span class="line">1 0000 0010   (溢出位1)</span><br></pre></td></tr></table></figure><p>结果变成 <code>0000 0010</code>（把符号位当普通位加了） → 实际是 <strong>+2</strong>，不正确。<br>💡 <strong>在原码下，-1 + -1 得不到 -2</strong>，必须用单独的减法指令或额外处理逻辑才行。</p><p>例2：2+(-3) （原码）<br>步骤</p><ul><li><strong>+2（原码）</strong>：<code>0000 0010</code></li><li><strong>-3（原码）</strong>：<code>1000 0011</code></li></ul><p>相加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000 0010</span><br><span class="line">+1000 0011</span><br><span class="line">-----------</span><br><span class="line">1000 0101</span><br></pre></td></tr></table></figure><p>这被解释为 <strong>-5（原码）</strong>，但正确答案应是 −1-1−1。<br>💡 <strong>在原码下做正数 + 负数很难直接得到正确结果</strong>，需要硬件做“减法”并判断符号。</p><h3 id="反码">反码</h3><p>正数：和原码一样<br>负数：在原码基础上<strong>符号位不变，数值位按位取反</strong><br>缺点：仍然有“+0”和“-0”两种表示和“末位进位回加”问题（end-around carry）。</p><p>如果要实现A-B时可以这样做：<br>A+(B的反码)<br>在 <strong>反码加法</strong>中：</p><ul><li>当两个符号位相加后，产生了一个“多出来的”进位到最高位以外。</li><li>具体来说：当两个数同号，或一个数是负数另一个是正数，但反码相加时结果大于最大可表示的正值，会产生环绕进位。</li></ul><p>📌 <strong>重点记忆</strong>：<br><strong>只要反码相加结果溢出了最高位，且你要得到正确值，就要把溢出的1加回最低位。</strong></p><p>例1：8 位反码：</p><ul><li>+2 (反码) = <code>0000 0010</code></li><li>+3 (反码) = <code>0000 0011</code></li></ul><p>相加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000 0010</span><br><span class="line">+0000 0011</span><br><span class="line">-----------</span><br><span class="line">0000 0101  (没有溢出，不用回加)</span><br></pre></td></tr></table></figure><p>例2：典型的回加例子（-1 + -1）</p><ul><li>-1 原码 = <code>1000 0001</code> → 反码 = <code>1111 1110</code></li></ul><p>再加 -1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1111 1110</span><br><span class="line">+1111 1110</span><br><span class="line">-----------</span><br><span class="line">1 1111 1100  (多出一个进位1)</span><br></pre></td></tr></table></figure><p>去掉溢出的1（符号之外）再加回最低位：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1111 1100 + 1 = 1111 1101</span><br></pre></td></tr></table></figure><p>这是 -2 的反码。正确。</p><h3 id="补码">补码</h3><p>现代计算机都用补码。</p><ul><li>正数：与原码、反码相同</li><li>负数：<strong>反码+1</strong></li><li>好处：<ul><li>加减法可以用同一个加法器完成</li><li>只有一个零</li><li>范围可以多出一个负数（-128～+127 for 8-bit）<br>例如：</li></ul></li></ul><table><thead><tr><th>十进制</th><th>原码</th><th>反码</th><th>补码</th></tr></thead><tbody><tr><td>+5</td><td>00000101</td><td>00000101</td><td>00000101</td></tr><tr><td>-5</td><td>10000101</td><td>11111010（反码）</td><td>11111011（补码）</td></tr><tr><td>对于 n 位二进制：</td><td></td><td></td><td></td></tr></tbody></table><ul><li>负数的补码 = $a^{n} - |X|$</li><li>负数的补码再取补码（再求反码+1）就回到正数</li></ul><p>如果要实现A-B时可以这样做：<br>A+(B的补码)<br><strong>只要有一个加法器，就能同时完成加法和减法</strong>，因为：</p><ul><li>B 为正：直接加</li><li>B 为负：加上它的补码</li></ul><p>补码天然让溢出和进位处理一致。<br>📌 <strong>优点：无需单独的减法器/减法指令</strong>，只需：</p><ul><li>把第二个操作数取补码（硬件中通过反码+1实现）</li><li>然后用同一个加法器执行加法</li></ul><p>例 1：−1+−1（补码）<br>步骤</p><ul><li>-1（补码）**：<ul><li>原码：<code>1000 0001</code></li><li>反码：<code>1111 1110</code></li><li>补码：<code>1111 1111</code></li></ul></li></ul><p>两数相加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1111 1111</span><br><span class="line">+1111 1111</span><br><span class="line">-----------</span><br><span class="line">1 1111 1110</span><br></pre></td></tr></table></figure><p>丢弃最高位的进位（溢出位）：<br><code>1111 1110</code></p><p>→ 这是 <strong>-2 的补码</strong>（因为负数补码 = 反码 + 1 → 反码 = <code>1111 1101</code> → 原码 = <code>1000 0010</code>）。<br>✅ <strong>直接得出 -2</strong>。<br>📌 <strong>补码不需要回加</strong>。</p><hr><p>例 2：2+(−3)（补码）<br>步骤</p><ul><li>+2（补码）：<code>0000 0010</code></li><li><strong>-3（补码）</strong>：<ul><li>原码：<code>1000 0011</code></li><li>反码：<code>1111 1100</code></li><li>补码：<code>1111 1101</code></li></ul></li></ul><p>两数相加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0000 0010</span><br><span class="line">+1111 1101</span><br><span class="line">-----------</span><br><span class="line">1111 1111</span><br></pre></td></tr></table></figure><p><code>1111 1111</code> → 这是 <strong>-1 的补码</strong>。<br>✅ 结果正确：2+(−3)=−1。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 原码 </tag>
            
            <tag> 反码 </tag>
            
            <tag> 补码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Emacs 配置C++开发环境</title>
      <link href="/2025/09/23/emacs-pei-zhi-cpp-kai-fa-huan-jing/"/>
      <url>/2025/09/23/emacs-pei-zhi-cpp-kai-fa-huan-jing/</url>
      
        <content type="html"><![CDATA[<p>Emacs 入门和命令查询：<a href="https://wangjunstf.github.io/2025/09/22/emacs-ru-men-jiao-cheng/">Emacs 入门教程</a></p><p>熟悉了Emacs的基本使用之后，我们现在来尝试使用 Emacs 配置一个比较现代、实用的C++开发环境（包括代码补全、跳转、语法检查、调试等）</p><span id="more"></span><p>Emacs 的配置文件为：<code>~/.emacs.d/init.el</code><br>将下列的配置信息保存到 Emacs 的配置文件中，保存并重启打开 Emacs 就可以生效。</p><h2 id="安装必要的包管理器">安装必要的包管理器</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; 包管理器初始化 </span></span><br><span class="line">(<span class="name">require</span> &#x27;package) <span class="comment">; 加载Emacs包管理系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; 设置包镜像源为清华大学TUNA镜像，加快国内下载速度 </span></span><br><span class="line">(<span class="name">setq</span> package-archives</span><br><span class="line">      &#x27;((<span class="string">&quot;gnu&quot;</span>   . <span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/&quot;</span>)</span><br><span class="line">        (<span class="string">&quot;melpa&quot;</span> . <span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/&quot;</span>)))</span><br><span class="line">(<span class="name">package-initialize</span>)  <span class="comment">; 初始化包系统</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; 确保use-package已安装（用于声明式包管理）</span></span><br><span class="line">(<span class="name">unless</span> (<span class="name">package-installed-p</span> &#x27;use-package)</span><br><span class="line">  (<span class="name">package-refresh-contents</span>)</span><br><span class="line">  (<span class="name">package-install</span> &#x27;use-package))</span><br><span class="line">  </span><br><span class="line"><span class="comment">;; 确保在安装 use-package 前刷新包列表</span></span><br><span class="line">(<span class="name">unless</span> (<span class="name">package-installed-p</span> &#x27;use-package)</span><br><span class="line">  (<span class="name">package-refresh-contents</span>)</span><br><span class="line">  (<span class="name">package-install</span> &#x27;use-package))</span><br></pre></td></tr></table></figure><h2 id="基本的-C-模式支持">基本的 C++ 模式支持</h2><p>Emacs 自带 <code>cc-mode</code>主模式，支持C、C++、Java、Objective-C、AWK 等一系列在语法和风格上类似的“类C”语言的语法高亮和智能缩进。</p><p>安装 clang-format<br>针对Ubuntu:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install clang-format</span><br></pre></td></tr></table></figure><p>Mac： <code>brew install clang-format</code><br>Windows： 用 LLVM 安装包</p><p>我们可以安装 <code>clang-format</code> 实现代码自动排版：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">use-package</span> clang-format</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:commands</span> (<span class="name">clang-format-buffer</span> clang-format-region)</span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">;; 设置样式</span></span><br><span class="line">  (<span class="name">setq</span> clang-format-style <span class="string">&quot;file&quot;</span>)   <span class="comment">; 使用项目中的 .clang-format 文件</span></span><br><span class="line">  (<span class="name">setq</span> clang-format-fallback-style <span class="string">&quot;llvm&quot;</span>)  <span class="comment">; 无配置文件时的默认样式</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">;; 启用详细日志</span></span><br><span class="line">  <span class="comment">;; (setq clang-format-verbose t)</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">;; 绑定快捷键</span></span><br><span class="line">  <span class="symbol">:bind</span> ((<span class="string">&quot;C-c f&quot;</span> . clang-format-buffer)      <span class="comment">; 针对整个缓冲区</span></span><br><span class="line">         (<span class="string">&quot;C-c r&quot;</span> . clang-format-region)))    <span class="comment">; 针对选中的区域</span></span><br></pre></td></tr></table></figure><p>我们可以在 Emacs 配置一个钩子函数，每次保存时都对代码自动自动排版</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; 每次保存时都自动格式化代码</span></span><br><span class="line">(<span class="name">add-hook</span> &#x27;c-mode-common-hook</span><br><span class="line">          (<span class="name">lambda</span> ()</span><br><span class="line">            (<span class="name">add-hook</span> &#x27;before-save-hook &#x27;clang-format-buffer <span class="literal">nil</span> <span class="literal">t</span>)))</span><br></pre></td></tr></table></figure><h2 id="代码补全：LSP-clangd">代码补全：LSP + clangd</h2><p>最主流的方法是用 <strong>LSP（Language Server Protocol）</strong> 与 clangd 配合。LSP (Language Server Protocol) 是一种​<strong>​开放标准协议​</strong>​，它允许编辑器或 IDE 与语言服务器进行通信，从而提供智能代码功能。在 Emacs 中，LSP 通过特定的包实现，将编辑器转变为功能强大的现代开发环境。</p><p><strong>Emacs 配置</strong><br>推荐 <code>lsp-mode</code> + <code>lsp-ui</code>：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;; 代码补全：LSP+clang</span></span><br><span class="line">(<span class="name">use-package</span> lsp-mode</span><br><span class="line">  <span class="symbol">:hook</span> ((<span class="name">c++-mode</span> . lsp)</span><br><span class="line">         (<span class="name">c-mode</span> . lsp))</span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  <span class="comment">;; 用 clangd 作为后端</span></span><br><span class="line">  (<span class="name">setq</span> lsp-clients-clangd-executable <span class="string">&quot;clangd&quot;</span>)</span><br><span class="line">  <span class="symbol">:commands</span> lsp)</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> lsp-ui</span><br><span class="line">  <span class="symbol">:commands</span> lsp-ui-mode)</span><br></pre></td></tr></table></figure><p>这样就有：智能补全、跳转、悬停文档、诊断信息等。关于 LSP 的详细使用，包括快捷键绑定等，后面写文章总结。</p><h2 id="自动补全：company-mode">自动补全：company-mode</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">use-package</span> company</span><br><span class="line">  <span class="symbol">:hook</span> (<span class="name">after-init</span> . global-company-mode)</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">setq</span> company-minimum-prefix-length <span class="number">1</span></span><br><span class="line">        company-idle-delay <span class="number">0.0</span>))  <span class="comment">;; 输入就弹出</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; myvec;</span><br></pre></td></tr></table></figure><p>当输入 <code>myvec.</code>的时候，它会弹出一个框，选择相应的成员函数等。</p><h2 id="语法检查：flycheck">语法检查：flycheck</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">use-package</span> flycheck</span><br><span class="line">  <span class="symbol">:hook</span> (<span class="name">prog-mode</span> . flycheck-mode))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="调试：GDB-dap-mode">调试：GDB/ dap-mode</h2><p>Emacs 自带 <code>M-x gdb</code>，也可以用 <code>dap-mode</code>（VSCode 风格的调试器前端）：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">use-package</span> dap-mode</span><br><span class="line">  <span class="symbol">:after</span> lsp-mode</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">dap-auto-configure-mode</span>))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="项目管理：project-el-projectile">项目管理：project.el / projectile</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">use-package</span> projectile</span><br><span class="line">  <span class="symbol">:init</span> (<span class="name">projectile-mode</span> <span class="number">+1</span>)</span><br><span class="line">  <span class="symbol">:bind-keymap</span></span><br><span class="line">  (<span class="string">&quot;C-c p&quot;</span> . projectile-command-map))</span><br></pre></td></tr></table></figure><p>projectile包是一个强大的项目管理和导航工具，详细用法后面写专题文章总结。</p><h2 id="模板与-Snippets">模板与 Snippets</h2><p>这个配置用于设置 Emacs 的 ​<strong>​YASnippet​</strong>​ 系统，这是一个强大的代码片段管理工具，可以显著提高编码效率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(use-package yasnippet</span><br><span class="line">  :hook (prog-mode . yas-minor-mode))</span><br><span class="line"></span><br><span class="line">(use-package yasnippet-snippets) ;; 常用代码片段集合</span><br></pre></td></tr></table></figure><h2 id="完整配置文件">完整配置文件</h2><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;;; init.el --- My Emacs configuration -*- lexical-binding: t; -*-</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; Copyright (C) 2025 编程之禅</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; URL: https://github.com/wangjunstf/emacs-config</span></span><br><span class="line"><span class="comment">;; Version: 1.0</span></span><br><span class="line"></span><br><span class="line">(<span class="name">require</span> &#x27;package)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; code</span></span><br><span class="line">(<span class="name">menu-bar-mode</span> <span class="number">-1</span>)</span><br><span class="line">(<span class="name">tool-bar-mode</span> <span class="number">-1</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">setq</span> package-archives</span><br><span class="line">      &#x27;((<span class="string">&quot;gnu&quot;</span>   . <span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/&quot;</span>)</span><br><span class="line">        (<span class="string">&quot;melpa&quot;</span> . <span class="string">&quot;https://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/&quot;</span>)))</span><br><span class="line">(<span class="name">package-initialize</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 确保在安装 use-package 前刷新包列表</span></span><br><span class="line">(<span class="name">unless</span> (<span class="name">package-installed-p</span> &#x27;use-package)</span><br><span class="line">  (<span class="name">package-refresh-contents</span>)</span><br><span class="line">  (<span class="name">package-install</span> &#x27;use-package))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 正确加载 use-package</span></span><br><span class="line">(<span class="name">require</span> &#x27;use-package)</span><br><span class="line">(<span class="name">setq</span> use-package-always-ensure <span class="literal">t</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 基本C++模式支持</span></span><br><span class="line">(<span class="name">use-package</span> clang-format</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span></span><br><span class="line">  <span class="symbol">:commands</span> (<span class="name">clang-format-buffer</span> clang-format-region)</span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">;; 设置样式</span></span><br><span class="line">  (<span class="name">setq</span> clang-format-style <span class="string">&quot;file&quot;</span>)   <span class="comment">; 使用项目中的 .clang-format 文件</span></span><br><span class="line">  (<span class="name">setq</span> clang-format-fallback-style <span class="string">&quot;llvm&quot;</span>)  <span class="comment">; 无配置文件时的默认样式</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">;; 启用详细日志</span></span><br><span class="line">  <span class="comment">;; (setq clang-format-verbose t)</span></span><br><span class="line">  </span><br><span class="line">  <span class="symbol">:bind</span> ((<span class="string">&quot;C-c f&quot;</span> . clang-format-buffer)</span><br><span class="line">         (<span class="string">&quot;C-c r&quot;</span> . clang-format-region)))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 每次保存时都自动格式化代码</span></span><br><span class="line">(<span class="name">add-hook</span> &#x27;c-mode-common-hook</span><br><span class="line">          (<span class="name">lambda</span> ()</span><br><span class="line">            (<span class="name">add-hook</span> &#x27;before-save-hook &#x27;clang-format-buffer <span class="literal">nil</span> <span class="literal">t</span>)))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 代码补全：LSP+clang</span></span><br><span class="line">(<span class="name">use-package</span> lsp-mode</span><br><span class="line">  <span class="symbol">:ensure</span> <span class="literal">t</span> <span class="comment">; 确保安装包</span></span><br><span class="line">  <span class="symbol">:hook</span> ((<span class="name">c++-mode</span> . lsp)</span><br><span class="line">         (<span class="name">c-mode</span> . lsp))</span><br><span class="line">  <span class="symbol">:init</span></span><br><span class="line">  <span class="comment">;; 用 clangd 作为后端</span></span><br><span class="line">  (<span class="name">setq</span> lsp-clients-clangd-executable <span class="string">&quot;clangd&quot;</span>)</span><br><span class="line">  <span class="symbol">:commands</span> lsp)</span><br><span class="line"></span><br><span class="line">(<span class="name">use-package</span> lsp-ui</span><br><span class="line">  <span class="symbol">:commands</span> lsp-ui-mode)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;; 自动补全</span></span><br><span class="line">(<span class="name">use-package</span> company</span><br><span class="line">  <span class="symbol">:hook</span> (<span class="name">after-init</span> . global-company-mode)</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">setq</span> company-minimum-prefix-length <span class="number">1</span></span><br><span class="line">        company-idle-delay <span class="number">0.0</span>))  <span class="comment">;; 输入就弹出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">;; 语法检查</span></span><br><span class="line">(<span class="name">use-package</span> flycheck</span><br><span class="line">  <span class="symbol">:hook</span> (<span class="name">prog-mode</span> . flycheck-mode))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">;; 调试：GDB</span></span><br><span class="line">(<span class="name">use-package</span> dap-mode</span><br><span class="line">  <span class="symbol">:after</span> lsp-mode</span><br><span class="line">  <span class="symbol">:config</span></span><br><span class="line">  (<span class="name">dap-auto-configure-mode</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">;; 项目管理</span></span><br><span class="line">(<span class="name">use-package</span> projectile</span><br><span class="line">  <span class="symbol">:init</span> (<span class="name">projectile-mode</span> <span class="number">+1</span>)</span><br><span class="line">  <span class="symbol">:bind-keymap</span></span><br><span class="line">  (<span class="string">&quot;C-c p&quot;</span> . projectile-command-map))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Emacs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Emacs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Emacs 入门教程</title>
      <link href="/2025/09/22/emacs-ru-men-jiao-cheng/"/>
      <url>/2025/09/22/emacs-ru-men-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h2 id="Emacs-命令格式">Emacs 命令格式</h2><p>Emacs 按键命令通常包含 CONTROL 键（有时候以CTRL标识）和 META 键（有时以ALT标识）。Emacs 中的命令以以下方式给出<br><code>c-&lt;chr&gt;</code>  表示当输入字符<code>&lt;chr&gt;</code>时按住 CONTROL 键，因此<code>C-f</code>表示：按住 CONTROL 键再输入 f。</p><span id="more"></span><p><code>M-&lt;chr&gt;</code> 表示当输入字符<code>&lt;chr&gt;</code>时按住META（或ALT）键。</p><p>退出Emacs：使用命令：C-x C-c（两个连续的组合键）。<br>退出一个正在运行的命令：C-g</p><h2 id="光标移动">光标移动</h2><p>将光标移动到下一屏开头：C-v<br>将光标移动到上一屏结尾：M-v<br>将光标置于屏幕中央：C-L</p><ul><li>再按一次：将光标置于屏幕顶部</li><li>再按一次：将光标置于屏幕底部</li><li>再按一次：将置于屏幕中央（新一轮循环开始）</li></ul><p>光标移动：上下左右移动分别是：C-p, C-n, C-b, C-f<br>光标移动（基于词）：左右移动分别是：M-b, M-f<br>定位到行头：C-a<br>定位到行尾：C-e<br>定位到句头：M-a<br>定位到句尾：M-e<br>快速移动到文件的开头：M-&lt;（META 小于号）<br>快速移动到文件的末尾：M-&gt;（META 大于号）</p><p>大部分的 Emacs 命令接受数字参数，对于多数命令而言，这些数字参数的作用是指定命令的重复次数，为一个命令指定数字参数主要通过以下两种方法：</p><ol><li>先输入 C-u，然后输入数字作为参数，最后再输入命令</li><li>按住 META 键不放，然后输入数字，最后输入命令</li></ol><p>快速将光标移动到屏幕顶部：C-u 0 C-l</p><p>将光标移动到上一个位置：<code>C-u C-&lt;space&gt;</code></p><h2 id="插入、删除与恢复">插入、删除与恢复</h2><p>插入和命令一样也可以重复指定次数：<br>插入8个<code>*</code>：<code>C-u 8 *</code><br>删除光标后的一个字符：<code>C-d</code><br>移除光标前的一个字符：<code>M-d</code><br>移除从光标到“行尾”间的字符：<code>C-k</code><br>移除从光标到“句尾”间的字符：<code>M-k</code><br><strong>选定文字与移除：</strong></p><ul><li>先按下 <code>C-&lt;SPC&gt;</code>（<code>&lt;SPC&gt;</code>指空格）</li><li>在按下控制光标的任何指令即可选定文字：例如C-p, C-n, C-b, C-f等<br><em>Emacs 有 <strong>kill ring</strong>（剪切环），可以保存多段剪切内容，不是单一的剪贴板。</em><br>移除选定的文字：C-w（剪切选中区域，保存在剪切环）<br>从剪切环粘贴最近一次被 kill 的文本：C-y</li></ul><p><strong>移除整行</strong><br>单独的<code>C-k</code>首先会把一行的内容移除，然后按下第二个<code>C-k</code>会移除换行符<br>如果使用<code>C-u 2 C-k</code>则会把两行以及它们的换行符移除</p><p><strong>召回</strong><br>重新插入被移除的文字这个动作叫做“召回（yanking）”。可以在删除文字的地方召回，也可以在别的地方召回：C-y</p><p>每一次被移除的文字都存储在剪切环中，使用命令<code>M-y</code>输入被移除的一部分按下<code>Tab</code>键，能自动补全相应的内容，按下回车键后自动插入光标处。</p><p><strong>撤销</strong><br>修改了一处文字觉得不满意可以使用以下命令撤销：<code>C-/</code><br>通常<code>C-/</code>会消除一个命令所造成的所有改变；如果在一行中多次地使用<code>C-/</code>，你会把以前的命令也依次撤销。但是有两个例外：</p><ol><li>没有改变文字的命令不算</li><li>从键盘输入的字符以组为单位处理——每组最多20个字符。<br><code>C-x u</code> == <code>C-_</code> == <code>C-/</code></li></ol><h2 id="文件">文件</h2><p>打开文件或新建文件： 按下<code>C-x C-f</code>后输入文件名</p><p>存储文件：<code>C-x C-s</code></p><p>每次对文件进行变更之后再保存，Emacs会自动备份变更前的文件，命名规则为在原文件名之后添加一个<code>~</code>字符。</p><p>要关闭这个特性可以使用以下命令：（按下Tab键可以自动补全命令）<br><code>M-x customize-variable &lt;Return&gt; make-backup-files &lt;Return&gt;</code></p><p>执行完上述命令后会弹出一个新窗格，并自动将光标转移到新窗格，移动光标到<code>Toggle</code>处按下<code>&lt;Return&gt;</code>，再移动光标到<code>&lt;State&gt;</code>处选择数字1（Save for Future Sessions）</p><p>上述命令会自动将配置保存到 <code>~/.emacs</code>中。</p><h2 id="窗格">窗格</h2><p>Emacs 的迷人之处很多，比如能够在屏幕上同时显示多个窗格就是其中之一。<br>Emacs 可以有多个“窗格”，每个窗格显示不同的文字。</p><p>在一个新窗格显示指定命令的文档：C-h k C-f（光标还是位于原来的窗格）<br>关闭文档窗格：C-x 1（只保留当前窗格）</p><p>将屏幕划分成两个窗格（垂直分割）：<code>C-x 2</code><br>将屏幕划分成两个窗格（垂直分割）：<code>C-x 3</code></p><p>滚动下方的窗格：</p><ul><li><code>C-M-v</code>    向下滚动一屏</li><li><code>C-M-S-v</code> 向上滚动一屏</li></ul><p>将光标移动到下方窗格：<code>C-x o</code>    该命令可以遍历所有窗格</p><p>关闭下方窗格，只保留当前窗格：<code>C-x 1</code></p><p>使用以下命令在下面窗格打开一个文件并将光标留在新打开的文件中：<br><code>C-x 4 C-f</code></p><p><code>C-x 0</code>  关闭当前窗格，这个命令会关闭当前选中的窗格，但不会关闭其中的缓冲区。<br><code>C-x 4 0</code> (Ctrl+X 然后按 4，再按 0)，这个命令会关闭当前窗格并杀死其中的缓冲区。<br><code>C-x 1</code>  最大化当前窗格（关闭其他所有窗格）</p><h2 id="多窗口">多窗口</h2><p>Emacs 可以创建多个窗口。窗口由许多窗格以及菜单、滚动条、回显区等组成。在图形界面下，多个窗口可以同时显示出来。在文本终端中，只能同时显示一个。</p><p>使用以下命令新建一个新的窗口：<br><code>M-x make-frame &lt;Return&gt;</code></p><p>使用以下命令关闭光标所在的窗口：<br><code>M-x delete-frame &lt;Return&gt;</code></p><p>切换窗口命令：<br><code>C-x 5 o</code></p><h2 id="缓冲区">缓冲区</h2><p>Emacs 把每个编辑中的文件都放在一个称为“缓冲区”的地方，每打开一个文件，Emacs就会为其开辟一个缓冲区。使用以下命令列出当前所有的缓冲区：<br><code>C-x C-b</code>   列出缓冲区<br><code>C-x 1</code> 关闭缓冲区列表，只保留当前窗格</p><p>不管存在多少缓冲区，任何时候都只能有一个“当前”缓冲区，要想编辑其它缓冲区，就必须“切换”过去，主要有两种办法：<br><code>C-x C-f</code><br><code>C-x b</code> 需要手动输入缓冲区名称，可以自动补全</p><p>有一些特殊的缓冲区，比如<code>*Messages*</code>存放的是在 Emacs 底部出现的消息，这类缓冲区不存储在磁盘中，关闭 Emacs 后就删除了。</p><p><code>C-x s</code> 保存多个缓冲区，该命令会依次列出所有被修改的缓冲区，输入‘y’或’n’进行保存或跳过</p><p><code>C-x k</code> 杀死当前缓冲区（需要确认）<br><code>M-x kill-this-buffer</code> 直接杀死当前缓冲区，无需确认<br><code>M-x kill-some-buffers</code> 这个命令会逐个询问你是否要关闭每个缓冲区。<br><code>M-x kill-other-buffers</code> 关闭除当前缓冲区外的所有缓冲区<br><code>M-x kill-all-buffer</code> 关闭所有文件缓冲区（保留特殊缓冲区）</p><p><strong>使用 ibuffer 管理多个缓冲区</strong><br><code>M-x ibuffer</code>  ibuffer 是管理多个缓冲区的强大工具：<br>在 ibuffer 模式中：</p><ul><li>标记要删除的缓冲区：<code>m</code></li><li>取消标记：<code>u</code></li><li>标记所有：<code>t</code></li><li>执行操作（如杀死）：<code>x</code></li></ul><h2 id="命令集扩展">命令集扩展</h2><p>Emacs 的命令集数量巨大，把它们都对应到 CONTROL 和 META 组合键上显然是不可能的。Emacs 用扩展（extend）命令来解决这个问题，扩展命令有两种风格：<br><code>C-x</code>    字符扩展。C-x 之后输入另一个字符或者组合键<br><code>M-x</code>    命令名扩展。M-x 之后输入一个命令名。</p><p>前面提到的很多命令都是扩展命令，比如<code>C-x C-f</code>用于寻找文件和用<code>C-x C-s</code>保存文件，退出 Emacs 用的 <code>C-x C-c</code>。</p><p><code>C-x</code>的扩展命令有很多：</p><ul><li><code>C-x C-f</code>  打开或新建文件</li><li><code>C-x C-s</code>  保存文件</li><li><code>C-x C-b</code>  列出缓冲区</li><li><code>C-x C-c</code>  离开 Emacs</li><li><code>C-x 1</code>  关掉其它所有窗格，只保留一个。</li><li>C-x u    撤销。</li></ul><p>用命令名扩展的命令通常并不常用：比如 replace-string（字符串替换）这个命令，它会把字符串替换成另一个。在输入 <code>M-x</code>之后，Emacs 会在屏幕底部向你询问并等待你输入命令名。Emacs会自动补全命令，只需输入<code>repl s&lt;TAB&gt;</code>就行了<br><code>M-x replace-string&lt;Return&gt;changed&lt;Return&gt;altered&lt;Return&gt;</code><br>注：这个命令是向后搜索，若要全文搜索，需要光标置于文件开头。</p><p>和 replace-string 有一个类似的命令是 <code>query-replace</code>，两者用法一致，前者直接在整个缓冲区（或选区）中<strong>一次性替换所有匹配</strong>，后者<strong>逐个匹配地替换</strong>，每次替换前询问用户（通过输入y或n）。</p><p>也可以模糊匹配并替换（基于正则表达式）：</p><ul><li><code>replace-regexp</code></li><li><code>query-replace-regexp</code></li></ul><h2 id="自动保存">自动保存</h2><p>如果正在编辑的文件在保存前，电脑死机或其他原因导致Emacs异常退出，那么未保存的文件的丢失了。为了避免这种情况的发生，Emacs有自动保存机制，就是定期将正在编辑的文件写入一个”自动保存文件中“。自动保存的文件名的头尾各有一个”#“字符。这个文件会在正常存盘之后被Emacs 删除。</p><p>如果不幸的事情发生了，我们可以打开原来的文件（不是自动保存的文件）然后输入以下命令来恢复：<br><code>M-x recover file &lt;Return&gt;</code>    提示确认的时候，输入 <code>y</code> 确认。</p><h2 id="回显区（ECHO-AREA）">回显区（ECHO AREA）</h2><p>回显区位于 Emacs 的底部，用来 <strong>显示临时信息、提示、和接收用户输入</strong> 的地方。<br>使用以下命令清空回显区中输入到一半的命令：<br><code>C-g C-g</code></p><h2 id="状态栏（MODE-LINE）">状态栏（MODE LINE）</h2><p>位于回显区正上方的一行称为”状态行“。状态栏上显示当前缓冲区和编辑状态的各种信息。</p><table><thead><tr><th>位置</th><th>含义</th></tr></thead><tbody><tr><td><code>U</code></td><td>编码</td></tr><tr><td><code>--</code></td><td>缓冲区状态：<code>--</code>表示未改动，<code>**</code>表示已修改</td></tr><tr><td><code>- </code></td><td>当前文件所在目录</td></tr><tr><td><code>hello-world.cpp</code></td><td>当前缓冲区或文件名</td></tr><tr><td><code>42%</code></td><td>光标在缓冲区的位置（百分比）</td></tr><tr><td>L100</td><td>当前所在行数</td></tr><tr><td><code>(C++//l Abbrev)</code></td><td>当前主模式（Major Mode）和 副模式（Minor Mode）</td></tr></tbody></table><p>Emacs 中有数种主要模式，有的是用来编辑程序代码的比如Lisp模式；编辑各种自然语言文本的Text模式。在任何情况下只能应用一个主模式，其名称会显示在状态栏。</p><p>使用以下命令启用 Text 模式：<br><code>M-x text-mode &lt;Return&gt;</code></p><p>在 text-mode 模式下，M-f 和 M-b 把单引号（<code>'</code>）视为词的一部分。<br>在 Fundamental 模式中，M-f 和 M-b 都单引号视为分隔单词的符号。</p><p>使用以下命令查看当前主模式的文档：<code>C-h m</code></p><p>除了主模式外，还同时有一个“辅模式（minor mode）”，辅模式不能代替主模式，而是提供一些辅助的功能。每个辅模式都可以独立的开启和关闭，可以使用一个或同时使用多个辅助模式。</p><p>有一个叫做自动折行（Auto Fill）的辅助模式很有用，启用自动折行后，Emacs 会在你打字超过一行边界时自动替你换行（在边界处输入空格，可自动识别换行，这个规则主要争对）。使用以下命令启用自动折行：<br><code>M-x auto-fill-mode &lt;Return&gt;</code></p><p>针对于自动折行模式，用以下命令设置每行最大字符，多出会自动折行：<br>对于命令<code>C-x f</code>并传递参数 20，完整的命令格式：<code>C-20 C-x f</code> （此处设置为20，它的原始默认值是70）<br>运行完上述命令后需要使用<code>M-q</code>手动折行，光标必须位于需要折行的那一段里。</p><h2 id="搜索">搜索</h2><p>向前搜索：<code>C-s</code>  搜索光标右边之后的内容<br>向后搜索：<code>C-r</code>  搜索光标左边之前的内容<br>连续按下命令多次，可以便利匹配的结果。</p><p>在匹配处按下<code>&lt;Enter&gt;</code>，光标将停留匹配处，可以有两种方式回到开始搜索的位置：</p><ul><li><code>C-u C-&lt;space&gt;</code></li><li>不按下<code>&lt;Enter&gt;</code>，按下<code>C-g C-g</code></li></ul><h2 id="递归编辑">递归编辑</h2><p>有时可能会看到<code>[(Fundamental)]</code>，而不是 (Fundamental)。【比如在用 M-%<br>进行交互式替换的时候你又用了 C-s 进行搜索，这时替换模式并没有结束，但<br>你又进入了搜索模式，这就是所谓的递归编辑。】</p><p>离开递归编辑可以用 <code>ESC ESC ESC</code>，这是一个通用的”离开“命令，你甚至可以使用它来关掉多余的窗格，或者离开小缓冲区。</p><h2 id="获得更多帮助">获得更多帮助</h2><p>Emacs 提供了一些命令来查看 Emacs 的命令文档，这些命令都以<code>C-h</code> 开头，这个字符也因此被称为”帮助“字符。</p><p>最基本的帮助功能是：<code>C-h c</code>，输出<code>C-h c</code>之后再输入一个组合键，Emacs会给出这个命令的简要说明，例如：<br><code>C-h c C-p</code></p><p>要获得更多信息，可以使用 <code>C-h k C-p</code></p><p><code>C-h f</code> 解释一个函数，需要输入函数名<br><code>C-h v</code>用来显示 Emacs 变量的文档，Emacs 变量可以被用来”定制“ Emacs 的行为，同样我们需要输入变量的名称。例如：<br><code>C-h v fill-column &lt;RET&gt;</code> 显示当前fill-column值</p><p><code>C-h a</code>  相关命令搜索，输入一个关键词后 Emacs 会列出所有命令名中包含次关键词的命令。这些命令全部都可以用 <code>M-x</code>来启动。对于某些命令来说，相关命令搜索还会列出一两个组合键，例如：</p><p><code>C-h a file &lt;Return&gt;</code><br>Emacs 会在另一个窗格里显示一个<code>M-x</code>命令列表，这个列表包含了所有名称中包含&quot;file&quot;的命令。</p><p><code>C-h i</code>  阅读手册，这个命令打开一个称为<code>*info*</code>的特殊缓冲区，在那里，可以阅读安装在系统里的软件包使用手册。要阅读 Emacs 的使用手册，按 <code>m emacs &lt;Return&gt;</code>就可以。按&quot;?&quot; Emacs 就会进入 Info 的使用指南，Emacs Info 是重要的参考文档。</p><h2 id="主语列表">主语列表</h2><pre><code>command               命令cursor                光标scrolling             滚动numeric argument      数字参数window                窗格 [1]insert                插入delete                删除 [2]kill                  移除 [2]yank                  召回 [2]undo                  撤销file                  文件buffer                缓冲区minibuffer            小缓冲echo area             回显区mode line             状态栏search                搜索incremental search    渐进式搜索 [3]</code></pre><h2 id="Emacs的优势">Emacs的优势</h2><ol><li>高度可定制、几乎无限扩展<ul><li>Emacs 本质上不仅是编辑器，更是一个 <strong>Lisp 运行环境</strong>。</li><li>所有功能（包括菜单、快捷键、行为）都可以通过 <strong>Emacs Lisp</strong> 改写或扩展。</li><li>你可以自己写脚本，也可以安装别人写好的包（MELPA、ELPA）。</li><li>能变成 IDE、邮件客户端、RSS 阅读器、任务管理器、甚至浏览器。</li></ul></li><li>统一的工作环境<ul><li>不同于 VS Code 或 Sublime 等需要频繁切换窗口，Emacs 追求 <strong>“在同一个缓冲区完成所有事”</strong>：<ul><li>写代码</li><li>Git 管理（Magit）</li><li>终端（Eshell / vterm）</li><li>记笔记（Org mode）</li><li>阅读 PDF / 文本</li></ul></li><li>减少上下文切换，工作流极其连贯。</li></ul></li><li>强大的文本编辑能力<ul><li><strong>多光标/矩形编辑</strong>（通过内置 rectangle 或包）</li><li><strong>宏录制与回放</strong>（重复性操作秒变自动化）</li><li><strong>无限撤销/重做</strong>（undo-tree）</li><li><strong>增量搜索/替换</strong> + 正则表达式支持</li><li>强大的代码折叠、语法高亮和跳转。</li></ul></li><li>Org Mode – 独一无二的神器<ul><li>大纲笔记、待办、时间安排、导出 PDF/HTML。</li><li>文学化编程、学术写作、科研笔记、GTDer 的神器。</li><li>一旦熟练 Org Mode，很多单独的工具（Notion/Trello/Obsidian）都可以替代。</li></ul></li><li>跨平台 &amp; 开源 &amp; 免费<ul><li>Windows、Linux、macOS 都能用。</li><li>40+ 年社区沉淀，几乎所有语言和场景都有插件。</li><li>生态稳固，不怕跑路；配置文件可迁移。</li></ul></li><li>键盘驱动、极快的操作效率<ul><li>熟练掌握快捷键后，几乎可以 <strong>不碰鼠标</strong>。</li><li>对熟练用户，效率非常高；对手腕也友好（少鼠标、多键盘）。</li></ul></li><li>长期可持续<ul><li>Emacs 的配置可以跟你走一辈子。</li><li>你可以逐步积累自己的 <strong>.emacs.d</strong>，形成专属“操作系统”。</li><li>不依赖任何公司，不会因商业策略而被砍功能。</li></ul></li><li>社区资源丰富<ul><li>MELPA/ELPA/GNU ELPA 上有数千个包。</li><li>世界各地有大量博客、视频教程、配置分享（doom-emacs、spacemacs）。</li></ul></li></ol><p><strong>适合人群：</strong></p><ul><li>喜欢自己折腾工具的人。</li><li>希望用 <strong>一个统一环境管理工作流</strong> 的人。</li><li>对文本/编程/笔记有高要求的重度用户。</li></ul><p><strong>一句话总结：</strong><br><strong>Emacs = “可编程的编辑器 + 个人操作系统”</strong><br>只要你愿意花时间上手，几乎没有做不到的。</p>]]></content>
      
      
      <categories>
          
          <category> Emacs </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Emacs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>业余无线电——相对值单位</title>
      <link href="/2025/09/18/ye-yu-wu-xian-dian-xiang-dui-zhi-dan-wei/"/>
      <url>/2025/09/18/ye-yu-wu-xian-dian-xiang-dui-zhi-dan-wei/</url>
      
        <content type="html"><![CDATA[<p>本质上就是<strong>用对数（log）来表示比值</strong>，这样方便比较非常大的功率或电压范围。例如：</p><ul><li><strong>绝对值</strong>：直接告诉你功率有多大，例如 1 W、5 W、50 W。</li><li><strong>相对值</strong>：告诉你和某个参考值相比有多大，例如比 1 W 大 10 倍、或小 10 倍。<br>在无线电里，功率、电压、场强常常跨越 <strong>10⁶～10¹² 倍</strong>的范围，直接写数字会非常大，所以大家用<strong>对数刻度</strong>（dB）来表达。</li></ul><span id="more"></span><h2 id="一、先搞清楚什么是-dB">一、先搞清楚什么是 dB</h2><ul><li>dB（分贝） = $10\times\lg{\frac{p2}{p1}}$</li><li>它没有“绝对值”含义，只是“比值”，关键在于<strong>参考值是什么</strong>。</li><li>好处：乘法变加法，方便心算和画图</li></ul><table><thead><tr><th>功率比</th><th>dB值</th><th>直观含义</th></tr></thead><tbody><tr><td>1:1</td><td>0 dB</td><td>相对</td></tr><tr><td>2:1</td><td>+3 dB</td><td>大约大一倍</td></tr><tr><td>10:1</td><td>+10 dB</td><td>大十倍</td></tr><tr><td>100:1</td><td>+20 dB</td><td>大百倍</td></tr><tr><td>1:10</td><td>-10 dB</td><td>小十倍</td></tr></tbody></table><p><strong>下面这些 dB + x 都是“对某个固定参考值”的表示。</strong></p><h2 id="二、dBm：相对-1mW（0-001W）的功率">二、dBm：相对 1mW（0.001W）的功率</h2><table><thead><tr><th>功率（W）</th><th>dBm</th></tr></thead><tbody><tr><td>0.001W（1 mW）</td><td>0 dBm</td></tr><tr><td>0.01W（10mW）</td><td>+10 dBm</td></tr><tr><td>1W</td><td>+30 dBm</td></tr><tr><td>10W</td><td>+40 dBm</td></tr></tbody></table><ul><li>“m” 代表 milliWatt（毫瓦）</li><li>dBm = 10×log₁₀(功率/1 mW)</li></ul><h2 id="三、dBW（相对1W的功率）">三、dBW（相对1W的功率）</h2><table><thead><tr><th>功率（W）</th><th>dBW</th></tr></thead><tbody><tr><td>1W</td><td>0 dBW</td></tr><tr><td>10W</td><td>+10 dBW</td></tr><tr><td>100W</td><td>+20 dBW</td></tr><tr><td>0.1W</td><td>-10 dBW</td></tr></tbody></table><ul><li>“W” 代表 Watt（瓦特）</li><li>dBW = 10×log₁₀(功率/1 W)</li><li>所以 <strong>dBW = dBm – 30</strong>（因为 1 W = 1000 mW）。</li></ul><h2 id="四、dBi（相对“理想各向同性天线”的增益）">四、dBi（相对“理想各向同性天线”的增益）</h2><table><thead><tr><th>天线</th><th>增益</th></tr></thead><tbody><tr><td>各向同性天线</td><td>0 dBi</td></tr><tr><td>常见偶极子天线</td><td>~2.15 dBi</td></tr><tr><td>高增益定向天线</td><td>10-20 dBi 甚至更高</td></tr></tbody></table><ul><li>“i” = isotropic，各向同性天线</li><li>dBi = 天线增益相对<strong>理论各向同性天线</strong>的值</li><li>越高代表在某方向辐射更集中。</li></ul><h2 id="五、dBd（相对“半波偶极子天线”的增益）">五、dBd（相对“半波偶极子天线”的增益）</h2><table><thead><tr><th>天线</th><th>增益</th></tr></thead><tbody><tr><td>半波偶极子</td><td>0</td></tr><tr><td>各向同性天线</td><td>-2.15 dBd</td></tr><tr><td>高增益定向天线</td><td>+8 dBd</td></tr></tbody></table><ul><li>“d” = dipole（半波偶极子）</li><li>dBd = 天线增益相对<strong>半波偶极子</strong>的值</li><li>半波偶极子比各向同性天线多约 2.15 dB 增益，因此：<br>$$dBi = dBd + 2.15$$</li></ul><h2 id="六、dBc（相对“载波”的电平）">六、dBc（相对“载波”的电平）</h2><table><thead><tr><th>信号</th><th>dBc</th></tr></thead><tbody><tr><td>载波本身</td><td>0 dBc</td></tr><tr><td>副载波/谐波</td><td>-30 dBc</td></tr><tr><td>杂散信号</td><td>-60 dBc</td></tr></tbody></table><ul><li>“c” = carrier（载波）</li><li>dBc = 某个信号功率相对<strong>载波功率</strong>的比值</li><li>常用来表示杂散、谐波、边带等的抑制程度。</li></ul><table><thead><tr><th>单位</th><th>参考点</th><th>用途</th></tr></thead><tbody><tr><td>dBm</td><td>1 mW</td><td>功率（毫瓦基准）</td></tr><tr><td>dBW</td><td>1 W</td><td>功率（瓦特基准）</td></tr><tr><td>dBi</td><td>理论各向同性天线</td><td>天线增益</td></tr><tr><td>dBd</td><td>半波偶极子</td><td>天线增益</td></tr><tr><td>dBc</td><td>载波功率</td><td>谐波、杂散抑制或边带电平</td></tr></tbody></table><h2 id="七、总结对照表">七、总结对照表</h2><table><thead><tr><th>单位</th><th>参考点</th><th>用途</th></tr></thead><tbody><tr><td>dBm</td><td>1 mW</td><td>功率（毫瓦基准）</td></tr><tr><td>dBW</td><td>1 W</td><td>功率（瓦特基准）</td></tr><tr><td>dBi</td><td>理论各向同性天线</td><td>天线增益</td></tr><tr><td>dBd</td><td>半波偶极子</td><td>天线增益</td></tr><tr><td>dBc</td><td>载波功率</td><td>谐波、杂散抑制或边带电平</td></tr></tbody></table><ul><li>dB + m / W = 功率基准</li><li>dB + i / d = 天线基准</li><li>dB + c = 载波基准</li></ul>]]></content>
      
      
      <categories>
          
          <category> 无线电 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dB </tag>
            
            <tag> dBm </tag>
            
            <tag> dBW </tag>
            
            <tag> dBi </tag>
            
            <tag> dBd </tag>
            
            <tag> dBc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中auto类型推导的常见用法</title>
      <link href="/2025/09/18/cpp-zhong-auto-lei-xing-tui-dao-de-chang-jian-yong-fa/"/>
      <url>/2025/09/18/cpp-zhong-auto-lei-xing-tui-dao-de-chang-jian-yong-fa/</url>
      
        <content type="html"><![CDATA[<p>C++ 中的 <code>auto</code> 关键字是一个强大的类型推导工具，它能显著简化代码并提高可读性。下面我将为你详细解析它的各种用法、注意事项和最佳实践。</p><h3 id="🧠-一、auto-的基本概念">🧠 一、auto 的基本概念</h3><p><code>auto</code> 是 C++11 标准引入的关键字，用于在声明变量时​<strong>​自动推导变量的类型​</strong>​，推导依据是变量的初始化表达式。</p><span id="more"></span><p>​<strong>​基本示例：​</strong>​</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto x = 42;        // x 被推导为 int</span><br><span class="line">auto y = 3.14;      // y 被推导为 double</span><br><span class="line">auto z = &quot;Hello&quot;;   // z 被推导为 const char*</span><br></pre></td></tr></table></figure><p>​<strong>​优势：​</strong>​</p><ul><li>​<strong>​代码简洁​</strong>​：避免书写冗长的类型名，特别是复杂的模板类型。</li><li>​<strong>​泛型编程​</strong>​：更容易编写适用于不同类型的模板代码。</li><li>​<strong>​可维护性​</strong>​：如果初始化表达式的类型改变（例如函数返回类型改变），<code>auto</code> 变量类型会自动适应，无需修改代码。</li></ul><h3 id="🔍-二、在范围for循环中的用法">🔍 二、在范围for循环中的用法</h3><p>在范围for循环（Range-based for loop）中，<code>auto</code> 的用法主要有以下几种形式，各有不同的语义和用途。</p><table><thead><tr><th>用法</th><th>是否复制元素</th><th>是否可修改原元素</th><th>适用场景</th></tr></thead><tbody><tr><td>​<strong>​<code>auto</code>​</strong>​</td><td>是</td><td>否（修改的是副本）</td><td>需修改副本或元素很小（如内置类型）</td></tr><tr><td>​<strong>​<code>auto&amp;</code>​</strong>​</td><td>否</td><td>是</td><td>需要修改容器中的元素</td></tr><tr><td>​<strong>​<code>const auto&amp;</code>​</strong>​</td><td>否</td><td>否</td><td>​<strong>​只读访问​</strong>​，适用于所有类型，​<strong>​推荐首选​</strong>​</td></tr><tr><td>​<strong>​<code>auto&amp;&amp;</code>​</strong>​</td><td>否</td><td>是</td><td>泛型编程，需处理左值和右值</td></tr></tbody></table><ol><li><p>​<strong>​<code>auto</code>（值拷贝）​</strong>​<br>创建容器中元素的​<strong>​副本​</strong>​。修改的是副本，不影响原容器。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec = &#123;1, 2, 3&#125;;</span><br><span class="line">for (auto elem : vec) &#123; </span><br><span class="line">    elem *= 2; // 只修改副本，原容器元素不变</span><br><span class="line">&#125;</span><br><span class="line">// vec 仍为 &#123;1, 2, 3&#125;</span><br></pre></td></tr></table></figure><p>​<strong>​适用场景​</strong>​：元素是内置类型（如 <code>int</code>, <code>double</code>）且拷贝开销小，或者​<strong>​需要修改元素的副本​</strong>​而不影响原容器时。</p></li><li><p>​<strong>​<code>auto&amp;</code>（左值引用）​</strong>​<br>创建容器中元素的​<strong>​引用​</strong>​。修改它会直接影响原容器。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec = &#123;1, 2, 3&#125;;</span><br><span class="line">for (auto&amp; elem : vec) &#123; </span><br><span class="line">    elem *= 2; // 直接修改原元素</span><br><span class="line">&#125;</span><br><span class="line">// vec 变为 &#123;2, 4, 6&#125;</span><br></pre></td></tr></table></figure><p>​<strong>​适用场景​</strong>​：需要修改原容器中的元素，或者元素是大型对象（如 <code>std::string</code>, 自定义类）​<strong>​希望避免复制开销​</strong>​但需要修改时。</p></li><li><p>​<strong>​<code>const auto&amp;</code>（常量引用）​</strong>​<br>创建容器中元素的​<strong>​常量引用​</strong>​。​<strong>​只读访问，无法修改​</strong>​，且避免复制开销。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; words = &#123;&quot;Hello&quot;, &quot;World&quot;&#125;;</span><br><span class="line">for (const auto&amp; word : words) &#123;</span><br><span class="line">    std::cout &lt;&lt; word &lt;&lt; &quot; &quot;; // 可读</span><br><span class="line">    // word = &quot;Hi&quot;; // 错误！不可修改</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>​适用场景​</strong>​：​<strong>​绝大多数只读遍历的情况​</strong>​，尤其是元素为大型对象时。​<strong>​这是最安全、最高效的只读遍历方式​</strong>​，也是​<strong>​推荐首选​</strong>​的写法。</p></li><li><p>​<strong>​<code>auto&amp;&amp;</code>（通用引用，Universal Reference）​</strong>​<br>这是最灵活的形式，可以绑定到左值、右值、const和非const对象。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;std::string&gt; getVector(); // 返回一个临时vector（右值）</span><br><span class="line">// ...</span><br><span class="line">for (auto&amp;&amp; elem : getVector()) &#123; // 可以绑定到临时容器中的元素</span><br><span class="line">    std::cout &lt;&lt; elem; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​<strong>​适用场景​</strong>​：主要用于​<strong>​泛型编程和模板代码​</strong>​，或者需要​<strong>​完美转发（perfect forwarding）​</strong>​ 的场景。在普通代码中，<code>const auto&amp;</code> 或 <code>auto&amp;</code> 通常更清晰直观。</p></li></ol><h3 id="⚠️-三、注意事项与常见陷阱">⚠️ 三、注意事项与常见陷阱</h3><ol><li><p>​<strong>​必须初始化​</strong>​<br><code>auto</code> 变量​<strong>​必须在声明时初始化​</strong>​，编译器需要根据初始化表达式来推导类型。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto x; // 错误！缺少初始化表达式，无法推导类型</span><br><span class="line">x = 5;</span><br></pre></td></tr></table></figure></li><li><p>​<strong>​类型推导会丢弃引用和const限定符​</strong>​<br>使用 <code>auto</code> 进行类型推导时，​<strong>​顶层的 <code>const</code> 和引用属性会被丢弃​</strong>​（除非你显式加上它们）。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int i = 10;</span><br><span class="line">const int&amp; cir = i;</span><br><span class="line">auto x = cir; // x 的类型是 int，而不是 const int&amp;</span><br></pre></td></tr></table></figure></li><li><p>​<strong>​与初始化表达式形式的关系​</strong>​<br><code>auto</code> 的推导结果受初始化表达式形式的影响。</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">auto a = 42;    // a 是 int</span><br><span class="line">auto b(42);     // b 是 int</span><br><span class="line">auto c = &#123;42&#125;;  // c 是 std::initializer_list&lt;int&gt;</span><br><span class="line">auto d &#123;42&#125;;    // 在C++17后，d 是 int；之前可能是 initializer_list</span><br></pre></td></tr></table></figure></li><li><p>​<strong>​其他限制​</strong>​<br><code>auto</code> 不能用于函数参数声明（但C++14的泛型Lambda除外）、不能用于非静态成员变量、不能用于数组类型推导等。</p></li></ol><h3 id="💡-四、实用建议">💡 四、实用建议</h3><ul><li>​<strong>​优先考虑 <code>const auto&amp;</code>​</strong>​：在范围for循环中只读访问元素时，这是​<strong>​默认的首选​</strong>​，因为它安全且高效。</li><li>​<strong>​需要修改元素时用 <code>auto&amp;</code>​</strong>​：当你确实需要修改容器中的元素时使用。</li><li>​<strong>​小型简单类型可用 <code>auto</code>​</strong>​：如果元素是<code>int</code>、<code>double</code>等内置类型，且你需要的是副本，使用 <code>auto</code> 拷贝开销也很小。</li><li>​<strong>​泛型编程考虑 <code>auto&amp;&amp;</code>​</strong>​：在编写模板代码或需要处理各种值类别（左值/右值）时非常强大。</li><li>​<strong>​复杂类型的好帮手​</strong>​：当处理复杂的迭代器类型或嵌套的STL容器（如<code>std::map&lt;std::string, std::vector&lt;int&gt;&gt;</code>）时，<code>auto</code> 能极大简化代码。</li></ul><p>掌握 <code>auto</code> 的关键在于理解其类型推导规则，并根据具体场景（是否需要修改、元素类型大小、是否只读）选择最合适的用法。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> auto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【算法解析】巧用哈希表与组合公式：高效统计数组中相同数对的数量</title>
      <link href="/2025/09/18/qiao-yong-ha-xi-biao-yu-zu-he-gong-shi-gao-xiao-tong-ji-shu-zu-zhong-xiang-tong-shu-dui-de-shu-liang/"/>
      <url>/2025/09/18/qiao-yong-ha-xi-biao-yu-zu-he-gong-shi-gao-xiao-tong-ji-shu-zu-zhong-xiang-tong-shu-dui-de-shu-liang/</url>
      
        <content type="html"><![CDATA[<p>现有以下题目：<a href="https://leetcode.cn/problems/number-of-good-pairs/">1512. 好数对的数目</a><br>现有一个整数数组，要求统计数组中满足条件的索引对 (i, j)（其中 i &lt; j 且 nums[i] = nums[j]）数量。</p><span id="more"></span><h2 id="一、暴力循环">一、暴力循环</h2><p>两层for循环可以遍历所有的索引对，但它的时间复杂度是O(n^2)，空间复杂度是O(n)。代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">numIdenticalPairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">+1</span>;j&lt;nums.<span class="built_in">size</span>(); j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[i]==nums[j])</span><br><span class="line">                    ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有没有办法能把时间复杂度降到O(n)。</p><h2 id="二、组合公式-哈希表">二、组合公式+哈希表</h2><p>输入：nums = [1,2,3,1,1,3]<br>输出：4<br>解释：有 4 组好数对，分别是 (0,3), (0,4), (3,4), (2,5)</p><p>根据上述示例，我们可以对问题进行分解，先计算关于1的对数，再计算关于2的对数，再计算关于3的对数（上述的对数不是数学中的对数）。</p><p>对于每个数字出现的次数：我们可以使用<strong>组合数公式</strong>直接计算出该数字包含多少对：</p><ul><li>当数组中某个数字出现1次时，代表该数字没有满足条件的索引对</li><li>当数组中某个数字出现2次时，代表该数字有1对满足条件的索引对</li><li>当数组中某个数字出现3次时，代表该数字有3对满足条件的索引对</li><li>当数组中某个数字出现4次时，代表该数字有6对满足条件的索引对</li><li>…</li><li>当数组中某个数字出现n次时，代表有$\frac{n*(n-1)}{2}$对满足条件的索引对</li></ul><p>上述公式表示<code>n</code>个元素中选取 2 个的组合数，更用法的公式如：从n个元素选出m个元素的公式为：<br>$$\frac{n!}{m!(n-m)!}$$</p><p>我们只需计算出给定数组中不同数字的组合数并相加就能得到答案。<br>使用哈希表（如 <code>std::unordered_map</code>）遍历数组，记录每个数字出现的次数，时间复杂度O(n)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">numIdenticalPairs</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    std::unordered_map&lt;<span class="type">int</span> ,<span class="type">int</span>&gt; freq;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> num : nums)</span><br><span class="line">        freq[num]++;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">const</span> <span class="keyword">auto</span>&amp; entry : freq)&#123;</span><br><span class="line">        <span class="type">int</span> v = entry.second;</span><br><span class="line">        count += v * (v - <span class="number">1</span>) / <span class="number">2</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 示例测试</span></span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="type">int</span> result = <span class="built_in">numIdenticalPairs</span>(nums);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Number of identical pairs: &quot;</span> &lt;&lt; result &lt;&lt; std::endl; <span class="comment">// 输出应为 4</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中第二个for循环用了auto类型推导，关于它的详细用法可以参考：<br><a href="https://wangjunstf.github.io/2025/09/18/cpp-zhong-auto-lei-xing-tui-dao-de-chang-jian-yong-fa/" title="C++中auto类型推导的常见用法">【算法解析】巧用哈希表与组合公式：高效统计数组中相同数对的数量</a></p><p>在这里它根据freq的元素类型推断entry的类型。</p><p>代码中的 <code>entry</code> 是一个​<strong>​常量引用​</strong>​，它指向 <code>std::unordered_map&lt;int, int&gt;</code> 中的一个键值对（<code>std::pair</code>）。更准确地说，它的类型是：</p><p><code>const std::pair&lt;const int, int&gt;&amp;</code></p><p>下面是关键点的解析：</p><table><thead><tr><th>组成部分</th><th>含义</th><th>说明</th></tr></thead><tbody><tr><td>​<strong>​<code>const</code>​</strong>​</td><td>常量</td><td>表示不能通过 <code>entry</code> 修改 <code>unordered_map</code> 中的元素。</td></tr><tr><td>​<strong>​<code>std::pair</code>​</strong>​</td><td>键值对</td><td><code>unordered_map</code> 中的每个元素都是一个 <code>pair</code> 对象。</td></tr><tr><td>​<strong>​<code>&lt;const int, int&gt;</code>​</strong>​</td><td>模板参数</td><td><code>pair</code> 的第一个成员（<code>first</code>）是 ​<strong>​<code>const int</code>​</strong>​（键），第二个成员（<code>second</code>）是 ​<strong>​<code>int</code>​</strong>​（值）。</td></tr><tr><td>​<strong>​<code>&amp;</code>​</strong>​</td><td>引用</td><td>避免在循环中拷贝整个 <code>pair</code> 对象，提升效率。</td></tr></tbody></table><p>在你的代码中：</p><ul><li><code>entry.first</code> 是键（即数组中的数字，例如 <code>1</code>, <code>2</code>, <code>3</code>），因为是 <code>const</code>，所以不可修改。</li><li><code>entry.second</code> 是值（即该数字出现的频率，例如 <code>3</code>, <code>2</code>, <code>1</code>），这里被用来计算好数对的数量：<code>count += v * (v - 1) / 2;</code>。</li></ul><p>这种使用 <code>const auto&amp;</code> 来遍历关联容器的做法非常常见，因为它​<strong>​既安全又高效​</strong>​。</p><p>简单来说，<code>entry</code> 就像是 <code>freq</code> 这个哈希表中每个单元的只读视图，让你能安全地读取每个数字及其对应的出现次数。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 哈希表 </tag>
            
            <tag> 组合公式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求两数最小公倍数的通解（通用方法解法）</title>
      <link href="/2025/09/17/qiu-liang-shu-zui-xiao-gong-bei-shu-de-tong-jie/"/>
      <url>/2025/09/17/qiu-liang-shu-zui-xiao-gong-bei-shu-de-tong-jie/</url>
      
        <content type="html"><![CDATA[<p>求两个数<code>a</code>和<code>b</code>的最小公倍数，最常用和最有效的方法是利用它们与最大公约数（Greatest Common Divisor, GCD）之间的关系。</p><h2 id="核心公式">核心公式</h2><p>两个数的最小公倍数等于这两个数的乘积除以它们的最大公约数。用数学公式表示为：<br>$$LCM(a,b)=\frac{|a * b|}{GCD(a,b)}$$</p><span id="more"></span><p>其中：</p><ul><li><code>LCM(a, b)</code>是<code>a</code>和<code>b</code>的最小公倍数</li><li><code>GCD(a, b)</code>是<code>a</code>和<code>b</code>的最大公约数</li><li><code>|a*b|</code>表示<code>a</code>和<code>b</code>乘积的绝对值（确保结果为正）。</li></ul><h2 id="求解步骤">求解步骤</h2><ol><li>计算最大公约数(GCD)：首先，你需要一个函数来计算两个数的最大公约数。最经典的算法是欧几里得算法（Euclidean Algorithm），也称为辗转相除法。<ul><li><strong>欧几里得算法原理：</strong> 两个整数 <code>a</code> 和 <code>b</code>（假设 <code>a &gt; b</code>）的最大公约数等于 <code>b</code> 和 <code>a</code> 除以 <code>b</code> 的余数（<code>a % b</code>）的最大公约数。我们不断重复这个过程，直到余数为0，此时的除数就是原始两个数的最大公约数。</li></ul></li><li><strong>应用公式：</strong> 计算出 <code>GCD(a, b)</code> 后，直接代入上述核心公式，即可求得最小公倍数。</li></ol><h2 id="举例说明">举例说明</h2><p>求 12 和 18 的最小公倍数。</p><ol><li>求GCD(12, 18)：<ul><li><code>18 % 12 = 6</code></li><li><code>12 % 6 = 0</code></li><li>余数为0，所以GCD(12, 18)=6</li></ul></li><li>计算LCM<ul><li><code> LCM(12, 18) = (12 * 18) / GCD(12, 18)</code></li><li><code>LCM(12, 18) = 216 / 6</code></li><li><code>LCM(12, 18) = 36</code></li></ul></li></ol><h2 id="C-代码实现">C++ 代码实现</h2><p>下面是使用 C++ 实现上述逻辑的代码。代码结构清晰，包含一个计算 GCD 的函数和一个计算 LCM 的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">// C++17 标准库中包含了 std::gcd 和 std::lcm</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span></span>;</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">lcm</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// --- 方法一：手动实现 GCD 和 LCM (推荐，兼容性好) ---</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使用欧几里得算法计算最大公约数 (GCD)</span></span><br><span class="line"><span class="comment"> * * @param a 第一个整数</span></span><br><span class="line"><span class="comment"> * @param b 第二个整数</span></span><br><span class="line"><span class="comment"> * @return long long a 和 b 的最大公约数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> temp = b;</span><br><span class="line">        b = a % b;</span><br><span class="line">        a = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使用公式 (a * b) / gcd(a, b) 计算最小公倍数 (LCM)</span></span><br><span class="line"><span class="comment"> * * @param a 第一个整数</span></span><br><span class="line"><span class="comment"> * @param b 第二个整数</span></span><br><span class="line"><span class="comment"> * @return long long a 和 b 的最小公倍数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">lcm</span><span class="params">(<span class="type">long</span> <span class="type">long</span> a, <span class="type">long</span> <span class="type">long</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">0</span> || b == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 0 和任何数的最小公倍数是 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 为了防止 a * b 溢出，可以先做除法</span></span><br><span class="line">    <span class="comment">// a * (b / gcd(a,b)) 同样有效</span></span><br><span class="line">    <span class="comment">// 使用 std::abs 确保处理负数时结果为正</span></span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">abs</span>(a * b) / <span class="built_in">gcd</span>(a, b); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> num1, num2;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;请输入两个整数: &quot;</span>;</span><br><span class="line">    std::cin &gt;&gt; num1 &gt;&gt; num2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 使用手动实现的函数 ---</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;--- 使用手动实现 ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result_gcd = <span class="built_in">gcd</span>(num1, num2);</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> result_lcm = <span class="built_in">lcm</span>(num1, num2);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最大公约数 (GCD) 是: &quot;</span> &lt;&lt; result_gcd &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最小公倍数 (LCM) 是: &quot;</span> &lt;&lt; result_lcm &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// --- 方法二：使用 C++17 标准库 &lt;numeric&gt; (如果你的编译器支持) ---</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;--- 使用 C++17 标准库 ---&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最大公约数 (GCD) 是: &quot;</span> &lt;&lt; std::<span class="built_in">gcd</span>(num1, num2) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;最小公倍数 (LCM) 是: &quot;</span> &lt;&lt; std::<span class="built_in">lcm</span>(num1, num2) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小公倍数 </tag>
            
            <tag> LCM </tag>
            
            <tag> GCD </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中auto与decltype的区别</title>
      <link href="/2025/09/12/cpp-zhong-auto-yu-decltype-de-qu-bie/"/>
      <url>/2025/09/12/cpp-zhong-auto-yu-decltype-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>理解 <code>decltype</code> 和 <code>auto</code> 的区别对掌握现代 C++ 编程很重要。它们虽然都用于类型推导，但<strong>规则和初衷不同</strong>。下面这个表格汇总了它们的核心区别，帮你快速把握要点。</p><span id="more"></span><table><thead><tr><th style="text-align:left">特性维度</th><th style="text-align:left"><code>auto</code></th><th style="text-align:left"><code>decltype</code></th></tr></thead><tbody><tr><td style="text-align:left"><strong>推导依据</strong></td><td style="text-align:left">根据<strong>初始化表达式</strong>的值进行推导</td><td style="text-align:left">根据给定<strong>表达式</strong>的类型进行推导</td></tr><tr><td style="text-align:left"><strong>初始化要求</strong></td><td style="text-align:left"><strong>必须初始化</strong></td><td style="text-align:left"><strong>可不初始化</strong></td></tr><tr><td style="text-align:left"><strong>引用处理</strong></td><td style="text-align:left"><strong>忽略引用</strong>，推导为底层类型</td><td style="text-align:left"><strong>保留引用</strong>类型</td></tr><tr><td style="text-align:left"><strong>const 处理</strong></td><td style="text-align:left">忽略<strong>顶层 const</strong>（指针/引用类型会保留底层const）</td><td style="text-align:left"><strong>保留 const</strong> 限定符</td></tr><tr><td style="text-align:left"><strong>数组推导</strong></td><td style="text-align:left">退化为指针</td><td style="text-align:left">保留数组类型 (如 <code>int[3]</code>)</td></tr><tr><td style="text-align:left"><strong>函数推导</strong></td><td style="text-align:left">退化为函数指针</td><td style="text-align:left">保留函数类型</td></tr><tr><td style="text-align:left"><strong>主要应用场景</strong></td><td style="text-align:left">简化代码、范围 for 循环、泛型编程</td><td style="text-align:left">模板元编程、依赖表达式类型的返回值推导、精确类型检查</td></tr></tbody></table><h3 id="🧠-详解推导规则与示例">🧠 详解推导规则与示例</h3><h4 id="1-auto-的推导规则"><strong>1. auto 的推导规则</strong></h4><p><code>auto</code> 根据初始化表达式推导类型，但会<strong>忽略初始化表达式的顶层 <code>const</code> 和引用</strong>，推导出的是基础类型。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ci = i;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;cr = ci;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a = i; <span class="comment">// a 是 int</span></span><br><span class="line"><span class="keyword">auto</span> b = ci; <span class="comment">// b 是 int (忽略顶层 const)</span></span><br><span class="line"><span class="keyword">auto</span> c = cr; <span class="comment">// c 是 int (忽略引用和顶层 const)</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i; <span class="comment">// d 是 int* (保留指针)</span></span><br></pre></td></tr></table></figure><p>若要保留引用和 <code>const</code>，需显式指明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="keyword">auto</span> e = ci; <span class="comment">// e 是 const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;f = ci; <span class="comment">// f 是 const int&amp;，绑定到 ci</span></span><br></pre></td></tr></table></figure><h4 id="2-decltype-的推导规则"><strong>2. decltype 的推导规则</strong></h4><p><code>decltype</code> 直接<strong>查询表达式的类型</strong>，会<strong>完整保留</strong>表达式的类型（包括引用和 <code>const</code>）。它的规则稍微复杂一些：</p><ul><li>如果 <code>exp</code> 是一个<strong>未被括号包围的变量、成员访问或表达式</strong>，<code>decltype(exp)</code> 的类型与该实体的声明类型完全一致。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) x = <span class="number">0</span>; <span class="comment">// x 的类型是 const int</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y = x; <span class="comment">// y 的类型是 const int&amp;，必须初始化</span></span><br></pre></td></tr></table></figure></li><li>如果 <code>exp</code> 是<strong>函数调用</strong>，<code>decltype(exp)</code> 的类型与函数返回值的类型一致。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getInt</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">decltype</span>(<span class="built_in">getInt</span>()) z; <span class="comment">// z 的类型是 int&amp;，必须初始化</span></span><br></pre></td></tr></table></figure></li><li>如果 <code>exp</code> 是一个<strong>左值</strong>，或是<strong>被括号包围的表达式</strong>，<code>decltype(exp)</code> 会推导出<strong>该类型的引用</strong>。这是 <code>decltype</code> 的一个特殊规则。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">decltype</span>((i)) k = i; <span class="comment">// k 是 int&amp;，因为 (i) 是左值表达式</span></span><br><span class="line"><span class="comment">// decltype(i) j; // j 是 int</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-decltype-auto"><strong>3. decltype(auto)</strong></h4><p>C++14 引入了 <code>decltype(auto)</code>，它用 <code>decltype</code> 的规则来推导 <code>auto</code>，旨在<strong>完美转发表达式的类型</strong>（保留引用和 <code>const</code>）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> &amp;ci = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> a1 = ci; <span class="comment">// a1 是 int</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) a2 = ci; <span class="comment">// a2 是 const int&amp;</span></span><br></pre></td></tr></table></figure><h3 id="⚠️-使用陷阱与最佳实践">⚠️ 使用陷阱与最佳实践</h3><ol><li><strong><code>auto</code> 会忽略顶层 <code>const</code> 和引用</strong>：若需要引用或常量，显式使用 <code>auto&amp;</code>、<code>const auto</code> 或 <code>const auto&amp;</code>。</li><li><strong><code>decltype</code> 的括号陷阱</strong>：<code>decltype((variable))</code> 会得到引用类型，而 <code>decltype(variable)</code> 则不会。使用时需特别注意括号。</li><li><strong>返回引用时</strong>：若函数返回引用，使用 <code>auto</code> 会返回值类型，用 <code>decltype(auto)</code> 可保留引用类型。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">getRef</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">auto</span> val = <span class="built_in">getRef</span>(); <span class="comment">// val 是 int，是副本</span></span><br><span class="line"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) ref = <span class="built_in">getRef</span>(); <span class="comment">// ref 是 int&amp;，是别名</span></span><br></pre></td></tr></table></figure></li><li><strong><code>auto</code> 不能用于非静态成员变量</strong>：类定义中无法使用 <code>auto</code> 声明非静态成员变量（C++17 前也不能用于静态成员）。</li></ol><h3 id="💡-如何选择">💡 如何选择</h3><ul><li><strong>日常编码，简化声明</strong>：优先使用 <code>auto</code>，特别是在 STL 迭代器、范围 for 循环或类型明显且冗长时。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::map&lt;std::string, <span class="type">int</span>&gt; myMap;</span><br><span class="line"><span class="comment">// 不用写冗长的迭代器类型</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = myMap.<span class="built_in">begin</span>(); it != myMap.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>需要精确类型，泛型编程</strong>：使用 <code>decltype</code>，特别是在模板编程、推导表达式类型或函数返回类型时。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T1 a, T2 b)</span> -&gt; <span class="title">decltype</span><span class="params">(a + b)</span> </span>&#123; <span class="comment">// C++11 风格返回类型后置</span></span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>完美转发表达式类型</strong>：使用 <code>decltype(auto)</code>，确保不丢失引用和 <code>const</code> 属性。</li></ul><p>希望这些解释和示例能帮助你清晰理解 <code>auto</code> 和 <code>decltype</code> 的区别。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> auto </tag>
            
            <tag> decltype </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>导数的概念和应用</title>
      <link href="/2025/01/19/dao-shu-de-gai-nian-he-ying-yong/"/>
      <url>/2025/01/19/dao-shu-de-gai-nian-he-ying-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="一-什么是导数">一 什么是导数</h2><p>导数是微积分中的一个重要概念，它描述了一个函数$f(x)$在某一点的变化率或斜率，斜率越大，函数图像越陡，$x$增加相同的数值，$f(x)$变化更快。</p><p>如果一个函数$f(x)$在某一点$x=a$可导，那么导数就是$f(x)$在$x=a$这一点的变化率。从几何上看，导数可以看作是曲线$y=f(x)$在点$a,f(a)$处的切线的斜率。</p><span id="more"></span><h2 id="二-导数的定义（极限形式）">二 导数的定义（极限形式）</h2><p>导数的正式定义是通过极限来表示的：<br>$$<br>f′(a)=\lim_{h \to 0} \frac{f(a+h) - f(a)}{h}<br>$$<br>这里，$f′(a)$表示函数$f(x)$在$x=a$处的导数。这个定义可以理解为：当 $x$ 从 $a$ 向右或向左微小变化（即增加一个很小的量 $h$）时，函数$f(x)$的变化率是如何变化的。</p><h2 id="三-导数的几何意义">三 导数的几何意义</h2><p>导数的几何意义是描述曲线在某一点的切线的斜率。具体来说，设函数 $f(x)$ 在$x=a$处有导数，那么切线的斜率就等于导数$f′(a)$。如果导数为正，切线的斜率为正，表示函数在该点向上升；如果导数为负，切线的斜率为负，表示函数在该点向下降；如果导数为零，切线平行于$x$轴，表示函数在该点没有变化，可能是极值点。</p><h2 id="四-导数的物理意义">四 导数的物理意义</h2><p>在物理中，导数通常用来描述物体的瞬时变化速率。比如：</p><ul><li>位置函数的导数是速度，表示物体在某一时刻的速度。</li><li>速度函数的导数是加速度，表示物体的速度变化速率。<br>例如，假设位置随时间变化的函数$s(t)$，那么物体在时刻$t$的速度$v(t)$就是位置函数的导数：$$v(t)=\frac{ds}{dt}$$</li></ul><h2 id="五-怎么求导数">五 怎么求导数</h2><p>求导数的方法依赖于函数的类型和所用的求导规则。以下是几种常见的求导方法：</p><h3 id="5-1-常见函数的导数">5.1 常见函数的导数</h3><ul><li>$\frac{d}{dx}( c )=0$   (常熟的导数为0)</li><li>$\frac{d}{dx}(x^n)=nx^{n-1}$ （幂函数的导数）</li><li>$\frac{d}{dx}(sinx)=cosx$ （正弦函数的导数）</li><li>$\frac{d}{dx}(cosx)=-sinx$ （余弦函数的导数）</li><li>$\frac{d}{dx}(e^x)=e^x$ （指数函数的导数）</li><li>$\frac{d}{dx}(lnx)=\frac{1}{x}$ （自然对数的导数）</li></ul><h3 id="5-2-常见的导数法则">5.2 常见的导数法则</h3><ul><li>常数法则：如果$f(x)=c$，其中$c$是常数，则$f′(x)=0$</li><li>幂函数法则：如果$f(x)=x^n$，则$f′(x)=nx^{n-1}$</li><li>和差法则：如果$f(x)=g(x)+h(x)$，则$f’(x)=g’(x)+h’(x)$</li><li>积法则：$f(x)=g(x)*h(x)$，则$f’(x)=g’(x)h(x)+g(x)h’(x)$</li><li>商法则：如果$f(x)=\frac{g(x)}{h(x)}$，则$f’(x)=\frac{g’(x)h(x)-g(x)h’(x)}{h(x)^2}$</li><li>链式法则：如果$f(x)=g(h(x))$，则$f’(x)=g’(h(x))*h’(x)$</li></ul><h2 id="六-导数的应用">六 导数的应用</h2><p>导数在很多领域都有重要的应用，尤其是在科学、工程、经济学等领域。常见的应用包括：</p><ul><li><strong>优化问题</strong>：寻找函数的最大值或最小值，通常通过求导并令导数等于0来实现。</li><li><strong>物理学</strong>：描述物体的运动，速度和加速度等。</li><li><strong>经济学</strong>：在成本函数、收益函数和利润函数等中，导数可以帮助分析利润最大化、成本最小化等问题。</li><li><strong>机器学习</strong>：在训练模型时，导数帮助我们优化目标函数，常见的梯度下降法依赖于求导数来更新参数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Math </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 导数 </tag>
            
            <tag> 导数法则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Common Lisp实践：建立单元测试框架</title>
      <link href="/2025/01/16/common-lisp-shi-jian-jian-li-dan-yuan-ce-shi-kuang-jia/"/>
      <url>/2025/01/16/common-lisp-shi-jian-jian-li-dan-yuan-ce-shi-kuang-jia/</url>
      
        <content type="html"><![CDATA[<p><strong>单元测试框架</strong>是一种工具或库，用于帮助开发人员创建、组织、运行和报告代码的单元测试。<br><strong>单元测试</strong>是指对软件系统中最小的可测试单元（通常是一个函数或方法）进行的验证测试。</p><span id="more"></span><p>常见的单元测试框架包括：</p><ul><li><strong>Python</strong>: <code>unittest</code>、<code>pytest</code></li><li><strong>Java</strong>: <code>JUnit</code></li><li><strong>C++</strong>: <code>Google Test (gtest)</code></li><li><strong>JavaScript</strong>: <code>Jest</code>、<code>Mocha</code></li><li><strong>C#</strong>: <code>NUnit</code></li></ul><h3 id="单元测试框架的意义"><strong>单元测试框架的意义</strong></h3><ol><li><strong>保证代码质量</strong>：<ul><li>提前发现潜在的错误。</li><li>避免重复引入已修复的bug。</li></ul></li><li><strong>简化调试和维护</strong>：<ul><li>通过测试定位问题点。</li><li>提升代码可维护性。</li></ul></li><li><strong>加速开发</strong>：<ul><li>通过自动化测试减少手动验证的工作量。</li></ul></li><li><strong>增强信心</strong>：<ul><li>确保修改代码不会破坏已有功能。</li></ul></li><li><strong>推动良好开发习惯</strong>：<ul><li>提高模块化和解耦性。</li></ul></li></ol><h2 id="一-两个最初的尝试">一 两个最初的尝试</h2><p>假设我们要为内置的“+”函数编写测试，那么下面这些可能是合理的测试用例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(= (+ 1 2) 3)</span><br><span class="line">(= (+ 1 2 3) 6)</span><br><span class="line">(= (+ -1 -3) -4)</span><br></pre></td></tr></table></figure><p>当然不必挨个进行测试，可以写个函数来执行上述测试用例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(defun test-+ ()</span><br><span class="line">  (and</span><br><span class="line">   (= (+ 1 2) 3)</span><br><span class="line">   (= (+ 1 2 3) 6)</span><br><span class="line">   (= (+ -1 -3) -4)))</span><br></pre></td></tr></table></figure><p>无论何时，当想运行这组测试用例时，都可以调用test-+，一旦它返回T，就知道所有测试用例通过了。但返回NIL时，说明有测试用例失败了，但无法确定是哪一个。为了找出哪些用例不通过，我们可以这样修改<code>test-+</code>函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(defun test-+ ()</span><br><span class="line">   (format t &quot;~:[FAIL~;Pass~] ... ~a~%&quot; (= (+ 1 2) 3) &#x27;(= (+ 1 2) 3))</span><br><span class="line">   (format t &quot;~:[FAIL~;Pass~] ... ~a~%&quot; (= (+ 1 2 3) 6) &#x27;(= (+ 1 2 3) 6)) </span><br><span class="line">   (format t &quot;~:[FAIL~;Pass~] ... ~a~%&quot; (= (+ -1 -3) -4) &#x27;(= (+ -1 -3) -4))) </span><br></pre></td></tr></table></figure><p>现在每个测试用例都单独报告结果。format指令中 <code>~:[FAIL~;Pass~]</code>会在format的第一个格式实参为假时打印FAIL，其他情况下为Pass。执行test-+函数如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (test-+)</span><br><span class="line">Pass ... (= (+ 1 2) 3)</span><br><span class="line">Pass ... (= (+ 1 2 3) 6)</span><br><span class="line">Pass ... (= (+ -1 -3) -4)</span><br><span class="line">NIL</span><br></pre></td></tr></table></figure><p>当然这个版本的test-+函数也存在一些问题，首先是对format的重复调用过于冗余，尤其后面的测试表达式也存在重复，这些都急需重构。</p><h2 id="二-重构">二 重构</h2><p>我们真正需要的应该是像第一个<code>test-+</code>那样能返回单一的T或NIL值的高效函数，但同时又能像第二个版本那样单独报告错误。</p><p>我们可以创建一个新函数来消除重复的format调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(defun report-result (result form)</span><br><span class="line">  (format t &quot;~:[FAIL~;Pass~] ... ~a~%&quot; result form))</span><br></pre></td></tr></table></figure><p>现在可以使用report-result来代替format。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(defun test-+ ()</span><br><span class="line">  (report-result (= (+ 1 2) 3) &#x27;(= (+ 1 2) 3))</span><br><span class="line">  (report-result (= (+ 1 2 3) 6) &#x27;(= (+ 1 2 3) 6))</span><br><span class="line">  (report-result (= (+ -1 -3) -4) &#x27;(= (+ -1 -3) -4)))</span><br></pre></td></tr></table></figure><p>接下来需要摆脱的是测试用例表达式的重复，理想的情况应该将表达式同时看作代码（为了获得结果）和数据（用来作为标签）。无论何时，若想将代码作为数据来看待，这就意味着需要一个宏。代码可能要写出下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(check (= (+ 1 2) 3))</span><br></pre></td></tr></table></figure><p>并让其与下列形式等同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(report-result (= (+ 1 2) 3) &#x27;(= (+ 1 2) 3))</span><br></pre></td></tr></table></figure><p>很容易写出一个宏来做这种转换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(defmacro check (form)</span><br><span class="line">  `(report-result ,form &#x27;,form))</span><br></pre></td></tr></table></figure><p><strong><code>,form</code></strong>：插入表达式 <code>(= (+ 1 2) 3)</code> 的值（直接展开）。<br><strong><code>',form</code></strong>：插入表达式 <code>(= (+ 1 2) 3)</code> 的符号表示形式，等价于 <code>'(= (+ 1 2) 3)</code>。<br>现在可以改变test-+来使用check。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(defun test-+ ()</span><br><span class="line">  (check (= (+ 1 2) 3))</span><br><span class="line">  (check (= (+ 1 2 3) 6))</span><br><span class="line">  (check (= (+ -1 -3) -4)))</span><br></pre></td></tr></table></figure><p>既然不喜欢重复的代码，为什么不把check的重复也一起消除掉。我们可以定义check来接受任意数量的形式并将它们中的每个都封装在一个对report-result的调用里。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(defmacro check (&amp;body forms)</span><br><span class="line">  `(progn</span><br><span class="line">     ,@(loop for f in forms collect `(report-result ,f &#x27;,f))))</span><br></pre></td></tr></table></figure><ul><li><p><strong>外层 <code>progn</code></strong>：</p><ul><li><code>progn</code> 是 Common Lisp 中的顺序执行结构。它依次执行其中的表达式，并返回最后一个表达式的值。</li></ul></li><li><p><strong><code>loop</code> 循环</strong>：</p><ul><li><strong><code>loop for f in forms</code></strong>：遍历 <code>forms</code> 中的每个表达式。</li><li><strong><code>collect</code></strong>：将处理后的结果收集成一个列表。</li><li><strong><code>(report-result ,f ',f)</code></strong>：对每个表达式 <code>f</code>，生成一个新的表达式：<ul><li><code>,f</code>：将 <code>f</code> 的内容作为求值部分插入。</li><li><code>',f</code>：将 <code>f</code> 的原始符号形式插入为数据。</li></ul></li></ul></li><li><p><strong><code>,@</code> 的作用</strong>：</p><ul><li><strong><code>,@</code></strong> 将 <code>loop</code> 返回的列表“解包”，作为 <code>progn</code> 的多个子表达式插入。</li></ul></li></ul><p>现在我们可以这样写出<code>test-+</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(defun test-+ ()</span><br><span class="line">  (check</span><br><span class="line">    (= (+ 1 2) 3)</span><br><span class="line">    (= (+ 1 2 3) 6)</span><br><span class="line">    (= (+ -1 -3) -4)))</span><br></pre></td></tr></table></figure><h2 id="三-修复返回值">三 修复返回值</h2><p>接下来修改<code>test-+</code>以使返回值可以指示所有测试用例是否都通过了。首先对<code>report-result</code>做点改变，让其可以在报告时顺便返回测试用例结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(defun report-result (result form)</span><br><span class="line">  (format t &quot;~:[FAIL~;Pass~] ... ~a~%&quot; result form)</span><br><span class="line">  result)</span><br></pre></td></tr></table></figure><p>现在<code>report-result</code>返回了它的测试结果，但我们不能简单地使用<code>AND</code>,因为其存在短路，一旦某个测试用例失败就跳过了其余的测试。我们真正需要的是一个像<code>AND</code>那样的操作符，同时又没有短路行为。虽然Common Lisp不提供这样的构造，但我们通过宏可以轻松实现它。我们所需要的宏应该如下所示，现将其称为<code>combine-results</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(combine-results</span><br><span class="line">  (foo)</span><br><span class="line">  (bar)</span><br><span class="line">  (baz))</span><br></pre></td></tr></table></figure><p>并且上述代码应该与下面的代码等同。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(let ((result t))</span><br><span class="line">  (unless (foo) (setf result nil))</span><br><span class="line">  (unless (bar) (setf result nil))</span><br><span class="line">  (unless (baz) (setf result nil))</span><br><span class="line">  result)</span><br></pre></td></tr></table></figure><p>编写这个宏的唯一麻烦之处，需要在展开式中引入一个变量，即前面代码中的<code>result</code>，在宏展开式中使用一个变量的字面名称会导致抽象层面出现漏洞，因此需要使用函数 GENSYM在其每次调用时返回唯一的符号，该符号在全局范围内唯一，避免用户代码中可能存在的变量名冲突。使用一个宏可以简化该过程。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(defmacro with-gensyms ((&amp;rest names) &amp;body body)</span><br><span class="line">  `(let ,(loop for n in names collect `(,n (gensym)))</span><br><span class="line">     ,@body))</span><br></pre></td></tr></table></figure><p>通过使用<code>with-gensyms</code>，我们可以这样定义<code>combine-results</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(defmacro combine-results (&amp;body forms)</span><br><span class="line">  (with-gensyms (result)</span><br><span class="line">    `(let ((,result t))</span><br><span class="line">       ,@(loop for f in forms collect `(unless ,f (setf ,result nil)))</span><br><span class="line">       ,result)))</span><br></pre></td></tr></table></figure><p>现在改变<code>check</code>来使用<code>combine-results</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(defmacro check (&amp;body forms)</span><br><span class="line">  `(combine-results</span><br><span class="line">     ,@(loop for f in forms collect `(report-result ,f &#x27;,f))))</span><br></pre></td></tr></table></figure><p>使用这个版本的<code>check</code>, <code>test-+</code>就可以输出它的三个测试表达式结果，并 返回T以说明所有测试用例都通过了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (test-+)</span><br><span class="line">Pass ... (= (+ 1 2) 3)</span><br><span class="line">Pass ... (= (+ 1 2 3) 6)</span><br><span class="line">Pass ... (= (+ -1 -3) -4)</span><br><span class="line">T</span><br></pre></td></tr></table></figure><p>如果改变一个测试用例而让其失败，最终的返回值也会变成NIL</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (test-+)</span><br><span class="line">Pass ... (= (+ 1 2) 3)</span><br><span class="line">Pass ... (= (+ 1 2 3) 6)</span><br><span class="line">FAIL ... (= (+ -1 -3) -5)</span><br><span class="line">NIL</span><br></pre></td></tr></table></figure><h2 id="四-更好的结果输出">四 更好的结果输出</h2><p>如果编写了大量测试，可能就需要以某种方式将它们组织起来，而不是将它们全部塞进一个函数里。例如，假设想要对“*” 函数添加一些测试用例，可以写一个新测试函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(defun test-* ()</span><br><span class="line">  (check</span><br><span class="line">    (= (* 2 2) 4)</span><br><span class="line">    (= (* 3 5) 15)))</span><br></pre></td></tr></table></figure><p>现在有了两个测试函数，如果想用一个函数来运行所有测试用例，可以这样实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(defun test-arithmetic ()</span><br><span class="line">  (combine-results</span><br><span class="line">    (test-+)</span><br><span class="line">    (test-*)))</span><br></pre></td></tr></table></figure><p>为什么能复用<code>test-arithmetic</code>,我们通过<code>combine-results</code>的展开式就可以知道。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(LET ((#:G245 T))</span><br><span class="line">  (UNLESS (TEST-+) (SETF #:G245 NIL))</span><br><span class="line">  (UNLESS (TEST-*) (SETF #:G245 NIL))</span><br><span class="line">  #:G245)</span><br></pre></td></tr></table></figure><p>上述代码，当评估<code>(TEST-+)</code>的时候，就是评估了所有<code>(TEST-+)</code>下的测试用例。<code>test-arithmetic</code>的运行结果如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (test-arithmetic)</span><br><span class="line">Pass ... (= (+ 1 2) 3)</span><br><span class="line">Pass ... (= (+ 1 2 3) 6)</span><br><span class="line">Pass ... (= (+ -1 -3) -4)</span><br><span class="line">Pass ... (= (* 2 2) 4)</span><br><span class="line">Pass ... (= (* 3 5) 15)</span><br><span class="line">T</span><br></pre></td></tr></table></figure><p>所有的用例都使用Pass来表示通过，如果能在测试结果中显示每个测试用例来自什么函数就好了，因为打印相关的代码使用<code>report-result</code>来表示，生成<code>report-result</code>的<code>check</code>并不知道它是从什么函数被调用的，这就意味着还需要改变调用<code>check</code>的方式，向其传递一个参数使其随后传递给<code>report-result</code>。</p><p>设计动态变量就是用于解决这类问题的。如果创建一个动态变量使得每个测试函数在调用<code>check</code>之前将其函数名绑定在其之上，那么<code>report-result</code>就可以无需理会<code>check</code>来使用它了。</p><p>第一步在最上层声明这个变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(defvar *test-name* nil)</span><br></pre></td></tr></table></figure><p>对<code>report-result</code>稍微改动一些，使其在输出中包括<code>*test-name*</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(format t &quot;~:[FAIL~;Pass~] ... ~a: ~a~%&quot; result *test-name* form)</span><br></pre></td></tr></table></figure><p>为了让<code>*test-name*</code>生效，还需要改变上述两个测试函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">(defun test-+ ()</span><br><span class="line">  (let ((*test-name* &#x27;test-+))</span><br><span class="line">    (check (= (+ 1 2) 3))</span><br><span class="line">    (check (= (+ 1 2 3) 6))</span><br><span class="line">    (check (= (+ -1 -3) -4))))</span><br><span class="line"></span><br><span class="line">(defun test-* ()</span><br><span class="line">  (let ((*test-name* &#x27;test-*))</span><br><span class="line">    (check</span><br><span class="line">      (= (* 2 2) 4)</span><br><span class="line">      (= (* 3 5) 15))))</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在结果都被正确打上了标签：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (test-arithmetic)</span><br><span class="line">Pass ... TEST-+: (= (+ 1 2) 3)</span><br><span class="line">Pass ... TEST-+: (= (+ 1 2 3) 6)</span><br><span class="line">Pass ... TEST-+: (= (+ -1 -3) -4)</span><br><span class="line">Pass ... TEST-*: (= (* 2 2) 4)</span><br><span class="line">Pass ... TEST-*: (= (* 3 5) 15)</span><br><span class="line">T</span><br></pre></td></tr></table></figure><h2 id="五-抽象诞生">五 抽象诞生</h2><p>现在已经实现的代码看似完整了，但还有值得改进的地方，比如对于测试函数<code>test-+</code>或者<code>test-*</code>，每个函数都需要包含其函数名两次，一次作为DEFUN中的名字，另一次在<code>*test-name*</code>的绑定里。导致重复是因为此时测试函数只做了一半抽象。为了得到一个完整抽象，需要用一种方法来表达“这是一个测试函数”，并且这种方法要能将所需的全部代码都生成出来。换句话说，你需要一个宏。</p><p>由于需要捕捉的模式是一个DEFUN加上一些样板代码，所以需要写一个宏使其展开成DEFUN，然后使用该宏去定义测试函数，可以将其命名为<code>deftest</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(defmacro deftest (name parameters &amp;body body)</span><br><span class="line">  `(defun ,name ,parameters</span><br><span class="line">     (let ((*test-name* &#x27;,name))</span><br><span class="line">       ,@body)))</span><br></pre></td></tr></table></figure><p>使用该宏，可以像下面这样重写<code>test-+</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(deftest test-+ ()</span><br><span class="line">  (check</span><br><span class="line">    (= (+ 1 2) 3)</span><br><span class="line">    (= (+ 1 2 3) 6)</span><br><span class="line">    (= (+ -1 -3) -4)))</span><br></pre></td></tr></table></figure><h2 id="六-测试层次体系">六 测试层次体系</h2><p>如果想要将上千个测试用例组织在一起，建立合理的测试层次就很好理解。如果用<code>deftest</code>来定义诸如<code>test-arithmetic</code>这样的测试套件函数，并且对其中的<code>*test-name*</code>作一个小改变，就可以用测试用例的“全称”路径来报告结果，就像下面这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pass ... (TEST-ARITHMETIC TEST-+): (= (+ 1 2) 3)</span><br></pre></td></tr></table></figure><p>因为已经抽象了测试函数的过程，所以就无需修改测试函数的代码从而改变相关的细节。为了使<code>*test-name*</code>保存一个测试函数名的列表而不只是最近进入的测试函数的名字，只需将绑定形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(let ((*test-name* &#x27;,name))</span><br></pre></td></tr></table></figure><p>变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(let ((*test-name* (append *test-name* (list &#x27;,name))))</span><br></pre></td></tr></table></figure><p>由于APPEND返回一个由其实参元素所构成的新列表，这个版本将把<code>*test-name*</code>绑定到一个含有追加其新名字到结尾处的<code>*test-name*</code>的旧内容的列表。每当一个测试函数返回时，<code>*test-name*</code>原有的值将被恢复。</p><p>现在可以用deftest代替DEFUN来重新定义test-arithmetic。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(deftest test-arithmetic ()</span><br><span class="line">  (combine-results</span><br><span class="line">    (test-+)</span><br><span class="line">    (test-*)))</span><br></pre></td></tr></table></figure><p>当然，<code>test-+</code>和<code>test-*</code>也应该用deftest定义。调用<code>test-arithmetic</code>结果如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (test-arithmetic)</span><br><span class="line">Pass ... (TEST-ARITHMETIC TEST-+): (= (+ 1 2) 3)</span><br><span class="line">Pass ... (TEST-ARITHMETIC TEST-+): (= (+ 1 2 3) 6)</span><br><span class="line">Pass ... (TEST-ARITHMETIC TEST-+): (= (+ -1 -3) -4)</span><br><span class="line">Pass ... (TEST-ARITHMETIC TEST-*): (= (* 2 2) 4)</span><br><span class="line">Pass ... (TEST-ARITHMETIC TEST-*): (= (* 3 5) 15)</span><br><span class="line">T</span><br></pre></td></tr></table></figure><p>随着测试套件的增长，可以添加新的测试函数层次，只要用deftest来定义，结果就会正确输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(deftest test-math ()</span><br><span class="line">  (test-arithmetic))</span><br></pre></td></tr></table></figure><p>将如下输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (test-math)</span><br><span class="line">Pass ... (TEST-MATH TEST-ARITHMETIC TEST-+): (= (+ 1 2) 3)</span><br><span class="line">Pass ... (TEST-MATH TEST-ARITHMETIC TEST-+): (= (+ 1 2 3) 6)</span><br><span class="line">Pass ... (TEST-MATH TEST-ARITHMETIC TEST-+): (= (+ -1 -3) -4)</span><br><span class="line">Pass ... (TEST-MATH TEST-ARITHMETIC TEST-*): (= (* 2 2) 4)</span><br><span class="line">Pass ... (TEST-MATH TEST-ARITHMETIC TEST-*): (= (* 3 5) 15)</span><br><span class="line">T</span><br></pre></td></tr></table></figure><h2 id="九-总结">九 总结</h2><p>完整代码如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">(defvar *test-name* nil)</span><br><span class="line"></span><br><span class="line">(defmacro deftest (name parameters &amp;body body)</span><br><span class="line">  `(defun ,name ,parameters</span><br><span class="line">     (let ((*test-name* (append *test-name* (list &#x27;,name))))</span><br><span class="line">       ,@body)))</span><br><span class="line">       </span><br><span class="line">(defmacro with-gensyms ((&amp;rest names) &amp;body body)</span><br><span class="line">  `(let ,(loop for n in names collect `(,n (gensym)))</span><br><span class="line">     ,@body))</span><br><span class="line"></span><br><span class="line">(defun report-result (result form)</span><br><span class="line">  (format t &quot;~:[FAIL~;Pass~] ... ~a: ~a~%&quot; result *test-name* form)</span><br><span class="line">  result)</span><br><span class="line"></span><br><span class="line">(defmacro combine-results (&amp;body forms)</span><br><span class="line">  (with-gensyms (result)</span><br><span class="line">    `(let ((,result t))</span><br><span class="line">       ,@(loop for f in forms collect `(unless ,f (setf ,result nil)))</span><br><span class="line">       ,result)))</span><br><span class="line"></span><br><span class="line">(defmacro check (&amp;body forms)</span><br><span class="line">  `(combine-results</span><br><span class="line">     ,@(loop for f in forms collect `(report-result ,f &#x27;,f))))</span><br></pre></td></tr></table></figure><p>编写测试用例步骤：</p><p>对测试用例进行分类，例如&quot;+&quot;函数的合理分类为，test-+ &lt;&lt; test-math &lt;&lt;  test-arithmetic</p><ol><li>先编写 <code>test-+</code>的测试用例</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(deftest test-+ ()</span><br><span class="line">  (check</span><br><span class="line">    (= (+ 1 2) 3)</span><br><span class="line">    (= (+ 1 2 3) 6)</span><br><span class="line">    (= (+ -1 -3) -4)))</span><br><span class="line"></span><br><span class="line">(deftest test-* ()</span><br><span class="line">  (check</span><br><span class="line">    (= (* 2 2) 4)</span><br><span class="line">    (= (* 3 5) 15)))</span><br></pre></td></tr></table></figure><ol start="2"><li>可选的，将 <code>test-+</code>放到一个更大的分类下，例如<code> test-arithmetic</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(deftest test-arithmetic ()</span><br><span class="line">  (combine-results</span><br><span class="line">    (test-+)</span><br><span class="line">    (test-*)))</span><br></pre></td></tr></table></figure><ol start="3"><li>可选的，将<code>test-arithmetic</code>放到一个更大的分类下，例如<code>test-math</code></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(deftest test-math ()</span><br><span class="line">  (test-arithmetic))</span><br></pre></td></tr></table></figure><ol start="4"><li>执行测试，执行最上层函数<code>test-math</code>就能执行所有的测试用例。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Lisp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Common Lisp </tag>
            
            <tag> 单元测试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Common Lisp如何编写宏</title>
      <link href="/2025/01/16/common-lisp-ru-he-bian-xie-hong/"/>
      <url>/2025/01/16/common-lisp-ru-he-bian-xie-hong/</url>
      
        <content type="html"><![CDATA[<h2 id="一-宏展开期和运行期">一 宏展开期和运行期</h2><p>编写宏就是在编写那些将被编译器用来生成代码并随后编译的程序，只有当所有宏都被完全展开并且产生的代码被编译后，程序才可以实际运行。宏运行的时期被称为宏展开期(macro expansion time)，这和运行期(runtime)是不同的，宏展开期无法访问运行期的数据。</p><span id="more"></span><h2 id="二-DEFMACRO">二 DEFMACRO</h2><p>宏使用DEFMACRO来定义，其基本框架为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(defmacro name (parameter*)</span><br><span class="line">&quot;Optional documentation string.&quot;</span><br><span class="line">body-form*)</span><br></pre></td></tr></table></figure><p>和函数一样，宏由名字，形参列表，可选的文档字符串以及Lisp表达式体所构成。宏的工作是将宏形式转化成做特定事情的代码。</p><p>对于简单的宏，编写一个反引用模板并将宏参数差人到正确的位置。复杂的宏则是一个庞大的独立程序，它将带有配套的助手函数和数据结构。编写完宏以后需要确保它所提供的抽象没有“泄露”其实现细节。</p><p>总结起来，编写宏的步骤如下：<br>（1）辨析示例的宏调用以及它应当展开生成的代码，反之亦然。<br>（2）编写从示例调用的参数中生成手写展开式的代码。<br>（3）确保宏抽象不产生“泄露”。</p><h2 id="三-示例宏：do-primes">三 示例宏：do-primes</h2><p>do-primes 宏类似于DOTIMES和DOLIST的循环构造，只是它并非迭代在整数或者一个列表的元素上，而是迭代在相继的素数上。<br>需要两个工具函数：一个用来测试给定的数是否为素数，另一个用来返回大于或等于其实参的下一个素数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(defun primep (number)</span><br><span class="line">  (when (&gt; number 1)</span><br><span class="line">    (loop for fac from 2 to (isqrt number) never (zerop (mod number fac)))))</span><br><span class="line"></span><br><span class="line">(defun next-prime (number)</span><br><span class="line">  (loop for n from number when (primep n) return n))</span><br></pre></td></tr></table></figure><p>我们首先需要编写一个宏调用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(do-primes (p 0 19)</span><br><span class="line">(format t &quot;~d&quot; p))</span><br></pre></td></tr></table></figure><p>这个循环在每个大于等于0并小于等于19的素数上依次执行循环体。如果没有do-primes宏，我们可以使用DO来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(do ((p (next-prime 0) (next-prime (1+ p))))</span><br><span class="line">    ((&gt; p 19))</span><br><span class="line">  (format t &quot;~d &quot; p))</span><br></pre></td></tr></table></figure><p>但上述代码不惧有通用性，使用宏do-primes，我们可以自定义循环体。</p><h2 id="四-宏形参">四 宏形参</h2><p>任何宏的第一步工作都是提取出那些对象中用于计算展开式的部分，对于简单的宏，只需定义正确的形参来保存不同的实参就可以。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(do-primes (p 0 19)</span><br><span class="line">(format t &quot;~d&quot; p))</span><br></pre></td></tr></table></figure><p>从上述宏调用可以看到，do-primes的第一个参数是一个列表，其含有循环变量的名字P以及下界0和上界19，第二个参数是format打印。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(defmacro do-primes ((var start end) &amp;body body)</span><br><span class="line">  `(do ((,var (next-prime ,start) (next-prime (1+ ,var))))</span><br><span class="line">       ((&gt; ,var ,end))</span><br><span class="line">     ,@body))</span><br></pre></td></tr></table></figure><p>上述<code>(var start end)</code>是所谓的解构式参数列表，“解构”涉及分拆一个结构体。<br>以上宏可以如下调用：其中p相当于是var, 0相当于是start, 19相当于是end。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (do-primes (p 0 19) (format t &quot;~d &quot; p))</span><br><span class="line">2 3 5 7 11 13 17 19 </span><br><span class="line">NIL</span><br></pre></td></tr></table></figure><p>宏形参列表的另一个特性是可以使用&amp;body作为&amp;rest的同名词，它们在语义上是等价的，&amp;body被用来保存一个构成该宏主体的形式的列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (macroexpand-1 &#x27;(do-primes (p 0 19) (format t &quot;~d &quot; p)))</span><br><span class="line">(DO ((P (NEXT-PRIME 0) (NEXT-PRIME (1+ P)))) ((&gt; P 19)) (FORMAT T &quot;~d &quot; P))</span><br><span class="line">T</span><br></pre></td></tr></table></figure><p>使用<code>macroexpand-1</code>可以查看宏调用产生的代码。也可以通过快捷键查看宏的展开式，光标移动到宏调用的行尾，输入 <code>C-c RET</code></p><h2 id="五-生成展开式">五 生成展开式</h2><p>反引号（`）用于 宏展开（macro expansion）时，它的作用是对表达式进行部分求值，以便在表达式中直接引用变量或常量，同时保持部分结构不变。<br>逗号 <code>,</code>表示对表达式进行求值<br><code>,</code>（unquote）会将一个表达式求值并插入到宏扩展的代码中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(defmacro example1 (x)</span><br><span class="line">  `(list 1 2 ,x 4))  ; 使用 , 来插入 x 的值</span><br><span class="line"></span><br><span class="line">(example1 3)  ; 执行宏，传入 3</span><br></pre></td></tr></table></figure><p>展开后，<code>example1</code> 会将 <code>x</code> 的值（即 3）插入到 <code>list</code> 中，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">; 展开后的代码 </span><br><span class="line">(list 1 2 3 4)</span><br></pre></td></tr></table></figure><p><code> ,@</code>是 解包操作符（unquote-splicing），它用于在列表中“展开”或“解包”一个列表，使其中的元素被直接插入到外部列表中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(defmacro example2 (x)</span><br><span class="line">  `(list 1 2 ,@x 4))  ; 使用 ,@ 来展开 x</span><br><span class="line"></span><br><span class="line">(example2 &#x27;(3 4 5))  ; 执行宏，传入 (3 4 5)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>x</code> 是一个列表 <code>(3 4 5)</code>，使用 <code>,@</code> 会将其元素 <code>3</code>、<code>4</code> 和 <code>5</code> 解包并插入到 <code>list</code> 中，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">; 展开后的代码</span><br><span class="line">(list 1 2 3 4 5 4)</span><br></pre></td></tr></table></figure><h2 id="六-堵住漏洞">六 堵住漏洞</h2><h3 id="6-1-多重求值漏洞">6.1 多重求值漏洞</h3><p>假设我们没有使用19这样的字面数字，而是用(random 10)这样的表达式在end的位置上来调用do-primes：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(do-primes (p 0 (random 1000))</span><br><span class="line">(format t &quot;~d &quot; p))</span><br></pre></td></tr></table></figure><p>它生成的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(DO ((P (NEXT-PRIME 0) (NEXT-PRIME (1+ P))))</span><br><span class="line">    ((&gt; P (RANDOM 100)))</span><br><span class="line">  (FORMAT T &quot;~d &quot; P))</span><br></pre></td></tr></table></figure><p>它会在每次迭代时都执行<code> (RANDOM 100)</code>，显然是不对的。为了堵住上述漏洞，我们可以定义一个变量 ending-value 来保存<code>(RANDOM 100)</code>的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(defmacro do-primes ((var start end) &amp;body body)</span><br><span class="line">  `(do ((ending-value ,end)</span><br><span class="line">(,var (next-prime ,start) (next-prime (1+ ,var))))</span><br><span class="line">       ((&gt; ,var ending-value))</span><br><span class="line">     ,@body))</span><br></pre></td></tr></table></figure><h3 id="6-2-数值依赖漏洞">6.2 数值依赖漏洞</h3><p>上述的修改又引入了一个新漏洞，在以下调用中我们希望 end 参数是 start 的两倍。如果 end 的计算（即 (* 2 start)）在 var 初始化之前进行，那么它将能够正确地使用 start 的值。但如果 end 的计算在 var 初始化之后进行，而 var 的初始化又以某种方式依赖于 start 的值，这可能会导致问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(let ((start 10))</span><br><span class="line">  (do-primes (p start (* 2 start))</span><br><span class="line">    (format t &quot;~d &quot; p)))</span><br></pre></td></tr></table></figure><p>正确的版本应该是将<code>ending-value</code>的定义放到后面：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(defmacro do-primes ((var start end) &amp;body body)</span><br><span class="line">  `(do ((,var (next-prime ,start) (next-prime (1+ ,var)))</span><br><span class="line">(ending-value ,end))</span><br><span class="line">       ((&gt; ,var ending-value))</span><br><span class="line">     ,@body))</span><br></pre></td></tr></table></figure><h3 id="6-3-命名漏洞">6.3 命名漏洞</h3><p>最后一个需要堵上的漏洞是由于使用了变量名ending-value而产生的，假设宏调用如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(do-primes (ending-value 0 10)</span><br><span class="line">(print ending-value))</span><br></pre></td></tr></table></figure><p>传递给do-primes的名字ending-value和宏体内的ending-value产生了干扰，为了解决这个问题，应该在宏体内使用一个罕见的名字，确保不会和调用者所传入的相同。</p><p>函数 GENSYM在其每次调用时返回唯一的符号，该符号在全局范围内唯一，避免用户代码中可能存在的变量名冲突，这样可以确保每次do-primes被展开时生成一个新符号以替代像ending-value这样的字面名称。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(defmacro do-primes ((var start end) &amp;body body)</span><br><span class="line">  (let ((ending-value-name (gensym)))</span><br><span class="line">    `(do ((,var (next-prime ,start) (next-prime (1+ ,var)))</span><br><span class="line">(,ending-value-name ,end))</span><br><span class="line">       ((&gt; ,var ,ending-value-name))</span><br><span class="line">       ,@body)))</span><br></pre></td></tr></table></figure><p>当我们这样调用时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(do-primes (p 0 (random 100))</span><br><span class="line">  (format t &quot;~d &quot; p))</span><br></pre></td></tr></table></figure><p>展开式为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(DO ((P (NEXT-PRIME 0) (NEXT-PRIME (1+ P)))</span><br><span class="line">     (#:G323 (RANDOM 100)))</span><br><span class="line">    ((&gt; P #:G323))</span><br><span class="line">  (FORMAT T &quot;~d &quot; P))</span><br></pre></td></tr></table></figure><p>#:G323 在每次宏展开时都不一样，这样能确保全局范围内都不会同名。</p><h2 id="七-用于编写宏的宏">七 用于编写宏的宏</h2><p>宏的作用是将常见的句法模式抽象掉，例如在最后版本的do-primes，它们都以一个LET形式开始，它引入了一些变量用来保存宏展开过程中用到的生成符号，我们可以用一个宏来抽象掉这个模式。</p><p>我们可以编写一个宏with-gensyms，它用来生成一些代码，而这些代码又用来生成另一些代码。宏with-gensyms应该类似下面这种形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(defmacro do-primes ((var start end) &amp;body body)</span><br><span class="line">  (with-gensyms (ending-value-name)</span><br><span class="line">    `(do ((,var (next-prime ,start) (next-prime (1+ ,var)))</span><br><span class="line">(,ending-value-name ,end))</span><br><span class="line">       ((&gt; ,var ,ending-value-name))</span><br><span class="line">       ,@body)))</span><br></pre></td></tr></table></figure><p>with-gensyms 需要展开成一个LET，它会把每一个命名的变量都绑定到一个生成符号上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(defmacro with-gensyms ((&amp;rest names) &amp;body body)</span><br><span class="line">  `(let ,(loop for n in names collect `(,n (gensym)))</span><br><span class="line">     ,@body))</span><br></pre></td></tr></table></figure><p>以下示例演示loop是如何工作的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (loop for x in &#x27;(a b c) collect `(,x (gensym)))</span><br><span class="line">((A (GENSYM)) (B (GENSYM)) (C (GENSYM)))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Lisp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Common Lisp </tag>
            
            <tag> 宏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解构Common Lisp宏：从基本语法到高级用法</title>
      <link href="/2025/01/16/jie-gou-common-lisp-hong-cong-ji-ben-yu-fa-dao-gao-ji-yong-fa/"/>
      <url>/2025/01/16/jie-gou-common-lisp-hong-cong-ji-ben-yu-fa-dao-gao-ji-yong-fa/</url>
      
        <content type="html"><![CDATA[<p>其余自Lisp的许多编程思想，从条件表达式到垃圾收集，都已经被吸取进其他语言，但Lisp的宏系统却始终使它保持了在语言风格上的独特性。Lisp的宏和大多数其他语言中的也叫宏的东西是完全不一样的，要完全认识Lisp中的宏系统，就需要重新看待它。</p><span id="more"></span><p>一种常见的观点认为，语言的定义可能包含一个使用“核心”语言实现的标准功能库——如果某些功能没有被实现在标准库中，那么他们可能被程序员使用标准库提供的功能实现了。C的标准库差不多可以完全用可移植的C来实现，类似的，Java的标准Java开发包(JDK)中提供的不断改进的类和接口也是用&quot;纯&quot;Java编写的。</p><p>使用核心加上标准库的方式来定义语言的优势在于易于理解和实现，但真正的好处是很容易对其进行扩展，如果C语言中不包括做某件事的函数，那么就可以写出这个函数。类似的，类似Java这样的语言通过定义新的类就可以扩展该语言。</p><p><strong>尽管Common Lisp支持所有这些扩展语言的方法，但宏还提供了另一个表达方法。</strong> 每个宏都有自己的语法，它们能够决定那些被传递的S-表达式如何转换成Lisp形式。核心语言有了宏就可以构造出新的语法，例如WHEN, DOLIST和LOOP这样的控制构造以及DEFUN和DEFPARAMETER这样的定义形式，从而使这些新语法可以作为“标准库”的一部分而不是将其硬编码到语言核心。这已经涉及到语言本身是如何实现的，但作为一个Lisp程序员，我们更关心的是它所提供的语言扩展方式，而这将使Common Lisp成为更好的用于表达特定编程问题解决方案的语言。</p><p><strong>S-表达式</strong><br>S-表达式的基本元素是列表(lisp)和原子(atom)，列表由括号所包围，并可包含任何数量的由空格所分割的元素。原子是除了列表之外的所有元素，包括符号、数字、字符串等。列表元素本身也可以是S-表达式(原子或嵌套的列表)</p><p><strong>作为Lisp形式的S-表达式</strong><br>在读取器把大量文本转化为S-表达式后，这些S-表达式随后可以作为Lisp形式被求值，并不是每个读取器可读的S-表达式都有必要作为Lisp形式来求值，Common Lisp的求值规则定义了第二层的语法来检测哪种S-表达式可以看作Lisp形式。例如，从读取 (foo 1 2) 得到的S-表达式在句法上是良好定义的，但是只有当foo是一个函数或宏的名字时，它才可以被求值。</p><p>现在以Lisp中常见的几个宏开始讲解，它们都是如果Lisp没有宏，就必须构造在语言核心里的东西。</p><h2 id="一-WHEN-和-UNLESS">一 WHEN 和 UNLESS</h2><p>最基本的条件执行形式是由IF特殊操作符提供的，其基本形式是：如果condition成立，那么执行then-form，否则执行else-form。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(if condition then-form [else-form])</span><br></pre></td></tr></table></figure><p>其中then-form或else-form必须是单一的Lisp形式，如果要在每个子句中执行一系列的操作，则必须将其用其他一些语法形式进行封装，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(if (condition)</span><br><span class="line">(progn </span><br><span class="line">(then-form1)</span><br><span class="line">(then-form2)))</span><br></pre></td></tr></table></figure><p>类似上述这样的代码可以实现，当condition为真时，做这个，那个以及一些事情。可否有一种方式能将这种IF加上PROGN所组成的模式抽象出来，宏就能实现。Common Lisp提供了一个标准宏WHEN，可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(when  (condition)</span><br><span class="line">(then-form1)</span><br><span class="line">(then-form2))</span><br></pre></td></tr></table></figure><p>如果WHEN没有被内置到标准库中，我们可以使用下面这个宏来定义自己的WHEN：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(defmacro when (condition &amp;rest body)</span><br><span class="line">`(if ,condition (progn ,@body)))</span><br></pre></td></tr></table></figure><p>与WHEN宏同系列的另一个宏是UNLESS，它取相反的条件，只有当条件为假时才求值其形式体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(defmacro unless (condition &amp;rest body)</span><br><span class="line">`(if (not ,condition) (progn ,@body)))</span><br></pre></td></tr></table></figure><p>必须承认，这些都是相当简单的宏，它们只是抽象掉了一些语言层面约定俗成的细节，其实宏可以被更大规模地用于创建完整的特定领域的嵌入式语言。</p><p>反引号（`）用于 宏展开（macro expansion）时，它的作用是对表达式进行部分求值，以便在表达式中直接引用变量或常量，同时保持部分结构不变。<br>逗号 <code>,</code>表示对表达式进行求值<br><code>,</code>（unquote）会将一个表达式求值并插入到宏扩展的代码中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(defmacro example1 (x)</span><br><span class="line">  `(list 1 2 ,x 4))  ; 使用 , 来插入 x 的值</span><br><span class="line"></span><br><span class="line">(example1 3)  ; 执行宏，传入 3</span><br></pre></td></tr></table></figure><p>展开后，<code>example1</code> 会将 <code>x</code> 的值（即 3）插入到 <code>list</code> 中，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">; 展开后的代码 </span><br><span class="line">(list 1 2 3 4)</span><br></pre></td></tr></table></figure><p><code> ,@</code>是 解包操作符（unquote-splicing），它用于在列表中“展开”或“解包”一个列表，使其中的元素被直接插入到外部列表中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(defmacro example2 (x)</span><br><span class="line">  `(list 1 2 ,@x 4))  ; 使用 ,@ 来展开 x</span><br><span class="line"></span><br><span class="line">(example2 &#x27;(3 4 5))  ; 执行宏，传入 (3 4 5)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>x</code> 是一个列表 <code>(3 4 5)</code>，使用 <code>,@</code> 会将其元素 <code>3</code>、<code>4</code> 和 <code>5</code> 解包并插入到 <code>list</code> 中，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">; 展开后的代码</span><br><span class="line">(list 1 2 3 4 5 4)</span><br></pre></td></tr></table></figure><h2 id="二-COND">二 COND</h2><p>当遇到多重分支的条件语句时，原始的IF表达式再次变得丑陋不堪：如果a成立那么执行x，否则如果b成立那么执行y，否则执行z：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(if a</span><br><span class="line">(do-x)</span><br><span class="line">(if b</span><br><span class="line">(do-y)</span><br><span class="line">(do-z)))</span><br></pre></td></tr></table></figure><p>如果需要在then子句中包括多个形式，就需要用到PROGN，代码结构会变得更加复杂。因此 Common Lisp提供了用于表达多重分支条件的宏 COND。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(cond</span><br><span class="line">  (test1 expr1)</span><br><span class="line">  (test2 expr2)</span><br><span class="line">  ...</span><br><span class="line">  (t exprN))  ; &#x27;t&#x27; 是默认情况，类似于 else</span><br></pre></td></tr></table></figure><p>在 <code>cond</code> 语句中，Lisp 会逐个评估每个条件（<code>test1</code>, <code>test2</code> 等），直到找到一个结果为真（非 <code>nil</code>）的条件。如果找到了真条件，Lisp 会执行对应的表达式（<code>expr1</code>, <code>expr2</code> 等），并返回其结果。<code>t</code> 表示“真”，如果没有条件匹配，<code>t</code> 分支会执行。</p><h2 id="三-AND，OR-和-NOT">三 AND，OR 和 NOT</h2><p>NOT是函数，它接受单一参数并对其值取反，当参数为NIL时返回T，否则返回NIL。<br>AND和OR则是宏，它们实现了对任意数量子表达式的逻辑合取和析取操作，并被定义成宏以支持“短路”特性。</p><p>只要AND的一个子表达式求值为NIL，它就立即停止并返回NIL，如果将所有子表达式都求值为非NIL，那么它将返回最后一个子表达式的值。</p><p>对于OR来说，只要一个子表达式求值得到非NIL，它就立即停止并返回当前子表达式的值，如果没有子表达式求值为真，OR返回NIL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(not nil)             ; --&gt; T</span><br><span class="line">(not (= 1 1))         ; --&gt; NIL</span><br><span class="line">(and (= 1 2) (= 3 3)) ; --&gt; NIL</span><br><span class="line">(or (= 1 2) (= 3 3))  ; --&gt; T</span><br></pre></td></tr></table></figure><h2 id="四-循环">四 循环</h2><p>循环构造是另外一类主要的控制构造。Common Lisp的循环机制，除了更加强大和灵活以外，还是一门关于宏所提供的“鱼和熊掌兼得”的编程风格的有趣课程。<br>DO提供了一种基本的结构化循环构造，而DOLIST和DOTIMES则提供了两种易用却不那么通用的构造。最后，LOOP宏提供了一种成熟的微型语言，它是一种独特的表达循环的方式。不论你喜欢或不喜欢这种循环的构造方式，LOOP本身都是为语言增加新构造的宏展示其强大威力的突出示例。</p><h2 id="五-DOLIST-和-DOTIMES">五 DOLIST 和 DOTIMES</h2><p>先从易于使用的DOLIST和DOTIMES宏开始。<br>DOLIST在一个列表的元素上循环操作，使用一个依次持有列表中所有后继元素的变量来执行循环体。下面是其基本形式（去掉了一些难懂的选项）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(dolist (var list-form)</span><br><span class="line">body-form*)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (dolist (x &#x27;(1 2 3)) (print x))</span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">NIL</span><br></pre></td></tr></table></figure><p>在这种方式下，DOLIST这种形式本身求值为NIL。<br>如果想在列表结束之前中断一个DOLIST循环，则可以使用RETURN。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (dolist (x &#x27;(1 2 3)) (print x) (if (evenp x) (return)))</span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">NIL</span><br></pre></td></tr></table></figure><p>evenp 判断一个数是否为偶数。</p><p>DOTIMES是用于循环计数的高级循环构造，其基本模板和DOLIST非常相似。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(dotimes (var count-form)</span><br><span class="line">body-form*)</span><br></pre></td></tr></table></figure><p>其中count-form必须能求值为一个整数，通过每次循环，var所持有的整数依次从0到比那个数小1的每一个后继整数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (dotimes (i 4) (print i))</span><br><span class="line">0 </span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">NIL</span><br></pre></td></tr></table></figure><h2 id="六-DO">六 DO</h2><p>尽管DOLIST和DOTIMES方便易用，但也无法应用于所有循环，使用DO可以解决所有的循环问题。与DOLIST和DOTIMES只提供一个循环变量有所不同的是，DO允许绑定任意数量的变量，并且变量值在每次循环中的改变也是可自定义的，也可以自定义测试条件来决定何时终止循环，并可以提供一个形式，在循环结束时进行求值来为DO表达式整体生成一个返回值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(do (variable-definition*)</span><br><span class="line">(end-test-form result-form*)</span><br><span class="line">statement*)</span><br></pre></td></tr></table></figure><p>每一个variable-definition引入一个将存在于循环体作用域之内的变量，单一变量定义的完整形式是含有三个元素的列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(var init-form step-form)</span><br></pre></td></tr></table></figure><p>上述init-form在循环开始时被求值并将结果值绑定到变量var上，在循环的每一个后续迭代开始之前，step-form将被求值并把新值赋值给var，step-form是可选的。</p><p>在每次迭代开始时以及所有循环变量都被指定新值后，end-test-form会被求值，只要其值为NIL，迭代过程就会继续。</p><p>当end-test-form求值为真，result-form将被求值，且最后一个结果形式的值将作为DO表达式的值返回。<br>示例：计算斐波那契数列的第 n 项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(do ((n 0 (1+ n))</span><br><span class="line">     (cur 0 next)</span><br><span class="line">     (next 1 (+ cur next)))</span><br><span class="line">    ((= 4 n) cur))</span><br></pre></td></tr></table></figure><p>示例：打印前N个自然数的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(do ((i 0 (1+ i)))</span><br><span class="line">    ((&gt;= i 4))</span><br><span class="line">  (print i))</span><br></pre></td></tr></table></figure><p>当然打印前N个自然数的值使用DOTIMES会更加方便：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(dotimes (i 4) (print i))</span><br></pre></td></tr></table></figure><p>下面的例子演示一个不绑定循环变量的DO循环，在当前时间小于一个全局变量值的时候，它保持循环，每分钟打印一个&quot;Waiting&quot;：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(do ()</span><br><span class="line">((&gt; (get-universal-time) *some-future-data*))</span><br><span class="line">(format t &quot;Waiting~%&quot;)</span><br><span class="line">(sleep 60))</span><br></pre></td></tr></table></figure><h2 id="七-强大的LOOP">七 强大的LOOP</h2><p>简单的情形可以使用DOLIST和DOTIMES，如果它们不满足要求可以使用通用的DO。但是有一种循环需求在实际开发中很常见，例如在多种数据结构上的循环：列表，向量，哈希表和包，或者在循环时以多种方式来聚集值：收集，计数，求和，最小化，最大化等这一系列问题都可以用LOOP宏轻松实现。<br>LOOP宏有两大版本，简化的扩展的。简化版是没有变量绑定的无限循环，而扩展版则允许复杂的变量绑定和条件判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(loop</span><br><span class="line">body-form*)</span><br></pre></td></tr></table></figure><p>主体形式在每次循环时都被求值，整个循环将不停的迭代，直到使用RETURN来进行终止。例如可以使用一个简化的LOOP来写出前面的DO循环。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(loop</span><br><span class="line">(when (&gt; (get-universal-time) *some-future-data*) </span><br><span class="line">(return))</span><br><span class="line">(format t &quot;Waiting ~%&quot;)</span><br><span class="line">(sleep 60))</span><br></pre></td></tr></table></figure><p>问题，将1到10的数字收集到一个列表中：<br>使用DO循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(do ((nums nil) (i 1 (1+ i)))</span><br><span class="line">    ((&gt; i 10) (nreverse nums))</span><br><span class="line">  (push i nums))</span><br></pre></td></tr></table></figure><p>使用LOOP：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(loop for i from 1 to 10 collecting i)</span><br></pre></td></tr></table></figure><p>关于LOOP的这种语法，有些人喜欢，有些人则讨厌。</p><p>下面是关于LOOP的其他一些用法：</p><ol><li>统计一个字符串中元音字母的个数：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(loop for  x across &quot;This is my blog&quot; counting (find x &quot;aeiou&quot;))</span><br></pre></td></tr></table></figure><ol start="2"><li>计算第10个斐波那契数，它类似于前面的DO循环版本：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(loop for i below 10</span><br><span class="line">      and a = 0 then b</span><br><span class="line">      and b = 1 then (+ b a)</span><br><span class="line">      finally (return a))</span><br></pre></td></tr></table></figure><p>符号across, and, below, collecting, counting, finally, for, from, summing, then 和to都是一些循环关键字。值得注意的是，我们通过LOOP可以看到，宏是如何被用于扩展基本语言的。尽管LOOP提供了它自己的语法用来表达循环构造，但它并没有抹杀Lisp的其他优势，如果它没有被包括在标准库中，你也可以自己实现或借助一个第三方库来实。现其余自Lisp的许多编程思想，从条件表达式到垃圾收集，都已经被吸取进其他语言，但Lisp的宏系统却始终使它保持了在语言风格上的独特性。Lisp的宏和大多数其他语言中的也叫宏的东西是完全不一样的，要完全认识Lisp中的宏系统，就需要重新看待它。</p><p>一种常见的观点认为，语言的定义可能包含一个使用“核心”语言实现的标准功能库——如果某些功能没有被实现在标准库中，那么他们可能被程序员使用标准库提供的功能实现了。C的标准库差不多可以完全用可移植的C来实现，类似的，Java的标准Java开发包(JDK)中提供的不断改进的类和接口也是用&quot;纯&quot;Java编写的。</p><p>使用核心加上标准库的方式来定义语言的优势在于易于理解和实现，但真正的好处是很容易对其进行扩展，如果C语言中不包括做某件事的函数，那么就可以写出这个函数。类似的，类似Java这样的语言通过定义新的类就可以扩展该语言。</p><p><strong>尽管Common Lisp支持所有这些扩展语言的方法，但宏还提供了另一个表达方法。</strong> 每个宏都有自己的语法，它们能够决定那些被传递的S-表达式如何转换成Lisp形式。核心语言有了宏就可以构造出新的语法，例如WHEN, DOLIST和LOOP这样的控制构造以及DEFUN和DEFPARAMETER这样的定义形式，从而使这些新语法可以作为“标准库”的一部分而不是将其硬编码到语言核心。这已经涉及到语言本身是如何实现的，但作为一个Lisp程序员，我们更关心的是它所提供的语言扩展方式，而这将使Common Lisp成为更好的用于表达特定编程问题解决方案的语言。</p><p><strong>S-表达式</strong><br>S-表达式的基本元素是列表(lisp)和原子(atom)，列表由括号所包围，并可包含任何数量的由空格所分割的元素。原子是除了列表之外的所有元素，包括符号、数字、字符串等。列表元素本身也可以是S-表达式(原子或嵌套的列表)</p><p><strong>作为Lisp形式的S-表达式</strong><br>在读取器把大量文本转化为S-表达式后，这些S-表达式随后可以作为Lisp形式被求值，并不是每个读取器可读的S-表达式都有必要作为Lisp形式来求值，Common Lisp的求值规则定义了第二层的语法来检测哪种S-表达式可以看作Lisp形式。例如，从读取 (foo 1 2) 得到的S-表达式在句法上是良好定义的，但是只有当foo是一个函数或宏的名字时，它才可以被求值。</p><p>现在以Lisp中常见的几个宏开始讲解，它们都是如果Lisp没有宏，就必须构造在语言核心里的东西。</p><h2 id="一-WHEN-和-UNLESS-2">一 WHEN 和 UNLESS</h2><p>最基本的条件执行形式是由IF特殊操作符提供的，其基本形式是：如果condition成立，那么执行then-form，否则执行else-form。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(if condition then-form [else-form])</span><br></pre></td></tr></table></figure><p>其中then-form或else-form必须是单一的Lisp形式，如果要在每个子句中执行一系列的操作，则必须将其用其他一些语法形式进行封装，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(if (condition)</span><br><span class="line">(progn </span><br><span class="line">(then-form1)</span><br><span class="line">(then-form2)))</span><br></pre></td></tr></table></figure><p>类似上述这样的代码可以实现，当condition为真时，做这个，那个以及一些事情。可否有一种方式能将这种IF加上PROGN所组成的模式抽象出来，宏就能实现。Common Lisp提供了一个标准宏WHEN，可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(when  (condition)</span><br><span class="line">(then-form1)</span><br><span class="line">(then-form2))</span><br></pre></td></tr></table></figure><p>如果WHEN没有被内置到标准库中，我们可以使用下面这个宏来定义自己的WHEN：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(defmacro when (condition &amp;rest body)</span><br><span class="line">`(if ,condition (progn ,@body)))</span><br></pre></td></tr></table></figure><p>与WHEN宏同系列的另一个宏是UNLESS，它取相反的条件，只有当条件为假时才求值其形式体：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(defmacro unless (condition &amp;rest body)</span><br><span class="line">`(if (not ,condition) (progn ,@body)))</span><br></pre></td></tr></table></figure><p>必须承认，这些都是相当简单的宏，它们只是抽象掉了一些语言层面约定俗成的细节，其实宏可以被更大规模地用于创建完整的特定领域的嵌入式语言。</p><p>反引号（`）用于 宏展开（macro expansion）时，它的作用是对表达式进行部分求值，以便在表达式中直接引用变量或常量，同时保持部分结构不变。<br>逗号 <code>,</code>表示对表达式进行求值<br><code>,</code>（unquote）会将一个表达式求值并插入到宏扩展的代码中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(defmacro example1 (x)</span><br><span class="line">  `(list 1 2 ,x 4))  ; 使用 , 来插入 x 的值</span><br><span class="line"></span><br><span class="line">(example1 3)  ; 执行宏，传入 3</span><br></pre></td></tr></table></figure><p>展开后，<code>example1</code> 会将 <code>x</code> 的值（即 3）插入到 <code>list</code> 中，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">; 展开后的代码 </span><br><span class="line">(list 1 2 3 4)</span><br></pre></td></tr></table></figure><p><code> ,@</code>是 解包操作符（unquote-splicing），它用于在列表中“展开”或“解包”一个列表，使其中的元素被直接插入到外部列表中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(defmacro example2 (x)</span><br><span class="line">  `(list 1 2 ,@x 4))  ; 使用 ,@ 来展开 x</span><br><span class="line"></span><br><span class="line">(example2 &#x27;(3 4 5))  ; 执行宏，传入 (3 4 5)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在这个例子中，<code>x</code> 是一个列表 <code>(3 4 5)</code>，使用 <code>,@</code> 会将其元素 <code>3</code>、<code>4</code> 和 <code>5</code> 解包并插入到 <code>list</code> 中，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">; 展开后的代码</span><br><span class="line">(list 1 2 3 4 5 4)</span><br></pre></td></tr></table></figure><h2 id="二-COND-2">二 COND</h2><p>当遇到多重分支的条件语句时，原始的IF表达式再次变得丑陋不堪：如果a成立那么执行x，否则如果b成立那么执行y，否则执行z：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(if a</span><br><span class="line">(do-x)</span><br><span class="line">(if b</span><br><span class="line">(do-y)</span><br><span class="line">(do-z)))</span><br></pre></td></tr></table></figure><p>如果需要在then子句中包括多个形式，就需要用到PROGN，代码结构会变得更加复杂。因此 Common Lisp提供了用于表达多重分支条件的宏 COND。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(cond</span><br><span class="line">  (test1 expr1)</span><br><span class="line">  (test2 expr2)</span><br><span class="line">  ...</span><br><span class="line">  (t exprN))  ; &#x27;t&#x27; 是默认情况，类似于 else</span><br></pre></td></tr></table></figure><p>在 <code>cond</code> 语句中，Lisp 会逐个评估每个条件（<code>test1</code>, <code>test2</code> 等），直到找到一个结果为真（非 <code>nil</code>）的条件。如果找到了真条件，Lisp 会执行对应的表达式（<code>expr1</code>, <code>expr2</code> 等），并返回其结果。<code>t</code> 表示“真”，如果没有条件匹配，<code>t</code> 分支会执行。</p><h2 id="三-AND，OR-和-NOT-2">三 AND，OR 和 NOT</h2><p>NOT是函数，它接受单一参数并对其值取反，当参数为NIL时返回T，否则返回NIL。<br>AND和OR则是宏，它们实现了对任意数量子表达式的逻辑合取和析取操作，并被定义成宏以支持“短路”特性。</p><p>只要AND的一个子表达式求值为NIL，它就立即停止并返回NIL，如果将所有子表达式都求值为非NIL，那么它将返回最后一个子表达式的值。</p><p>对于OR来说，只要一个子表达式求值得到非NIL，它就立即停止并返回当前子表达式的值，如果没有子表达式求值为真，OR返回NIL。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(not nil)             ; --&gt; T</span><br><span class="line">(not (= 1 1))         ; --&gt; NIL</span><br><span class="line">(and (= 1 2) (= 3 3)) ; --&gt; NIL</span><br><span class="line">(or (= 1 2) (= 3 3))  ; --&gt; T</span><br></pre></td></tr></table></figure><h2 id="四-循环-2">四 循环</h2><p>循环构造是另外一类主要的控制构造。Common Lisp的循环机制，除了更加强大和灵活以外，还是一门关于宏所提供的“鱼和熊掌兼得”的编程风格的有趣课程。<br>DO提供了一种基本的结构化循环构造，而DOLIST和DOTIMES则提供了两种易用却不那么通用的构造。最后，LOOP宏提供了一种成熟的微型语言，它是一种独特的表达循环的方式。不论你喜欢或不喜欢这种循环的构造方式，LOOP本身都是为语言增加新构造的宏展示其强大威力的突出示例。</p><h2 id="五-DOLIST-和-DOTIMES-2">五 DOLIST 和 DOTIMES</h2><p>先从易于使用的DOLIST和DOTIMES宏开始。<br>DOLIST在一个列表的元素上循环操作，使用一个依次持有列表中所有后继元素的变量来执行循环体。下面是其基本形式（去掉了一些难懂的选项）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(dolist (var list-form)</span><br><span class="line">body-form*)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (dolist (x &#x27;(1 2 3)) (print x))</span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">NIL</span><br></pre></td></tr></table></figure><p>在这种方式下，DOLIST这种形式本身求值为NIL。<br>如果想在列表结束之前中断一个DOLIST循环，则可以使用RETURN。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (dolist (x &#x27;(1 2 3)) (print x) (if (evenp x) (return)))</span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">NIL</span><br></pre></td></tr></table></figure><p>evenp 判断一个数是否为偶数。</p><p>DOTIMES是用于循环计数的高级循环构造，其基本模板和DOLIST非常相似。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(dotimes (var count-form)</span><br><span class="line">body-form*)</span><br></pre></td></tr></table></figure><p>其中count-form必须能求值为一个整数，通过每次循环，var所持有的整数依次从0到比那个数小1的每一个后继整数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (dotimes (i 4) (print i))</span><br><span class="line">0 </span><br><span class="line">1 </span><br><span class="line">2 </span><br><span class="line">3 </span><br><span class="line">NIL</span><br></pre></td></tr></table></figure><h2 id="六-DO-2">六 DO</h2><p>尽管DOLIST和DOTIMES方便易用，但也无法应用于所有循环，使用DO可以解决所有的循环问题。与DOLIST和DOTIMES只提供一个循环变量有所不同的是，DO允许绑定任意数量的变量，并且变量值在每次循环中的改变也是可自定义的，也可以自定义测试条件来决定何时终止循环，并可以提供一个形式，在循环结束时进行求值来为DO表达式整体生成一个返回值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(do (variable-definition*)</span><br><span class="line">(end-test-form result-form*)</span><br><span class="line">statement*)</span><br></pre></td></tr></table></figure><p>每一个variable-definition引入一个将存在于循环体作用域之内的变量，单一变量定义的完整形式是含有三个元素的列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(var init-form step-form)</span><br></pre></td></tr></table></figure><p>上述init-form在循环开始时被求值并将结果值绑定到变量var上，在循环的每一个后续迭代开始之前，step-form将被求值并把新值赋值给var，step-form是可选的。</p><p>在每次迭代开始时以及所有循环变量都被指定新值后，end-test-form会被求值，只要其值为NIL，迭代过程就会继续。</p><p>当end-test-form求值为真，result-form将被求值，且最后一个结果形式的值将作为DO表达式的值返回。<br>示例：计算斐波那契数列的第 n 项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(do ((n 0 (1+ n))</span><br><span class="line">     (cur 0 next)</span><br><span class="line">     (next 1 (+ cur next)))</span><br><span class="line">    ((= 4 n) cur))</span><br></pre></td></tr></table></figure><p>示例：打印前N个自然数的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(do ((i 0 (1+ i)))</span><br><span class="line">    ((&gt;= i 4))</span><br><span class="line">  (print i))</span><br></pre></td></tr></table></figure><p>当然打印前N个自然数的值使用DOTIMES会更加方便：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(dotimes (i 4) (print i))</span><br></pre></td></tr></table></figure><p>下面的例子演示一个不绑定循环变量的DO循环，在当前时间小于一个全局变量值的时候，它保持循环，每分钟打印一个&quot;Waiting&quot;：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(do ()</span><br><span class="line">((&gt; (get-universal-time) *some-future-data*))</span><br><span class="line">(format t &quot;Waiting~%&quot;)</span><br><span class="line">(sleep 60))</span><br></pre></td></tr></table></figure><h2 id="七-强大的LOOP-2">七 强大的LOOP</h2><p>简单的情形可以使用DOLIST和DOTIMES，如果它们不满足要求可以使用通用的DO。但是有一种循环需求在实际开发中很常见，例如在多种数据结构上的循环：列表，向量，哈希表和包，或者在循环时以多种方式来聚集值：收集，计数，求和，最小化，最大化等这一系列问题都可以用LOOP宏轻松实现。<br>LOOP宏有两大版本，简化的扩展的。简化版是没有变量绑定的无限循环，而扩展版则允许复杂的变量绑定和条件判断。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(loop</span><br><span class="line">body-form*)</span><br></pre></td></tr></table></figure><p>主体形式在每次循环时都被求值，整个循环将不停的迭代，直到使用RETURN来进行终止。例如可以使用一个简化的LOOP来写出前面的DO循环。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(loop</span><br><span class="line">(when (&gt; (get-universal-time) *some-future-data*) </span><br><span class="line">(return))</span><br><span class="line">(format t &quot;Waiting ~%&quot;)</span><br><span class="line">(sleep 60))</span><br></pre></td></tr></table></figure><p>问题，将1到10的数字收集到一个列表中：<br>使用DO循环：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(do ((nums nil) (i 1 (1+ i)))</span><br><span class="line">    ((&gt; i 10) (nreverse nums))</span><br><span class="line">  (push i nums))</span><br></pre></td></tr></table></figure><p>使用LOOP：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(loop for i from 1 to 10 collecting i)</span><br></pre></td></tr></table></figure><p>关于LOOP的这种语法，有些人喜欢，有些人则讨厌。</p><p>下面是关于LOOP的其他一些用法：</p><ol><li>统计一个字符串中元音字母的个数：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(loop for  x across &quot;This is my blog&quot; counting (find x &quot;aeiou&quot;))</span><br></pre></td></tr></table></figure><ol start="2"><li>计算第10个斐波那契数，它类似于前面的DO循环版本：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(loop for i below 10</span><br><span class="line">      and a = 0 then b</span><br><span class="line">      and b = 1 then (+ b a)</span><br><span class="line">      finally (return a))</span><br></pre></td></tr></table></figure><p>符号across, and, below, collecting, counting, finally, for, from, summing, then 和to都是一些循环关键字。值得注意的是，我们通过LOOP可以看到，宏是如何被用于扩展基本语言的。尽管LOOP提供了它自己的语法用来表达循环构造，但它并没有抹杀Lisp的其他优势，如果它没有被包括在标准库中，你也可以自己实现或借助一个第三方库来实现。</p>]]></content>
      
      
      <categories>
          
          <category> Lisp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Common Lisp </tag>
            
            <tag> 宏 </tag>
            
            <tag> WHEN </tag>
            
            <tag> COND </tag>
            
            <tag> DO </tag>
            
            <tag> DOLIST </tag>
            
            <tag> DOTIMES </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>uiop-run-program 基本使用教程</title>
      <link href="/2025/01/16/uiop-run-program-ji-ben-shi-yong-jiao-cheng/"/>
      <url>/2025/01/16/uiop-run-program-ji-ben-shi-yong-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<p>uiop:run-program 是 Common Lisp 中 UIOP (Utilities for Implementation- and OS- Portability) 库的一部分，用于在 Lisp 环境中执行外部程序和命令。这个函数提供了一个强大的接口来启动外部进程，并可以处理进程的输入、输出和退出状态。以下是一个关于如何使用 uiop:run-program 的入门教程：</p><span id="more"></span><h3 id="安装和加载-UIOP">安装和加载 UIOP</h3><p>UIOP 是 ASDF (Another System Definition Facility) 的一部分，通常已经包含在现代 Common Lisp 实现中。你可以通过 Quicklisp 来确保 UIOP 可用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(ql:quickload &quot;uiop&quot;)</span><br></pre></td></tr></table></figure><h3 id="基本用法">基本用法</h3><h3 id="1-执行简单命令">1. <strong>执行简单命令</strong></h3><p>执行 Windows 命令行中的 <code>dir</code> 命令（类似于 Unix 的 <code>ls</code> 命令），列出当前目录内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(uiop:run-program &quot;cmd /c dir&quot;)</span><br></pre></td></tr></table></figure><h3 id="2-捕获命令输出">2. <strong>捕获命令输出</strong></h3><p>获取 <code>dir</code> 命令的输出并保存在 Lisp 变量中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(let ((output (uiop:run-program &quot;cmd /c dir&quot; :output :string)))</span><br><span class="line">  (format t &quot;~A~%&quot; output))</span><br></pre></td></tr></table></figure><h3 id="3-执行外部程序">3. <strong>执行外部程序</strong></h3><p>运行外部的可执行文件（比如 <code>notepad.exe</code>）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(uiop:run-program &quot;notepad.exe&quot;)</span><br></pre></td></tr></table></figure><p>执行上述命令会打开记事本</p><h3 id="4-传递参数给外部程序">4. <strong>传递参数给外部程序</strong></h3><p>执行外部程序时传递参数，例如用 <code>echo</code> 命令输出一段文本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(uiop:run-program &quot;cmd /c echo Hello, World!&quot;)</span><br></pre></td></tr></table></figure><h3 id="5-指定输入数据">5. <strong>指定输入数据</strong></h3><p>将一段输入传递给命令行程序。例如，通过 <code>findstr</code> 命令在输入数据中查找特定字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(let ((output (uiop:run-program &quot;cmd /c findstr foo&quot;</span><br><span class="line">                               :input &quot;foo\nbar\nfoobar\n&quot;</span><br><span class="line">                               :output :string)))</span><br><span class="line">  (format t &quot;Matched Output:~%~A~%&quot; output))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-捕获错误输出">6. <strong>捕获错误输出</strong></h3><p>捕获外部程序的标准错误输出。例如，试图访问不存在的文件，输出错误消息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(let ((error-output (uiop:run-program &quot;cmd /c type nonexistent-file.txt&quot;</span><br><span class="line">                                     :output :string</span><br><span class="line">                                     :error :string</span><br><span class="line">                                     :ignore-error-status t)))</span><br><span class="line">  (format t &quot;Error Output:~%~A~%&quot; error-output))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-执行批处理脚本">7. <strong>执行批处理脚本</strong></h3><p>执行一个 <code>.bat</code> 文件。例如，假设你有一个 <code>test.bat</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(uiop:run-program &quot;cmd /c test.bat&quot;)</span><br></pre></td></tr></table></figure><p>如果 <code>test.bat</code> 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@echo off</span><br><span class="line">echo Hello from the batch script!</span><br></pre></td></tr></table></figure><p>输出将会是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello from the batch script!</span><br></pre></td></tr></table></figure><h3 id="8-执行-PowerShell-命令">8. <strong>执行 PowerShell 命令</strong></h3><p>执行 Windows PowerShell 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(uiop:run-program &quot;powershell -Command \&quot;Write-Output &#x27;Hello, PowerShell!&#x27;\&quot;&quot;)</span><br></pre></td></tr></table></figure><h3 id="9-将命令输出保存到文件">9. <strong>将命令输出保存到文件</strong></h3><p>将 <code>dir</code> 命令的输出保存到文件 <code>output.txt</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(uiop:run-program &quot;cmd /c dir&quot; :output &quot;output.txt&quot;)</span><br></pre></td></tr></table></figure><h3 id="10-忽略非零退出状态">10. <strong>忽略非零退出状态</strong></h3><p>执行一个会失败的命令（如 <code>exit 1</code>），忽略错误状态，防止 Lisp 抛出异常：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(uiop:run-program &quot;cmd /c exit 1&quot; :ignore-error-status t)</span><br></pre></td></tr></table></figure><h3 id="11-重定向输入和输出">11. <strong>重定向输入和输出</strong></h3><p>从文件 <code>input.txt</code> 读取内容，通过外部命令处理并将输出写入 <code>output.txt</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(uiop:run-program &quot;cmd /c sort&quot; :input &quot;input.txt&quot; :output &quot;output.txt&quot;)</span><br></pre></td></tr></table></figure><h3 id="12-使用参数列表">12. <strong>使用参数列表</strong></h3><p>将命令及其参数分开作为列表传递，而不是字符串：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(uiop:run-program &#x27;(&quot;cmd&quot; &quot;/c&quot; &quot;echo&quot; &quot;Hello, World!&quot;))</span><br></pre></td></tr></table></figure><h3 id="13-执行-Windows-系统工具">13. <strong>执行 Windows 系统工具</strong></h3><p>运行 Windows 自带的工具，例如 <code>systeminfo</code> 查看系统信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(uiop:run-program &quot;cmd /c systeminfo&quot;)</span><br></pre></td></tr></table></figure><h3 id="14-执行可执行文件并等待退出">14. <strong>执行可执行文件并等待退出</strong></h3><p>运行外部程序并等待其退出，例如运行 <code>calc.exe</code> 打开计算器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(uiop:run-program &quot;calc.exe&quot;)</span><br></pre></td></tr></table></figure><h3 id="15-执行带路径的程序">15. <strong>执行带路径的程序</strong></h3><p>如果外部程序在指定路径下，可以直接传入完整路径：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(uiop:run-program &quot;C:\\Windows\\System32\\notepad.exe&quot;)</span><br></pre></td></tr></table></figure><h3 id="16-执行并行命令">16. <strong>执行并行命令</strong></h3><p>在 <code>cmd</code> 中使用 <code>&amp;&amp;</code> 执行多个命令，例如先执行 <code>echo</code> 然后执行 <code>dir</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(uiop:run-program &quot;cmd /c echo Start &amp;&amp; dir&quot;)</span><br></pre></td></tr></table></figure><h3 id="17-捕获命令退出状态">17. <strong>捕获命令退出状态</strong></h3><p>你可以捕获命令的退出状态（例如 0 表示成功，非零表示错误）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(let ((status (uiop:run-program &quot;cmd /c exit 2&quot; :ignore-error-status t)))</span><br><span class="line">  (format t &quot;Exit Status: ~A~%&quot; status))</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>通过以上示例，你可以看到 <strong><code>uiop:run-program</code></strong> 在 Windows 下的多种用法，包括：</p><ol><li>执行系统命令（如 <code>cmd /c dir</code>）。</li><li>调用外部程序（如 <code>notepad.exe</code>、<code>calc.exe</code>）。</li><li>传递输入输出数据。</li><li>捕获标准输出和错误输出。</li><li>处理批处理脚本和 PowerShell 命令。</li><li>将输出重定向到文件。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Lisp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Common Lisp </tag>
            
            <tag> uiop:run-program </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Common Lisp 变量</title>
      <link href="/2025/01/16/common-lisp-bian-liang/"/>
      <url>/2025/01/16/common-lisp-bian-liang/</url>
      
        <content type="html"><![CDATA[<p>Common Lisp 支持两种类型的变量：词法变量(lexical)和动态变量(dynamic)</p><h2 id="一-变量的基础知识">一 变量的基础知识</h2><p>和常见的编程语言一样，Common Lisp中的变量是一些可以保存值的具名位置，但在Common Lisp 中，变量并不像在C++或Java那样带有确定的类型，一个变量可以保存任何类型的值，并且这些变量带有可用于运行期类型检查的类型信息。因此，Common Lisp是动态类型的，如果将某个并非数字的对象传给了+函数，那么Common Lisp将会报类型错误。</p><span id="more"></span><p>某些特定类型的，诸如整数与字符，它们会在内存中直接表示，除此之外，Common Lisp中所有值都是对象的引用，如果一个变量保存了对一个可变对象的引用，那么就可以用该引用来修改此对象，而这种改动将应用于任何带有相同对象引用的代码。</p><p>一种常用的引入新变量的方式是定义函数形参，用DEFUN来定义函数时，形参列表定义了当函数被调用时用来保存实参的变量。例如，下列函数定义了三个变量 x, y 和 z，用来保存其实参。<br><code>(defun foo (x y z) (+ x y z))</code>, 每当函数被调用时，Lisp就会创建新的绑定来保存由函数调用者所传递的实参</p><p>引入变量的另一种方式是使用LET特殊操作符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(let (variable*)</span><br><span class="line">  body-form*)</span><br></pre></td></tr></table></figure><p>其中每一个variable都是一个变量初始化形式，每一个初始化形式要么是一个含有变量名和初值形式的列表，要么就是一个简单的变量名，这样该变量默认为NIL。下面的LET形式将三个变量x, y和z绑定到初始值10，20和NIL上。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(let ((x 10) (y 20) z)</span><br><span class="line">...)</span><br></pre></td></tr></table></figure><p>当这个LET形式被求值时，所有的初始值形式都将首先被求值，然后创建出新的绑定并在形式体被执行之前，这些绑定将初始化到适当的初始值上。在LET形式体中，变量名将引用新创建的绑定。在LET形式体执行结束后，这些变量名将重新引用在执行LET之前所引用的内容，如果有的话。形式体中最后一个表达式的值作为LET表达式的值返回。</p><p>如果嵌套了引入同名变量的绑定形式，那么最内层的变量绑定将覆盖外层的绑定。</p><p>另一个引入变量的方式是LET的变体: LET*。两者的区别是，在一个LET中，被绑定的变量名只能在LET的形式体之内(LET形式中变量列表之后的那部分)，但在LET*中，每个变量的初始值形式，都可以引用到那些在变量列表中早先引入的变量，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(let* ((x 10)</span><br><span class="line">       (y (+ x 10)))</span><br><span class="line">  (list x y))</span><br></pre></td></tr></table></figure><h2 id="二-词法变量和闭包">二 词法变量和闭包</h2><p>默认情况下，Common Lisp 中所有的绑定形式都将引入词法作用域变量，词法作用域的变量只能由那些在文本上位于绑定形式之内的代码所引用(也就是下列…处的代码)，类似于Java，C，C++中的局部变。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(let ((x 10) (y 20) z)</span><br><span class="line">...)</span><br></pre></td></tr></table></figure><p>但是当一个匿名函数含有一个对来自封闭作用域之内的词法变量的引用时，将会发生什么呢？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(let ((count 0)) #&#x27;(lambda () (setf count (1+ count))))</span><br></pre></td></tr></table></figure><p>这个含有引用的匿名函数将被作为LET形式的值返回，并可能通过FUNCALL被不在LET作用域之内的代码所调用。当控制流进入LET形式时所创建的count绑定将被尽可能地保留下来，只要某处保持了一个对LET形式所返回的函数对象的引用即可。这个匿名函数被称为一个闭包，因为它“封闭包装”了由LET创建的绑定。</p><p>理解闭包的关键在于，被捕捉的是绑定而不是变量的值。因此，一个闭包不仅可以访问它所闭合的变量的值，还可以对其赋予在闭包被调用时不断变化的新值。例如，可以像下面这样将前面的表达式所创建的闭包捕捉到一个全局变量里：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(defparameter *fn* (let ((count 0)) #&#x27;(lambda () (setf count (1+ count)))))</span><br></pre></td></tr></table></figure><p>然后每当调用它时，count的值将被加1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (funcall *fn*)</span><br><span class="line">1</span><br><span class="line">CL-USER&gt; (funcall *fn*)</span><br><span class="line">2</span><br><span class="line">CL-USER&gt; (funcall *fn*)</span><br><span class="line">3</span><br><span class="line">CL-USER&gt; (funcall *fn*)</span><br></pre></td></tr></table></figure><p>单一闭包可以简单的引用变量来闭合许多变量绑定，或是多个闭合可以捕捉相同的绑定。例如，下面的表达式返回由三个闭合所组成的列表，一个可以递增其所闭合的count绑定的值，另一个可以递减它，还有一个返回他的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(let ((count 0))</span><br><span class="line">  (list</span><br><span class="line">   #&#x27;(lambda () (incf count))</span><br><span class="line">   #&#x27;(lambda () (decf count))</span><br><span class="line">   #&#x27;(lambda () count)))</span><br></pre></td></tr></table></figure><h2 id="三-动态变量">三 动态变量</h2><p>动态变量也叫全局变量，一种可以从程序的任何位置访问到的变量。Common Lisp 提供了两种创建全局变量的方式：DEFVAR和DEFPARAMETER，两种方式都接受一个变量名，一个初始值以及一个可选的文档字符串。全局变量习惯上被命名为以*开始和结尾的名字：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(defvar *count* 0</span><br><span class="line">  &quot;Count of widgets made so far.&quot;)</span><br><span class="line"></span><br><span class="line">(defparameter *gap-tolerance* 0.001</span><br><span class="line">  &quot;Tolerance to be allowed in widget gaps.&quot;)</span><br></pre></td></tr></table></figure><p>两种方式的区别是DEFPARAMETER总是将初始值赋给命名的变量，而DEFVAR只有当变量未定义时才这样做。DEFVAR也可以不带初始值来使用，这样的变量称为未绑定的。从实践上来讲，应该使用DEFVAR来定义某些变量。</p><p>有时我们需要临时改变全局变量的值，并在代码块结束时自动使用之前的值，这时我们可以使用LET形式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(let ((*standard-output* *some-other-stream*))</span><br><span class="line">  (stuff))</span><br></pre></td></tr></table></figure><p>在任何由于调用stuff而运行的代码中， 对<code>*standard-output*</code>的引用将使用由LET所创建的绑定，并且当stuff返回并且程序控制离开LET时，这个对<code>*standard-output*</code>的新绑定将消失。</p><h2 id="四-常量">四 常量</h2><p>除了词法变量和动态变量外，还有一种类型的变量是常值变量，所有常量都是全局的，并且使用DEFCONSTANT定义，DEFCONSTANT的基本形式与DEFPARAMETER相似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(defconstant name initial-value-form [documentation-string])</span><br></pre></td></tr></table></figure><p>被DEFCONSTANT定义的常量不能被用作函数形参或是任何其他的绑定形式进行重新绑定，因此许多程序员遵循了一个命名约定，用以+开始和结尾的名字来表示常量。</p><h2 id="五-赋值">五 赋值</h2><p>一旦创建了绑定，就可以对它做两件事：获取当前值以及为它设置新值，一个符号被求值为它所命名的变量的值，而为绑定赋予新值可以使用SETF宏，这是Common Lisp的通用赋值操作符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(setf place value)</span><br></pre></td></tr></table></figure><p>因为SETF是宏，所以它可以检查它所赋值的place上的形式，并展开成适当的底层操作来修改那个位置。当该位置是变量时，它展开成一个对特殊操作符SETQ的调用，后者可以访问到词法和动态绑定。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(setf x 10)</span><br></pre></td></tr></table></figure><p>SETF也可用于依次对多个位置赋值，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(setf x 1)</span><br><span class="line">(setf y 2)</span><br></pre></td></tr></table></figure><p>可以写成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(setf x 1 y 2)</span><br></pre></td></tr></table></figure><p>SETF返回最近被赋予的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(setf x (setf y (random 10)))</span><br></pre></td></tr></table></figure><p>这样 x 和 y都被赋予同一个随机值。</p><h2 id="六-广义赋值">六 广义赋值</h2><p>SETF可以为任何位置赋值，例如数组，哈希表，列表以及由用户定义的数据结构，所有这些数据结构都含有多个可用来保存值的位置。<br>对于Python来说：</p><table><thead><tr><th>赋值对象</th><th>python</th><th>Lisp</th></tr></thead><tbody><tr><td>变量</td><td>x = 10</td><td>(setf x 10)</td></tr><tr><td>数组元素</td><td>a[0]=10</td><td>(setf (aref a 0) 10)</td></tr><tr><td>哈希表项</td><td>hash[‘key’]=10</td><td>(setf (gethash 'key hash) 10)</td></tr><tr><td>对象字段</td><td>o.fiele=10</td><td>(setf (field o) 10)</td></tr><tr><td>其中AREF是数组访问函数，GETHASH是哈希表查找，而field可能是一个访问某用户定义对象中名为field的成员的函数。</td><td></td><td></td></tr></tbody></table><h2 id="七-其他修改位置的方式">七 其他修改位置的方式</h2><p>尽管所有的赋值都可以用SETF来表达，但也存在一些固定的模式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(incf x)</span><br><span class="line">(decf x)</span><br><span class="line">(incf x 10)</span><br></pre></td></tr></table></figure><p>以上三行代码与以下三行代码等价：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(setf x (+ x 1))</span><br><span class="line">(setf x (- x 1))</span><br><span class="line">(setf x (+ x 10))</span><br></pre></td></tr></table></figure><p>类似INCF和DECF这种宏称为修改宏，修改宏是建立在SETF之上的宏。修改宏所定义的方式使其可以安全地用于那些表达式必须只被求职一次的位置。</p><p>有两个稍微有些难懂但很有用的修改宏是ROTATEF和SHIFTF。ROTATEF在位置之间轮换它们的值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(rotatef a b)</span><br></pre></td></tr></table></figure><p>上述代码将交换两个变量的值并返回NIL。它等价于以下形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(let ((tep a)) (setf a b b tep) nil)</span><br></pre></td></tr></table></figure><p>将上述代码格式化得到以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(let ((tmp a))             ; Step 1</span><br><span class="line">  (setf a b                ; Step 2</span><br><span class="line">        b tmp)             ; Step 3</span><br><span class="line">  nil)                     ; Step 4</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>ROTATEF和SHIFTF都可以被用于任意多个参数，并且和所有的修改宏一样，它们可以保证以从左到右的顺序对每个参数只求值一次。</p>]]></content>
      
      
      <categories>
          
          <category> Lisp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Common Lisp </tag>
            
            <tag> 变量 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Rust Slice Type</title>
      <link href="/2023/01/28/the-rust-slice-type/"/>
      <url>/2023/01/28/the-rust-slice-type/</url>
      
        <content type="html"><![CDATA[<h1>The Rust Slice Type</h1><p>Slice is a kind of data structure that store heap memory, it contains two fields, one representing the memory address and the other representing the length. Our most common string literal is a kind of slice.</p><p>Slice let us reference a contiguous sequence of elements in a collection rather than the whole collection. A slice is a kind of reference, so it does not have ownership. And the slice ensures that the data it references is always valid.</p><h2 id="String-Slices">String Slices</h2><p>A string slice is a reference to part of a String, and it looks like this:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];</span><br></pre></td></tr></table></figure><span id="more"></span><p>The s is a reference to the entire String <code>hello world</code>, but the world is a slice, it reference to part of the String <code>hello world</code>. String slice referring to part of a <code>String</code></p><p>We can use slices to refer to any part of a string with Rust’s <code>..</code>syntax, for example:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s</span> = <span class="type">String</span>::<span class="title function_ invoke__">from</span>(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">world</span> = &amp;s[<span class="number">6</span>..<span class="number">11</span>];    ==&gt; <span class="string">&quot;world&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s1</span> = &amp;s[<span class="number">3</span>..];     ==&gt; <span class="string">&quot;lo world&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2</span> = &amp;s[..];      ==&gt; <span class="string">&quot;hello world&quot;</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">s3</span> = &amp;s[..<span class="number">2</span>];      ==&gt; <span class="string">&quot;he&quot;</span></span><br></pre></td></tr></table></figure><p>The string slice type is represented by <code>&amp;str</code>, it can be used as a function return type, for example:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">fn</span> <span class="title function_">first_world</span>(s:&amp;<span class="type">String</span>) <span class="punctuation">-&gt;</span> &amp;<span class="type">str</span> &#123;</span><br><span class="line">    &amp;s[..]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Other-Slices">Other Slices</h2><p>In addition to string slicing, there are other collection slicing types, such as array slicing.</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">a</span>:[<span class="type">i8</span>;<span class="number">4</span>]=[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];     ==&gt; &amp;[<span class="type">i8</span>]</span><br><span class="line"><span class="keyword">let</span> <span class="variable">slice</span> = &amp;a[<span class="number">1</span>..<span class="number">3</span>];</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Rust </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rust </tag>
            
            <tag> slice </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Effective C++总结</title>
      <link href="/2023/01/12/effective-cpp/"/>
      <url>/2023/01/12/effective-cpp/</url>
      
        <content type="html"><![CDATA[<h2 id="导读"><strong>导读</strong></h2><p>学习程序语言根本大法是一回事；学习如何以某种语言设计并实现高效程序则是令一会事。</p><p>一组明智选择并精心设计的 classes，functions 和 templates 可使程序编写容易，直观，高效，并且远离错误。</p><h3 id="1-explicit"><strong>1 explicit</strong></h3><p>default 构造函数：一个可被调用而不带任何实参的函数，这样的构造函数要不没有参数，要不就是每个参数都有缺省值。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">    public:</span><br><span class="line">        A();          // default 构造函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B&#123;</span><br><span class="line">    explicit B(int x = 0, bool b = true);    // default 构造函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class C&#123;</span><br><span class="line">    explicit C(int x);    //不是 default 构造函数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>explicit ：阻止类被用来执行隐式类型转换，但仍然可以进行显式类型转换。</strong></p><p><code>C c = 123;  </code>         // 错误 C, explicit 禁止隐式类型转换</p><h3 id="2-构造函数"><strong>2 构造函数</strong></h3><p>除非有一个好理由允许构造函数被用于隐式类型转换，否则就把它声明 explicit</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">    public:</span><br><span class="line">        Widget();                               // default 构造函数</span><br><span class="line">        Widget(const Widget&amp; rhs);              // copy 构造函数</span><br><span class="line">        Widget&amp; operator=(const Widget&amp; rhs);   // copy assignment 操作符</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Widget w1;                                      // 调用 default 构造函数</span><br><span class="line">Widget w2(w1);                                  // 调用 copy 构造函数</span><br><span class="line">w1 = w2;                                        // 调用 copy assignment 构造函数</span><br></pre></td></tr></table></figure><p><strong>当看到等号时请小心，因为&quot;=&quot;语法可用来调用 copy 构造函数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget w3 = w2;                                 // 调用 copy 构造函数</span><br></pre></td></tr></table></figure><p><strong>区分 copy 构造和 copy 赋值很容易，如果一个新对象被定义，例如上述  w3，一定会有一个构造函数被调用。如果没有新对象被定义，例如上面的 w1=w2，就不会有构造函数被调用，自然就是赋值操作被调用。</strong></p><h3 id="3-避免对象的值传递"><strong>3 避免对象的值传递</strong></h3><p>copy 构造函数是一个尤其重要的函数，因为它定义了一个对象如何 passed by value（值传递）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bool hasAcceptableQuality(Widget w);</span><br><span class="line">...</span><br><span class="line">Widget awidget;</span><br><span class="line">if(hasAcceptableQuality(awidget))</span><br></pre></td></tr></table></figure><p>上述参数 w 是以 by value 方式传递给 hasAcceptableQuality，所以在上述调用中 awidget 被复制到 w 体内。这个复制动作由 Widget 的 copy 构造函数完成。</p><p><strong>Pass-by-value</strong>意味着调用 copy 构造函数，以 by value 传递用户自定义类型通常是个坏注意。pass-by-reference-to-const 往往是比较好的选择。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bool hasAcceptableQuality(const Widget&amp; w);</span><br></pre></td></tr></table></figure><h3 id="4-行为像函数的对象"><strong>4 行为像函数的对象</strong></h3><p>STL 中的许多相关机能以函数对象（function objects）实现，那是“行为像函数”的对象，这样的对象来自于重载 operator() （function call 操作符）的class。</p><h3 id="5-未定义行为"><strong>5 未定义行为</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int *p = 0;          // p 是一个 null 指针</span><br><span class="line">std::cout &lt;&lt; *p;     // 对一个 null 指针取值(dereferencing) 会导致未定义行为</span><br><span class="line"></span><br><span class="line">char name[] = &quot;Hello&quot;;           // name 是个数组，大小为 6（别忘记最末端的 null）</span><br><span class="line">char c = name[10];               // 涉及一个无效的数组索引，会导致不明确行为</span><br></pre></td></tr></table></figure><p><strong>未定义行为的结果不可预期，很可能让人不愉快，有时会耗费很多精力，因为它有时执行正常，有时造成崩溃，有时产出错误结果。</strong></p><h2 id="一、让自己习惯-C"><strong>一、让自己习惯 C++</strong></h2><h3 id="条款-01：视-C-为一个语言联邦"><strong>条款 01：视</strong> <strong>C++</strong> <strong>为一个语言联邦</strong></h3><p>为了理解 C++ ，必须认识其主要的次语言，总共有 4 个：</p><ol><li>C part of C++，当以 C++ 内的 C 充分工作时，高效编程守则映照出 C 语言的局限：没有模板，没有异常，没有重载</li><li>Object-Oriented C++：包括 classed（包括构造函数和析构函数），封装，继承，多态，虚函数（动态绑定）。这一部分是面向对象设计之古典守则在 C++ 上的最直接实施。</li><li>Template C++：C++ 的泛型编程部分，由于 templates 威力强大，它带来了崭新的编程范型（TMP，模板元编程）</li><li>STL：STL 是个 template，它对容器，迭代器，算法以及函数对象（function objects）的规约有极佳的紧密配合与协调。STL 有自己特殊的办事方式，当使用 STL 时，必须遵守它的规约。</li></ol><p>对内置类型而言，pass-by-value 通常比 pass-by-reference 高效。</p><p>当从 C part of C++ 迁往 Object-Oriented C++ 时，由于用户自定义构造函数和析构函数的存在，pass-by-reference-to-const 往往更好。当运用 Template C++ 时尤其如此，因为你都不知道所处理的对象类型。</p><p>当进入 STL 之后，迭代器和函数对象都是在 C 指针之上塑造出来的，所以对 STL 的迭代器和函数对象而言，旧式的 pass-by-value 守则再次适用。</p><h4 id="总结">总结</h4><p>C++ 并不是一个带有一组守则的一体语言：它是从四个次语言组成的联邦政府，每个次语言都有自己的规约。记住这四个次语言就会发现 C++ 容易了解得多。</p><h3 id="条款-02：尽量以-const-enum-inline-替换-define"><strong>条款 02：尽量以 const, enum, inline 替换 #define</strong></h3><h4 id="2-1-define-定义常量缺点">2.1 #define  定义常量缺点</h4><p>可以用以下方式定义常量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define ASPECT_RATIO 1.653</span><br></pre></td></tr></table></figure><blockquote><p>记号名称 ASPECT_RATIO 也许从未被编译器看见，于是 ASPECT_RATIO 有可能没进入记号表（symbol table）内。当运用此常量但获得一个编译错误提示时，可能会带来困惑。错误提示中可能会提到 1.653 而不是 ASPECT_RATIO。如果 ASPECT_RATIO 被定义在其他人写的头文件中，也许你对 ASPECT_RATIO 来自何处毫无概念，于是将因为追踪它而浪费时间。</p></blockquote><p>解决办法是以一个常量替换上述的宏：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const double AspectRation = 1.653;  // 大写名称通常用于宏</span><br></pre></td></tr></table></figure><blockquote><p>作为一个语言常量， AspectRation 肯定会被编译器看到，当然就会进入符号表内。此外对于浮点常量，使用常量可能比使用 <code>#define</code>导致较小量的码，因为预处理器“盲目将宏名称 ASPECT_RATIO 替换为 1.653 ”可能导致目标码(object code)出现多份 1.653，若改用常量 AspectRation 则不会出现这种情况。</p></blockquote><p>当以常量替换 #define，有两种特殊情况值得说说：</p><h4 id="2-2-const-定义常量指针">2.2 const 定义<strong>常量指针</strong></h4><p>常量定义式通常被放在头文件内（以便被不同的源码含入），因此有必要将指针（而不是指针所指之物）声明为 const。若要在头文件内定义常量的（不变的）字符串，需要写两次 const 。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const char* const authorName = &quot;Scott Meyers&quot;;</span><br></pre></td></tr></table></figure><p>使用 string 对象通常比上面的方式合宜：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const std::string authorName(&quot;Scott Meyers&quot;);</span><br></pre></td></tr></table></figure><h4 id="2-3-class-的专属常量">2.3 class 的专属常量</h4><p>将常量的作用域限制在 class 内，则让它成为一个成员，</p><p>确保此常量至多只有一份实体，则让他成为一个 static 成员：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class GamePlayer &#123;</span><br><span class="line">private:</span><br><span class="line">    static const int NumTurns = 5;     // 常量声明式</span><br><span class="line">    int scores[NumTurns];              // 使用该常量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然而上述的  NumTurns 只是声明式而非定义式。通常 C++ 要求你对你所使用的任何东西提供一个定义式，<strong>但如果它是个 class 专属常量又是 static 且为整数类型（integral type，例如 ints, chars, bools）则需要特殊处理。只要不取它们的地址，就可以声明并使用它们而无需提供定义式。</strong></p><p>如果需要取某个 class 专属常量的地址，或不取地址但编译器（不正确地）要看到一个定义式，可在实现文件中定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int GamePlayer::NumTurns;     // NumTurns 的定义式</span><br></pre></td></tr></table></figure><p>class 常量已经在声明时获得初始值，因此定义时不可再设初值。</p><p>旧式的编译器也许不支持上述语法，它们不允许 static 成员在其声明式上获得初值，此外所谓的“in-class 初值设定”，也只允许对整数常量进行。如果编译器不支持上述语法，可以将初始值放在定义式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class CostEstimate&#123;</span><br><span class="line">private:</span><br><span class="line">    static const double FudgeFactor;    // static class 常量声明</span><br><span class="line">    ...                                 // 位于头文件内</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const double CostEstimate::FudgeFactor = 1.35;     // static class 常量定义，位于实现文件内</span><br></pre></td></tr></table></figure><h4 id="2-4-enum-hack">2.4 enum hack</h4><p>当在 class 编译期间需要一个 class 常量值，万一编译器（错误地）不允许 “static 整数型class常量&quot;完成&quot;in class 初值设定”，可改用所谓的 “the enum hack” 补偿做法。其理论基础是：“一个属于枚举类型的数值可权充 int 被使用”，于是 GamePlayer 可被定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class GamePlayer &#123;</span><br><span class="line">private:</span><br><span class="line">    enum &#123;NumTurns = 5&#125;;               // &quot;the enum hack&quot; —— 令 NumTurns 成为 5 的一个记号</span><br><span class="line">    int scores[NumTurns];              // 这就没问题</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>enum hack 值得我们认识的数个理由：</p><ol><li>enum hack 的行为某方面比较像 #define 而不像 const。例如取一个 const 的地址是合法的，但取一个 enum 的地址就不合法，而取一个 #define 的地址通常也不合法</li><li>基于实用主义：许多代码用了它，所以看到它时你必须认识它。事实上 “enum hack” 是模板元编程的技术基础（见条款 48）</li></ol><h4 id="2-5-define-定义宏的缺点">2.5 #define  定义宏的缺点</h4><p>另一个常见的 #define 误用情况是以它实现宏。宏看起来像函数，但不会造成函数调用。下面这个宏夹带着宏实参，调用函数 f</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 以 a 和 b 的较大值调用 f</span><br><span class="line">#define CALL_WITH_MAX(a,b) f( (a)&gt;(b)?(a):(b) )</span><br></pre></td></tr></table></figure><p>当以如下方式调用宏时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int a=5,b=0;</span><br><span class="line">CALL_WITH_MAX(++a,b);           // a 被累加二次</span><br><span class="line">CALL_WITH_MAX(++a,b+10);        // a 被累加一次</span><br></pre></td></tr></table></figure><p>幸运的是你不需要对这种无聊事情提供温床，你可以获得宏带来的效率以及以一般函数的所有可预料行为和类型安全性（type safety），只需写出 template inline 函数。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">inline void callWithMax(const T&amp; a, const T&amp; b)&#123;</span><br><span class="line">    f(a&gt;b?a:b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个 inline 产出一群函数，每个函数都接受两个同型对象，并以其中较大者调用 f。这里不需要在函数体中为参数加上括号，也不需要操心参数被求值多次。此外由于 callWithMax 是个真正的函数，它遵守作用域（scope）和访问规则。例如你绝对可以写出一个 “class 内的 private inline 函数”。一般而言，宏无法完成此事。</p><h4 id="2-6-总结">2.6 总结</h4><p>对于常量，最好用 const 对象或 enum 对象替换 #define</p><p>对于形似函数的宏，最好改用 inline 函数替换 #define</p><h3 id="条款-03：尽可能使用-const"><strong>条款 03：尽可能使用 const</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int* const number = 1024;</span><br></pre></td></tr></table></figure><p>如果关键字出现在 “<em>” 左边，表示被指物是常量，如果出现在“</em>” 右边，表示指针自身是常量。如果出现在 “*” 两边，表示被指物和指针两者都是常量。</p><h4 id="3-1-迭代器与指针">3.1 迭代器与指针</h4><p>STL 迭代器基于指针而设计，迭代器的作用像个 T* 指针。</p><ul><li>声明迭代器为 const 就像声明指针为 const —— T* const，表示迭代器不得指向不同的东西</li><li>如果希望迭代器所指的东西不可被改动（模拟 const T*） ，使用 const_iterator</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;int&gt; vec;</span><br><span class="line">const std::vector&lt;int&gt;::iterator iter = vec.begin();          // iter 的作用像个 T* cosnt</span><br><span class="line">*iter = 10;                                                   // 没问题，改变 iter 所指物</span><br><span class="line">++iter;                                                       // 错误，iter 是 const</span><br><span class="line">std::vector&lt;int&gt;::const_iterator cIter = vec.begin();         // cIter 是 const</span><br><span class="line">*cIter = 10;                                                  // 错误,*cIter 是 const</span><br><span class="line">++cIter;                                                      // 没问题，改变 cIter</span><br></pre></td></tr></table></figure><h4 id="3-2-函数返回常量值">3.2 函数返回常量值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Rational &#123; ... &#125;</span><br><span class="line">const Rational operator* (const Rational&amp; rhs);</span><br><span class="line"></span><br><span class="line">Rational a,b,c;</span><br></pre></td></tr></table></figure><p>令返回值为 const，可以避免以下问题，许多程序员无意那么做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(a * b) = c;                   // 在 a * b 的成果上调用 operator=</span><br></pre></td></tr></table></figure><p>const 可以预防那个 “没意思的赋值动作”</p><h4 id="3-3-const-成员函数">3.3 const 成员函数</h4><p>目的：使该成员函数可作用于 const 对象身上，const 对象只能调用 const 成员函数：</p><ol><li>它们使 class 接口比较容易被理解，得知哪个函数可以改动对象，哪个函数不行</li><li>它们使 “操作 const 对象” 成为可能。</li></ol><p>改善 C++ 程序效率的一个根本方法是以 pass by reference-to-const 方式传递对象，前提是我们有 const 成员函数用来处理 const 对象。</p><p><strong>两个成员函数如果只是常量性不同，可以被重载</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class TextBlock &#123;</span><br><span class="line">public:</span><br><span class="line">    const char&amp; operator[](std::size_t position) const &#123;return text[position]&#125; //operator[] for const 对象</span><br><span class="line">    char&amp; operator[](std::size_t position) &#123;return text[position];&#125;  //operator[] for non-const 对象      </span><br><span class="line">private:</span><br><span class="line">    std::string text;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TextBlock tb(&quot;Hello&quot;);</span><br><span class="line">std::cout &lt;&lt; tb[0];          // 调用 non-const TextBlock::operator[]</span><br><span class="line"></span><br><span class="line">const TextBlock ctb(&quot;World&quot;);</span><br><span class="line">std::cout &lt;&lt; ctb[0];         // 调用 const TextBlock::operator[]</span><br><span class="line">只要重载 operator[] 并对不同的版本给予不同的返回类型，就可以令 const 和 non-const TextBlocks 获得不同的处理：</span><br><span class="line">std::cout &lt;&lt; tb[0];   // 没问题，读一个 non-const TextBlock</span><br><span class="line">tb[0] = &#x27;x&#x27;;          // 没问题，写一个 non-const TextBlock</span><br><span class="line">std::cout &lt;&lt; ctb[0];  // 没问题，读一个 const TextBlock</span><br><span class="line">ctb[0] = &#x27;x&#x27;;         // 错误，写一个 const TextBlock</span><br></pre></td></tr></table></figure><p>const 成员函数不可以更改对象内任何 non-static 成员变量。</p><h4 id="3-4-物理常量性和逻辑常量性">3.4 物理常量性和逻辑常量性</h4><p>bitwise constness（又称为 physical constness）和 logical constness。</p><ul><li>bitwise constness</li></ul><p>成员函数只有在不更改对象之任何成员变量（static 除外）时才可以说是 const 。bitwise constness 正是 C++ 对常量性（constness）的定义，因此 const 成员函数不可以更改对象内任何 non-staic 成员变量。</p><p>不幸的是许多成员函数虽然不十足具备 const 性质却能通过 bitwish 测试，例如只有指针（而非其所指物）隶属于对象，即使只更改了“指针所指物”，那么称此函数为 bitwise const 不会引发编译器异议。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class CTextBlock &#123;</span><br><span class="line">public:</span><br><span class="line">    char &amp;operator[](std::size_t position) const        // bitwise const 声明，但其实不恰当</span><br><span class="line">    &#123;return pText[position];&#125;  </span><br><span class="line">    </span><br><span class="line">    private:</span><br><span class="line">        char* pText;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>operator[] 实现代码并不更改 pText，看看以下代码发生什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const CTextBlock cctb(&quot;Hello&quot;);           // 声明一个常量对象</span><br><span class="line">char* pc = &amp;cctb[0];                      // 调用 const operator[] 取得一个指针，指向 cctb 数据</span><br><span class="line">*pc = &#x27;J&#x27;;                                // cctb 现在变为 &#x27;Jello&#x27;</span><br></pre></td></tr></table></figure><ul><li>logical constness</li></ul><p>逻辑常量性：逻辑上维持常量性，但对象的某些 bits 可能被修改。</p><p>一个 const 成员函数可以修改它所处理的对象内的某些 bits。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class CTextBlock &#123;</span><br><span class="line">public:</span><br><span class="line">    std::size_t textLength;              // 最近一次计算的文本区块长度</span><br><span class="line">private:</span><br><span class="line">    char *pText;</span><br><span class="line">    std::size_t textLength;              // 最近一次计算的文本区块长度</span><br><span class="line">    bool lengthIsValid;                  // 目前长度是否有效</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::size_t CTextBlock::length const&#123;</span><br><span class="line">    if(!lengthIsValid) &#123;</span><br><span class="line">        textLength = std::strlen(pText);  // 错误，在 const 成员函数内</span><br><span class="line">        lengthIsValid = true;             // 不能赋值给 textLength 和 lengthIsValid</span><br><span class="line">        return textLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述实现当然不是 bitwise，因为 textLength 和 lengthIsValid 都可能被修改。那怎样才能通过编译器编译呢？</p><p>利用 C++ 的一个与 const 的摆动场：mutable（可变的）。mutable 释放掉 non-static 成员变量的 bitwish constness 约束。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class CTextBlock &#123;</span><br><span class="line">public:</span><br><span class="line">    std::size_t textLength;              // 最近一次计算的文本区块长度</span><br><span class="line">private:</span><br><span class="line">    char *pText;</span><br><span class="line">    mutable std::size_t textLength;              // 最近一次计算的文本区块长度</span><br><span class="line">    mutable bool lengthIsValid;                  // 目前长度是否有效</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::size_t CTextBlock::length const&#123;</span><br><span class="line">    if(!lengthIsValid) &#123;</span><br><span class="line">        textLength = std::strlen(pText);  // 错误，在 const 成员函数内</span><br><span class="line">        lengthIsValid = true;             // 不能赋值给 textLength 和 lengthIsValid</span><br><span class="line">        return textLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-在-const-和-non-const-成员函数中避免重复">3.5 在 const 和 non-const 成员函数中避免重复</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class TextBlock &#123;</span><br><span class="line">public:</span><br><span class="line">    const char&amp; operator[] (std::size_t position) cosnt&#123;</span><br><span class="line">        ...          // 边界检验</span><br><span class="line">        ...          // 标记数据访问</span><br><span class="line">        ...          // 校验数据完整性</span><br><span class="line">        return text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    char&amp; operator[](std::size_t position)&#123;</span><br><span class="line">        ...          // 边界检验</span><br><span class="line">        ...          // 标记数据访问</span><br><span class="line">        ...          // 校验数据完整性</span><br><span class="line">        return text[position];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到上述代码为了实现两种方式的返回值，有大量的代码冗余，可以使用下面的方式消除代码冗余：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class TextBlock &#123;</span><br><span class="line">public:</span><br><span class="line">    const char&amp; operator[] (std::size_t position) const&#123;</span><br><span class="line">        ...          // 边界检验</span><br><span class="line">        ...          // 标记数据访问</span><br><span class="line">        ...          // 校验数据完整性</span><br><span class="line">        return text[position];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 首先将当前对象加上 const 调用 const 成员函数，然后将返回值中的 const 去掉</span><br><span class="line">    char&amp; operator[](std::size_t position)&#123;</span><br><span class="line">        return </span><br><span class="line">            const_cast&lt;char&amp;&gt; (                             // 将 op[] 返回值中的 const 转除</span><br><span class="line">                static_cast&lt;const TextBlock&amp;&gt;(*this)        // 为 *this 加上 const</span><br><span class="line">                    [positon]                               // 调用 const op[]</span><br><span class="line">            );   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-总结">3.6 总结</h4><p>const 可以用于以下方面：在指针和迭代器身上；在指针，迭代器及references 设及的对象身上；在函数参数和返回类型身上；在 local 变量身上；在成员函数身上。</p><ul><li>将某些东西声明为 const 可帮助编译器侦测出错误用法。const 可被施加于任何作用域内的对象，函数参数，函数返回类型，成员函数本体。</li><li>编译器强制实施 bitwish constness。但编写程序时应该使用“概念上的常量性（conceptual constness）”。</li><li>当 const 和 non-const 成员函数有着实质的的等价的实现时，令 non-const 版本调用 const 版本可避免代码重复。</li></ul><h3 id="条款04：确定对象被使用前已被初始化"><strong>条款04：确定对象被使用前已被初始化</strong></h3><p><code>int x;</code> x 此时并未被初始化，未初始化之前使用 会导致以下问题：</p><ul><li>未定义行为</li><li>可能导致崩溃（某些平台）</li><li>读入一些半随即 “bits”，污染了正在进行读取动作的对象，导致不可预知的程序行为以及一些不愉快的调试过程。</li></ul><p><strong>永远在使用对象之前先将它初始化。对于无任何成员的内置类型，必须手工完成此事。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int x = 0;                  // 对 int 进行手工初始化</span><br><span class="line">const char* text = &quot;A C-style string&quot;;        // 对指针进行初始化</span><br><span class="line">double d;</span><br><span class="line">std::cin &gt;&gt; d;                                // 以读取 input stream 的方式完成初始化</span><br></pre></td></tr></table></figure><p>至于内置类型以外的任何其他东西，初始化责任落在构造函数。规则很简单，确保每一个构造函数都将对象的每一个成员初始化。</p><h4 id="4-1-成员初始化列表">4.1 成员初始化列表</h4><p>不要混淆了赋值（assignment）和初始化（initialization）。例如下列代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class PhoneNumber &#123; ... &#125;;</span><br><span class="line">class ABEntry&#123;           // ABEntry = &quot;Address Book Entry&quot;</span><br><span class="line">public:</span><br><span class="line">    ABEntry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones);</span><br><span class="line">private:</span><br><span class="line">    std::string theName;</span><br><span class="line">    std::string theAddress;</span><br><span class="line">    std::list&lt;PhoneNumber&gt;thePhones;</span><br><span class="line">    int numTimesConsulted;</span><br><span class="line">&#125;</span><br><span class="line">ABEntry::ABEtry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones)&#123;</span><br><span class="line">    // 以下都是赋值，而非初始化</span><br><span class="line">    theName = name;   </span><br><span class="line">    theAddress = address;</span><br><span class="line">    thePhones = phones;</span><br><span class="line">    numTimesConsulted = 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这不是最佳做法，C++ 规定，对象的成员函数的初始化动作发生在进入构造函数本体之前。ABEntry 构造函数的一个较佳写法，使用所谓的 member initialzation list（成员初始化列表）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::ABEtry(const std::string&amp; name, const std::string&amp; address, const std::list&lt;PhoneNumber&gt;&amp; phones):theName(name),theAddress(address),thePhones(phones),numTimesConsulted(0)&#123;</span><br><span class="line">    // 以下都是赋值，而非初始化</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述效率通常更高。基于赋值的那个版本首先调用 default 构造函数为 theName, theAddress 和 thePhones 设初值，然后立刻对它们赋予新值，default 构造函数的一切作用因此浪费了。初始值列表避免了这一问题。**因为初值列中各个成员变量而设的实参，被拿去作为各成员变量之构造函数的实参。**本例中的 theName 以 name 为初值进行 copy 构造，theAddress 以 address 为初值进行 copy 构造，thePhones 以 phones 为初值进行 copy 构造。</p><p>**对大多数类型，比起先调用 default 构造函数，再调用 copy assignment（拷贝赋值运算符）。单只调用一次 copy 构造函数是比较高效的 。**对于内置对象 numTimesConsulted，其初始化和赋值的成本相同，但为了一致性最好也通过成员初值列表来进行初始化。</p><p>或者当想要 default 构造一个成员变量，都可以使用初始值列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ABEntry::ABEntry()</span><br><span class="line">:theName(),                        // 调用 theName 的 default 构造函数</span><br><span class="line">theAddress(),                      // 同上</span><br><span class="line">thePhones(),                       // 同上</span><br><span class="line">numTimesConsulted(0)               // 记得将  numTimesConsulted 显式初始化为0</span><br><span class="line">&#123;&#125; </span><br></pre></td></tr></table></figure><p>规则：规定总是在初始值列中列出所有成员变量，以免还得记住哪些成员变量可以无需初值。例如：如果 numTimesConsulted 属于内置类型，但初始值列表遗漏了它，它就可能会获得随即值。</p><p>如果成员变量是 const 或 references ，它们就一定需要初值，不能被赋值。</p><p>C++ 的“成员初始化次序”，先初始化基类，然后初始化派生类。class 的成员变量总是以其声明次序被初始化，和成员初始化列表的次序没有关系。</p><h4 id="4-2-non-local-static-对象">4.2 non-local static 对象</h4><p>static 对象，其寿命从被构造出来直到程序结束为止。因此 stack 和 heap-based对象被排除。static 对象包括 global 对象，定义于 namespace 作用域内的对象，在 classes 内，在函数内，以及在 file 作用域内被声明为 static 的对象。函数内的 static 对象称为 local static 对象（因为它们对函数而言是 local）。</p><p>其他 static 对象称为 non-local static 对象。程序结束时 static 对象会被自动销毁，也就是它们的析构函数会在 main() 结束时自动调用。</p><p>编译单元：产出单一目标文件的那些源码。</p><p>某个编译单元的某个 non-local static 对象的初始化动作使用了另一个编译单元的 non-local static ，它所用的对象可能尚未被初始化，因为 C++ 对 &quot;定义于不同编译单元内的 non-local static 对象&quot;的初始化次序并无明确规定。以下举例说明：</p><p>假设现有一个 FileSystem class ，它让互联网上的文件看起来好像位于本机（local）。你可能会产出一个特殊对象，位于 global 或 namespace 作用域内，象征单一文件系统：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class FileSystem&#123;</span><br><span class="line">public:</span><br><span class="line">    std::size_t numDisks() const;                  // 众多成员函数之一</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意 tfs 对象，如果在它未构造完成之前就使用它，会得到惨重的灾情。</p><p>现在假设某些客户建立了一个 class 用以处理文件系统内的目录（directories），很自然他们的 class 会用上 tfs 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">extern FileSystem tfs;                             // 预备给客户使用的对象</span><br><span class="line"></span><br><span class="line">class Directory&#123;            // 由程序库客户建立</span><br><span class="line">public:</span><br><span class="line">    Directory(params);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Directory:: Directory(params)&#123;</span><br><span class="line">    ...</span><br><span class="line">    std::size_t disks = tfs.numDisks();   // 使用 tfs 对象</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进一部假设，这些客户决定创建一个 Directory 对象，用来放置临时文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Directory tempDir(params);                   // 为临时文件而做出的目录</span><br></pre></td></tr></table></figure><p>除非  tfs 在 temDir 之前初始化，否则 temDir 的构造函数会用到尚未初始化的 tfs。但 tfs 和 temDir 是不同的人在不同的时间于不同的源码文件中建立起来的，它们是定义于不同编译单元内的 non-local static 对象。</p><p>幸运的是一个小小的设计便可以完全消除这个问题 。唯一需要做的就是：</p><p>将每个 non-local static 对象搬到自己的专属函数内（该对象在此函数内被声明为 static）。这些函数返回一个 reference 指向它所含的对象。然后用户调用这些函数，而不直接指涉这些对象。换句话说，non-local static 对象被 local static 对象替换了。</p><p>从 Design Pattern 上来说，这属于 Singleton 模式的一个常见实现手法。</p><p>这个手法的基础在于：C++ 保证，函数内的 local static 对象会在 “该函数被调用期间”  “首次遇上该对象之定义式” 时被初始化。以 “函数调用” 替换 “直接访问 non-local static 对象” 就保证了所获得的那个 reference 将指向一个经历初始化的对象。更棒的是，如果从未调用 non-local static 对象的&quot;仿真函数&quot;，就绝不会引发构造和析构成本。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class FileSystem &#123;...&#125;;                    // 同前</span><br><span class="line">FileSystem&amp; tfs()&#123;                        // 这个函数替换 tfs 对象</span><br><span class="line">    static FileSystem fs;</span><br><span class="line">    return fs;                            // 返回一个 reference 指向上述对象</span><br><span class="line">&#125;</span><br><span class="line">class Directory &#123; ... &#125;;                  // 同前</span><br><span class="line">Directory::Directory(params)&#123;  // 同前，但原本的 reference to tfs，现在改为 tfs()</span><br><span class="line">    ... </span><br><span class="line">    std::size_t disks = tfs().numDisks();</span><br><span class="line">    ...</span><br><span class="line">&#125;              </span><br><span class="line"></span><br><span class="line">Directory&amp; tempDir()&#123;                   // 这个函数用来替换 tempDir 对象</span><br><span class="line">    static Directory td;                // 它在 Directory class 中可能是个 static</span><br><span class="line">    return td;                          // 返回一个 reference 指向上述对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：这些函数内含 static 对象的事实使它们在多线程系统中带有不确定性。任何一种 non-const static 对象，无论它是 local 或 non-local，在多线程下&quot;等待某事发生&quot;都会有麻烦。</p><p>解决办法：在程序的单线程启动阶段手工调用所有 reference-returning 函数，这可消除与初始化有关的&quot;竞速形势&quot;。</p><p><strong>为避免对象初始化之前过早地使用它们，你需要做三件事。第一：手工初始化内置 non-member 对象。第二，使用成员初始化列表对付对象的所有成分。最后在&quot;初始化次序不确定性&quot;氛围下加强你的设计。</strong></p><h4 id="4-3-总结">4.3 总结</h4><ul><li>为内置类型进行手工初始化，因为 C++ 不保证初始化它们</li><li>构造函数最好使用成员初始化列表，而不要在构造函数本体内使用赋值操作。</li><li>为免除 “跨编译单元之初始化次序”问题，请以 local static 对象替换 non-local static 对象。</li></ul><h2 id="二、构造-析构-赋值运算">二、构造/析构/赋值运算</h2><p>每个 class 都会有一或多个构造函数，一个析构函数，一个 copy assignment 操作符。得确保它们的行为正确，因为它们是 class 的脊柱。</p><h3 id="条款05：了解-C-默默编写并调用哪些函数">条款05：了解 C++ 默默编写并调用哪些函数</h3><p>一个类即使没有声明任何函数，编译器也会为它声明一个 copy 构造函数，一个 copy assignment 操作符和一个析构函数，一个 default 构造函数。所有这些函数都是 public 且 inline。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class Empty &#123;&#125;;</span><br></pre></td></tr></table></figure><p>经过编译器，它会变成这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Empty &#123;</span><br><span class="line">    Empty() &#123; ... &#125;                   // default 构造函数</span><br><span class="line">    Empty(const Empty&amp; rhs) &#123; ... &#125;   // copy 构造函数</span><br><span class="line">    ~Empty() &#123; ... &#125;                  // 析构函数，是否是 virtual 见稍后说明</span><br><span class="line">    </span><br><span class="line">    Empty&amp; operator=(const Empty&amp; rhs) &#123; ... &#125; // copy assignment 操作符</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>只有当这些函数被需要（被调用），它们才会被编译器创建出来。程序中需要它们是很平常的事：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    Empty e1;             // default 构造函数             </span><br><span class="line">    Empty e2(e1);         // copy 构造函数</span><br><span class="line">    e2 = e1;              // copy assignment</span><br><span class="line">                          // 析构函数                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器为啥要生成这些函数呢？default 构造函数和析构函数主要是给编译器一个地方用来放置 &quot;藏身幕后&quot;的代码，像是调用 base classes 和 non-static 成员变量的构造函数和析构函数。<strong>注意：编译器产出的析构函数是个 non-virtual 。除非这个 class 的 base class 自身声明有 virtual 析构函数（这种情况下这个函数的虚属性主要来自 base class）</strong></p><p>至于 copy 构造函数和 copy assignment 操作符，编译器创建的版本只是单纯地将来源对象的每一个 non-static 成员变量拷贝到目标对象。考虑一个 NameObject template，它允许你将一个个名称和类型为 T 的对象产生关联：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class NamedObject&#123;</span><br><span class="line">public:</span><br><span class="line">    NamedObject(const char* name, const T&amp; value);</span><br><span class="line">    NamedObject(const std::string&amp; name, const T&amp; value);</span><br><span class="line">    ...</span><br><span class="line">private:</span><br><span class="line">    std::string nameValue;</span><br><span class="line">    T objectValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于其中已经声明了一个构造函数，编译器就不再为它创建一个 default 构造函数，但会为它创建 copy 构造函数和 copy assignment 操作符。copy 构造函数的用法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NamedObject&lt;int&gt; no1(&quot;Smallest Prime Number&quot;,2);</span><br><span class="line">NamedObject&lt;int&gt; no2(no1);                          // 调用 copy 构造函数</span><br></pre></td></tr></table></figure><p>编译器生成的 copy 构造函数必须以 no1.nameValue 和 no1.objectValue 为初值设定 no2.namevalue 和 no2.objectValue。no2.nameValue 的初始化方式是调用 string 的 copy 构造函数。另一个成员 NameObject<int>::objectValue 的类型是 int，因此 T 是 int，是个内置类型，所以 no2.objectValue 会以拷贝 no1.objectValue 内的每一个 bits 来完成初始化。</p><p>编译器为 NamedObject<int> 所产生的 copy assignment 操作符。一般而言只有当产生的代码合法且有适当机会证明它有意义，万一两个条件有一个不符合，编译器会拒绝 class 产出 operator=</p><p>举例，NamedObject 定义如下，其中 nameValue 是个 reference to string, objectValue 是个 const T：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class NamedObject&#123;</span><br><span class="line">public:</span><br><span class="line">    // 以下构造函数不再接受一个 const 名称，因为 nameValue 是个 reference-to-non-const string</span><br><span class="line">    NamedObject(const std::string&amp; name, const T&amp; value);</span><br><span class="line">    ...</span><br><span class="line">private:</span><br><span class="line">    std::string&amp; nameValue;           // 现在是一个 reference</span><br><span class="line">    const T objectValue;              // 现在是个 const </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在考虑以下情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::string newDog(&quot;PersePhone&quot;);</span><br><span class="line">std::string oldDog(&quot;Satch&quot;);</span><br><span class="line">NameObject&lt;int&gt; p(newDog,2);           // 我们的狗 PersePhone 即将度过其第二个生日</span><br><span class="line">NameObject&lt;int&gt; s(oldDog,36);          // Satch 现在 36 岁</span><br><span class="line">p = s;                                 // 现在 p 成员变量发生了什么     </span><br></pre></td></tr></table></figure><p>该赋值动作如何影响 p.nameValue 呢？难道 p.nameValue 应该指向 s.nameValue吗？当然是不是的，因为 C++ 并不允许“让 reference 改指向不同对象”。或者 p.nameValue 所指的哪个 string 该被修改，进而影响持有 pointers 或 references 而且指向该 string 的其他对象吗？</p><ul><li>面对这个难题，C++ 的响应是拒绝编译那一行赋值动作。如果你打算在一个“内含 reference 成员”的 class 内支持赋值操作，就必须定义自己的 copy assignment 操作符。</li><li>面对 “内含 const 成员”，编译器的反应也一样。</li><li>还有一种情况，如果某个 base classes 将 copy assignment 操作符声明为 private，编译器将拒绝为其 derived classes 生成 copy assignment。</li></ul><h4 id="总结-2">总结</h4><p>编译器可以暗自为 class 创建 default 构造函数，copy 构造函数，copy assignment 操作符，以及析构函数。</p><h3 id="条款-06：若不想使用编译器自动生成的函数，就应该明确拒绝">条款 06：若不想使用编译器自动生成的函数，就应该明确拒绝</h3><h4 id="6-1-不安全的做法：">6.1 不安全的做法：</h4><p>所有编译器产生的函数都是 public ，为阻止这些函数被创建，得自行声明他们，可以将 copy 构造函数或 copy assignment 操作符声明为 private。</p><p>一般而言这个做法并不绝对安全，因为 member 函数和 friend 函数还是可以调用 private 函数，除非不去定义他们。</p><h4 id="6-2-安全做法">6.2 安全做法</h4><p>将 copy 构造函数或 copy assignment 操作符声明为 private，且故意不实现他们。这样当客户企图拷贝某个对象，编译器会阻饶它。如果不慎在 member 函数或 friend 函数之内那么做，轮到连接器发出抱怨。</p><h4 id="6-3-更聪明的做法">6.3 更聪明的做法</h4><p>将连接期错误移至编译器是可能的，而且是好事，毕竟越早发现错误越好。将 copy 构造函数或 copy assignment 操作符声明为 private，但不是在目标对象内，而是在一个专门为了阻止 copying 动作而设计的 base class 内：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Uncopyable &#123;</span><br><span class="line">protected:</span><br><span class="line">    Uncopyable() &#123;&#125;                   // 允许 derived 对象构造和析构</span><br><span class="line">    ~ Uncopyable() &#123;&#125;</span><br><span class="line">private:</span><br><span class="line">    Uncopyable(const Uncopyable&amp;);    // 阻止 copying</span><br><span class="line">    Uncopyable&amp; operator=(const Uncopyable&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了阻止拷贝 HomeForSale 对象，唯一需要做的就是继承 Uncopyable</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class HomeForSale: private Uncopyable&#123;         // class 不再声明 copy 构造函数和 copy assignment 操作符</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样的话，只要任何人——甚至是 member 函数或 friend 函数，尝试拷贝 HomeForSale 对象，编译器便尝试生成一个 copy 构造函数和一个 copy assignment 操作符号，而这些函数会尝试调用其 base class 的对应兄弟，那些调用会被编译器拒绝，因为其 base class 的拷贝函数是 private。</p><h4 id="6-4-总结">6.4 总结</h4><p>为驳回编译器自动生产 copy 构造函数和 copy assignment 操作符。可以将相应的成员函数声明为 private 并且不予实现。或者像 Uncopyable 这样的 base class 也是一种做法。</p><h3 id="条款-07：为多态基类声明-virtual-析构函数">条款 07：为多态基类声明 virtual 析构函数</h3><h4 id="7-1-virtual-析构函数的作用">7.1 virtual 析构函数的作用</h4><p>当一个 derived class 对象经由一个 base class 指针被删除，而该 base class 含有一个 non-virtual 析构函数，其结果未定义。实际可能发生的是对象的 derived 成分没有被销毁，其 base class 成分通常会被销毁。这就造成了诡异的 “局部销毁”对象。</p><p>消除上述问题的办法，给 base class 一个 virtual 析构函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class TimeKeeper &#123;</span><br><span class="line">public:</span><br><span class="line">    TimeKeeper();</span><br><span class="line">    virtual ~TimeKeeper();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">TimeKeeper* ptk = getTimeKeeper();</span><br><span class="line">...</span><br><span class="line">delete ptk; </span><br></pre></td></tr></table></figure><p>像 TimeKeeper 这样的 base classes 除了析构函数之外通常还有其他 virtual 函数，因为 virtual 函数的目的就是允许 derived class 的某些成员函数采用不同的源码实现，以实现多态。</p><p><strong>任何 class 只要带有 virtua 函数都几乎确定应该也有一个 virtual 析构函数。</strong></p><h4 id="7-2-不含-virtual-函数的好处">7.2 不含 virtual 函数的好处</h4><p>如果 class 不含 virtual 函数，通常表示它不意图被用作一个 base class。当一个 class 不被企图当作一个 base class，令其析构函数为 virtual 往往是个搜主意。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;</span><br><span class="line">public:</span><br><span class="line">    Poing(int x,int y);</span><br><span class="line">    ~Point();</span><br><span class="line">private:</span><br><span class="line">    int x,int y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果 int 占 32 bits，那么 Point 对象可塞入一个 64-bit 缓冲器中。这样一个 Point 对象可被当作一个 “64-bit 量”传给以其他语言如 C 或 FORTRAN 写的函数。</p><p>然而当 Point 的析构函数是 virtual ，情况就大不相同了：</p><p>为了实现 virtual 函数，对象必须携带某些信息，主要用来在运行期决定哪一个 virtual 函数被调用，这份信息通常由一个所谓 vptr(virtual table Pointer)指针指出。vptr 指向一个由函数指针构成的数组，称为 vtbl(virtual table)，每一个带有 virtual 函数的 class 都带有一个相应的 vtbl。当对象调用某一 virtual 函数，实际被调用的函数取决于该对象的  vptr 所指的那个 vbtl——编译器在其中寻找适当的函数指针。</p><h4 id="7-3-virtual-函数的误用">7.3 virtual 函数的误用</h4><h5 id="移植相关">移植相关</h5><ol><li>当一个 class 含有虚函数，其对象的体积会增加，在 32-bit 计算机体系结构中将占用 96 bits（两个 int 和一个 vptr）。在 64 bits 计算机体系结构中可能占用 128 bits（两个 int 和一个 64 bits 指针）。为 Point 添加一个 vptr 会增加其对象大小达 50%~100%，Point 对象将不再能够塞入一个 64-bit 缓冲器。因此也就不再可能把它传递至（或接受自）其他语言所写的函数（因为其他语言的对应物并没有 vptr），也因此不再具有移植性。</li></ol><h5 id="继承相关">继承相关</h5><p>只有当 class 内含有至少一个 virtual 函数，才为它声明 virtual 析构函数。即使 class 完全不带 virtual 函数，造成“non-virtual 析构函数问题”也有可能。举个例子，标准 string 不含任何 virtual 函数，有时候程序员会错误地把它当作 base class：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class SpecialString: public std::string &#123;  // 搜主意： std::string 有个 non-virtual 析构函数</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看似无害，如果无意间将一个 pointer-to-SpecialString 转换为一个 pointer-to-string，然后将转换所得的那个 string 指针 delete 掉。就会引发诡异的“局部销毁”对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SpecialString *pss = new SpecialString(&quot;Test Dog&quot;);</span><br><span class="line">std::string *ps;</span><br><span class="line">...</span><br><span class="line">ps = pss;</span><br><span class="line">...</span><br><span class="line">delete ps;               // 未定义，*ps 的 SpecialString 资源会泄漏，因为 SpecialString 的析构函数没有被调用</span><br></pre></td></tr></table></figure><p>相同的分析适用于任何不带 virtual 析构函数的 class，包括所有的 STL 容器如 vector，list，set，trl::unordered_map。</p><p><strong>很不幸，C++ 没有提供类似 Java 的 final classed 或 C# 的 sealed class 那样的 “禁止派生机制”。</strong></p><h4 id="7-4纯虚函数">7.4纯虚函数</h4><p>纯虚函数导致抽象 classes，也就是不能被实例化的 class。由于抽象 class 总是企图被当作一个 base class 来用，而又由于 base class 应该有个 virtual 析构函数，并且由于纯虚函数会导致抽象 class。还有一点，有时候希望拥有抽象 class ，但手上没有任何 pure virtual 函数，怎么办？</p><p>解法很简单，为你希望它成为抽象的那个 class 声明一个 pure virtual 析构函数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class AWOV &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ~AWOV() = 0;                 // 声明 pure virtual 析构函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>必须为这个 pure virtual 析构函数提供一份定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AWOV::~AWOV() &#123;&#125;      // pure virtual 析构函数的定义</span><br></pre></td></tr></table></figure><p>析构函数的运作方式是，最深层派生的那个 class 其析构函数最先被调用，然后是其中每一个 base class 的析构函数被调用。编译器会在 AWOV 的 derived classes 的析构函数中创建一个对 ~AWOV 的调用动作，所以你必须为这个函数提供一份定义。</p><p>“给 base classes 一个 virtual 析构函数”，这个规则只适用于带多态性质的 base classes 身上。这种 base classes 的设计目的是为了用来“通过 base class 接口处理 derived class 对象”。</p><p>并非所有 base classes 的设计目的都是为了多态用途。例如标准 string 和 STL容器都不被设计作为 base classes 使用，它们并非被设计用来“经由 base class 接口处理 derived class 对象”，因此它们不需要 virtual 析构函数。</p><h4 id="7-5-总结">7.5 总结</h4><p>Polymorphic（带多态性质的）base classes 应该声明一个 virtual 析构函数。如果 class 带有任何 virtual 函数，它就应该拥有一个 virtual 析构函数</p><p>class 的设计目的不是作为 base classes 使用，或不是为了具备多态，就不该声明 virtual 析构函数。</p><h3 id="条款-08：别让异常逃离析构函数">条款 08：别让异常逃离析构函数</h3><p>C++ 并不禁止析构函数吐出异常，但它不鼓励你这样做。在两个异常同时存在的情况下，程序若不是结束执行，就是导致不明确行为。</p><p>假设有一个 class 负责数据库连接：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class DBConnection &#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">    static DBConnection create();           // 返回 DBConnection 对象</span><br><span class="line">    void close();                           // 关闭连接，失败则返回异常                                                                    &#125;;</span><br></pre></td></tr></table></figure><p>为了确保不会忘记在 DBConnection 身上调用 close()，一个合理想法就是创建一个用来管理 DBConnection 资源的 class，并在其析构函数中调用 close：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class DBCon &#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">    ~DBCon()&#123;            // 确保数据库连接总是会被关闭</span><br><span class="line">        db.close();</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    DBConnection db;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>假设客户端写出以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">DBCon dbc(DBConnection::create()); // 建立 DBConnection 对象并交给 DBConn 对象管理</span><br><span class="line">                                   // 通过 DBConn 的接口使用 DBConnection 对象</span><br><span class="line">&#125;                                  // 在区块结束点，DBConn 对象被销毁，因而自动为 DBConnection 对象调用 close </span><br></pre></td></tr></table></figure><p>只要调用 close 成功，一切都美好。如果调用导致异常，DBConn 析构函数会传播该异常，也就是允许它离开这个析构函数。那会造成问题。</p><p>有两个办法可以避免这个问题，DBConn 析构函数可以：</p><ol><li>如果 close 抛出异常就结束程序，通常通过调用 abort 完成：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">DBConn::~DBConn()</span><br><span class="line">&#123;</span><br><span class="line">    try &#123;db.close();&#125;</span><br><span class="line">    catch (...)&#123;</span><br><span class="line">        制作运转记录，记下对 close 的调用失败</span><br><span class="line">        std::abort();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果程序遭遇一个“于析构期间发生的错误”后无法继续执行，”强迫结束程序“是个合理选项。毕竟它可以阻止异常从析构函数中传播出去（那会导致不明确的行为）。</p><ol><li>吞下因调用 close 而发生的异常</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DBConn::~DBConn()&#123;</span><br><span class="line">    try&#123;db.close();&#125;</span><br><span class="line">    catch(...)&#123;</span><br><span class="line">        制作运转记录，记下对 close 的调用失败</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般而言，将异常吞掉是个坏主意，因为它压制了“某些动作失败”的重要信息。然而有时候吞下异常也比负担“草率结束程序”或“不明确行为带来的风险”好。</p><p>这些办法都没有什么吸引力，问题在于两者都无法对“导致 close 抛出异常”的情况做法反应。</p><p>一个较佳策略是重新设计 DBConn 接口，使其客户有机会对可能出现的问题作出反映。例如 DBConn 自己可以提供一个 close 函数，因而赋予客户一个机会得以处理“因该操作而发生的异常”。DBConn 也可以追踪其所管理的 DBConnection 是否已经被关闭，并在答案为否的情况下由其析构函数关闭之。然而如果 DBConnction 析构函数调用 close 失败，我们又将退回到 “强迫程序结束”或“吞下异常”的老路。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">class DBCon &#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">    void close()&#123;        // 供客户使用的新函数</span><br><span class="line">        db.close();</span><br><span class="line">        closed = true;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ~DBCon()&#123;            // 关闭连接，如果客户不那么做的话</span><br><span class="line">        if(!closed)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                db.close();</span><br><span class="line">            &#125;</span><br><span class="line">            catch(...)&#123;</span><br><span class="line">                制作运转记录，记下对 close 的调用失败     // 如果关闭动作失败，记下并结束程序或吞下异常</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    DBConnection db;</span><br><span class="line">    bool closed;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果某个操作可能在失败时抛出异常，而又存在某种需要必须处理该异常，那么这个异常必须来自析构函数以外的某个函数。因为析构函数吐出异常就是危险，总会带来“过早结束程序”或“发生不明确行为”的风险。</p><p>在本例中，由客户自己调用 close 并不会给他们带来负担，而是给它们一个处理错误的机会，他们也可以忽略它们，依赖 DBConn 析构函数去调用 close。</p><h4 id="总结-3">总结</h4><p>析构函数绝对不要吐出异常。如果一个被析构函数调用的函数可能抛出异常，析构函数应该捕捉任何异常，然后吞下它们（不传播）或结束程序，</p><p>如果客户需要对某个操作函数运行期间抛出的异常做出反应，那么 class 应该提供一个普通函数（而非在析构函数中）执行该操作。</p><h3 id="条款09：绝不在构造和析构过程中调用-virtual-函数">条款09：绝不在构造和析构过程中调用 virtual 函数</h3><h4 id="9-1-构造函数中调用虚函数">9.1 构造函数中调用虚函数</h4><p>假设现有一个模拟股市交易如买进，卖出的订单等等，每当创建一个交易对象，需要在审计日志中创建一笔记录，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Transaction &#123;                                // 所有交易的 base class</span><br><span class="line">public:</span><br><span class="line">    Transaction();</span><br><span class="line">    virtual void logTransaction() const = 0 ;      // 做出一份因类型不同而不同的日志记录  </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transaction:: Transaction()&#123;</span><br><span class="line">    ...</span><br><span class="line">    logTransaction();                    // 最后动作是记录这笔交易</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BuyTransaction: public Transaction &#123;          // derived class</span><br><span class="line">public:</span><br><span class="line">    virtual void logTransaction() const;            // 标记此类型交易</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class SellTransaction: public Transaction &#123;          // derived class</span><br><span class="line">public:</span><br><span class="line">    virtual void logTransaction() const;            // 标记此类型交易</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在执行以下操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BuyTransaction b;</span><br></pre></td></tr></table></figure><p>首先肯定 base class 的构造函数先被执行，然后执行 derived class 构造函数。上述代码中在构造函数中调用了虚函数 logTransaction，虽然现在创建的是 BuyTransaction，但 base class 构造函数中调用的虚函数是 Transaction 的版本。</p><p>base class 构造期间 virtual 函数绝不会下降到 derived classes 阶层。在 base class 构造期间， virtual 函数不是 virtual 函数。</p><p>当 base class 构造函数执行时 derived class 的成员变量尚未初始化，如果此期间调用的 virtual 函数下降至 derived classes 阶层，要知道 derived classes 的函数几乎必然取用 local 成员变量，而那些变量尚未初始化。</p><p>在 derived class 对象的 base class 构造期间，对象的类型是 base class 而不是 derived class。</p><h4 id="9-2-析构函数中调用虚函数">9.2 析构函数中调用虚函数</h4><p>析构函数也是类似的。一旦 derived class 析构函数开始执行，对象内的 derived class 成员变量便呈现未定义值，所以 C++ 视它们彷佛不存在。进入 base class 析构函数后对象就成为一个 base class 对象</p><h4 id="9-3-隐藏问题">9.3 隐藏问题</h4><p>上述代码在构造函数中调用虚函数容易被编译器发现，如果写成以下代码，就容易通过编译器的检测，但同样存在一样的问题：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Transaction &#123;                                // 所有交易的 base class</span><br><span class="line">public:</span><br><span class="line">    Transaction ()&#123;</span><br><span class="line">        init();                                    // 调用 non-virtual</span><br><span class="line">    &#125;</span><br><span class="line">    virtual void logTransaction() const = 0;</span><br><span class="line">    ...</span><br><span class="line">private:</span><br><span class="line">    void init()&#123;</span><br><span class="line">        ...</span><br><span class="line">        logTransaction();                           // 这里调用 virtual</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码通常不会引发编译器和连接器异常，由于 logTransaction 是一个 pure virtual 函数，当 pure virtual 函数被调用，大多执行系统会中止程序。如果 logTransaction 是个正常的，它就会被调用。</p><p>确定构造函数和析构函数都没有调用 virtual 函数，而且它们调用的所有函数都服从同一约束。</p><h4 id="9-4-解决方法">9.4 解决方法</h4><p>在 class Transaction 内将 logTransaction 函数改为 non-virtual ，然后要求 derived class 构造函数传递必要信息给 Transaction 构造函数，而后那个构造函数便可以安全地调用 non-virtual logTransaction。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Transaction &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit Transaction(const std::string&amp; logInfo);</span><br><span class="line">    void logTransaction(const std::string&amp; );     // 现在是个 non-virtual 函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Transaction::Transaction(const std::string&amp; logInfo)&#123;</span><br><span class="line">    ...</span><br><span class="line">    logTransaction(logInfo);                     // 如今是个 non-virtual 调用</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class BuyTransaction: public Transaction &#123;          // derived class</span><br><span class="line">public:</span><br><span class="line">    BuyTransaction(parameters):Transaction(createLogString(parameters))</span><br><span class="line">    &#123; ... &#125;                         // 将 log 信息传给 base class 构造函数</span><br><span class="line">    ...</span><br><span class="line">private:</span><br><span class="line">    static std::string createLogString(parameters);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>createLogString 作为一个静态函数，就不可能意外指向 “初期未成熟之 BuyTransaction 对象内尚未初始化的成员变量。”</p><p>换句话话说，不能使用 virtual 函数从 base classes 向下调用，在构造期间，可以“令 derived classes 将必要的构造信息向上传递至 base class 构造函数” 替换而加以弥补。</p><h4 id="9-5-总结">9.5 总结</h4><p>在构造和析构期间不要调用 virtual 函数，因为这类调用从不下降至 derived class。</p><h3 id="条款-10：令-operator-返回一个-reference-to-this">条款 10：令 operator= 返回一个 reference to *this</h3><p>关于赋值，可以将它们写成连锁形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int x,y,z;</span><br><span class="line">x = y = z = 15;         // 赋值连锁形式</span><br></pre></td></tr></table></figure><p>有趣的是，赋值采用右结合律，所以上述赋值被解析为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = (y = (z = 15));</span><br></pre></td></tr></table></figure><p>为了实现“连锁赋值”，赋值操作符必须返回一个 reference 指向操作符的左侧实参。这是为 classes 实现赋值操作符时应该遵循的协议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">    Widget&amp; operator=(const Widget&amp; rhs)&#123;        // 返回类型是个 reference，指向当前对象</span><br><span class="line">        ... </span><br><span class="line">        return *this;                            // 指向左侧对象</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个协议不仅适用于以上的标准赋值形式，也适用于所有赋值相关运算，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Widget&#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">    Widget&amp; operator+=(const Widget&amp; rhs)&#123;    // 这个协议适用于 += -= *= 等等</span><br><span class="line">        ...</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    Widget&amp; operator=(int rhs)&#123;              // 此函数也适用于，即使此一操作符的参数类型不符合协定</span><br><span class="line">        ...</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这只是协议，并无强制性。这份协议被所有的内置类型和标准程序库提供的类型如 string, vector, complex, std::shared_ptr 共同遵守。</p><h4 id="总结-4">总结</h4><p>令赋值（assignment） 操作符返回一个 reference to *this。</p><h3 id="条款-11：在-operator-中处理-“自我赋值”">条款 11：在 operator= 中处理 “自我赋值”</h3><p>“自我赋值”发生在对象被赋值给自己时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123; ... &#125;;</span><br><span class="line">Widget w;</span><br><span class="line">...</span><br><span class="line">w = w;</span><br></pre></td></tr></table></figure><p>有些自我赋值并不容易被发现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a[i] = a[j];           // 潜在的自我赋值，如果 i 和 j 有相同的值</span><br><span class="line">*px = *py;             // 潜在的自我赋值，如果 px 和 py 恰巧指向同一个东西</span><br></pre></td></tr></table></figure><p>实际上两个对象只要来自同一个继承体系，它们甚至不需要声明为相同类型就可能造成 “别名”，因为一个 base class 的 reference 或 pointer 可以指向一个 derived class 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;&#125;;</span><br><span class="line">class Derived:public Base &#123; ... &#125;;</span><br><span class="line">void doSomething(const Base&amp; rb, Derived* pd);  // rb 和 *pd 有可能其实是同一对象</span><br></pre></td></tr></table></figure><p>如果尝试写一个资源管理的 class 就得时刻注意 “自我赋值”问题，防止在停止使用资源之前就意外释放了它。</p><p>假设现在需要建立一个 class 用来保存一个指针指向一块动态分配的位图(bitmap)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Bitmap &#123; ... &#125;;</span><br><span class="line">class Widget &#123;</span><br><span class="line">    ...</span><br><span class="line">private:</span><br><span class="line">    Bitmap *pb;           // 指针，指向一个从 heap 分配而得到的对象</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面的 operator= 实现代码，表面上看起来合理，但自我赋值出现时并不安全。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp;</span><br><span class="line">Widget::operator=(const Widget&amp; rhs)      // 一份不安全的 operator= 实现版本</span><br><span class="line">&#123;</span><br><span class="line">    delete pb;            // 停止使用当前的 bitmap</span><br><span class="line">    pb = new Bitmap(*rhs.pb); // 使用 rhs&#x27;s bitmap 副本</span><br><span class="line">    return *this;          </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码存在的问题是：operator= 函数内的 *this 和 rhs 有可能是同一个对象。如果真是这样，delete 就不只是销毁当前对象的 bitmap，它也销毁 rhs 的 bitmap。最后返回的 this 指针就可能指向一个已经删除的对象。</p><h4 id="11-1-解决方案">11.1 解决方案</h4><p>欲阻止这种错误，传统的做法是在 operator= 最前面设置一个 “证同测试”达到 “自我赋值”的检验目的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123;</span><br><span class="line">    if(this == &amp;rhs) return *this;      // 证同测试，如果是自我赋值就不做任何事</span><br><span class="line">    </span><br><span class="line">    delete pb;</span><br><span class="line">    pb = new Bitmap(*rhs.pb);</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码行得通，但不具备 “异常安全性”。如果 “new Bitmap” 导致异常（无论是分配时内存不足或因为 Bitmap 的 copy 构造函数抛出异常），Widget 最终会持有一个指针指向一块被删除的 Bitmap，这样的指针有害。</p><p>令人高兴的是，让 operator= 具备 “异常安全性” 往往自动获得 “自我赋值安全”的回报。因此越来越多人倾向于不去管它，把焦点放在实现 “异常安全性”(exception safety)上。</p><p>许多时候一群精心安排的语句就可以导出异常安全（以及自我赋值安全）的代码，这就够了。例如以下代码：我们只需注意在复制 pb 所指东西之前别删除 pb。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123;</span><br><span class="line">    Bitmap* pOrig = pb;        // 记住原先的 pb</span><br><span class="line">    pb = new Bitmap(*rhs.pb);  // 令 pb 指向一个副本</span><br><span class="line">    delete pOrig;              // 删除原先的 pb</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，如果 “new Bitmap” 抛出异常，pb（及其栖身的那个 Widget）保持原状。</p><p>你也可以把 “证同测试”再次放回函数起始处，然而这样做之前先问问自己，这样的“自我赋值”的发生频率有多高，因为这项测试也需要成本，它会使代码变大，并导入一个新的控制流分支，两者都会降低执行速度。</p><h4 id="11-2-copy-and-swap">11.2 copy and swap</h4><p>上述解决方案的一个替代方案称为 copy and swap 技术，这个技术和 “异常安全性”有密切关系。这也是一个常见而够好的 operator= 编写办法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">...</span><br><span class="line">void swap(Widget&amp; rhs);             // 交换 *this 和 rhs 的数据</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Widget&amp; Widget::operator=(const Widget&amp; rhs)&#123;</span><br><span class="line">    Widget temp(rhs);             // 为 rhs 数据制作一份复件</span><br><span class="line">    swap(temp);                    // 将 *this 数据和上述复件数据交换</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个主题的另一个变奏曲利用了以下事实：</p><ol><li>某 class 的 copy assignment 操作符可能被声明为 “以 by value 方式接受实参”</li><li>以 by value 方式传递东西会造成一份复件</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; Widget::operator=(Widget rhs)     // rhs 是被传对象的一份复件</span><br><span class="line">&#123;</span><br><span class="line">    swap(rhs);</span><br><span class="line">    return *this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码牺牲了清晰性，然而将 “copying 动作” 从函数本体移至 “函数参数构造阶段” 却可令编译器有时生成更高效的代码。</p><h4 id="11-3-总结">11.3 总结</h4><ul><li>确保当对象自我赋值时 operator= 有良好行为。其中技术包括：比较“来源对象”和“目标对象”的地址，精心周到的语句顺序，以及 copy-and-swap</li><li>确定任何函数如果操作一个以上的对象，而其中多个对象是同一对象时，其行为仍然正确。</li></ul><h3 id="条款-12：复制对象时勿忘其每一个成分">条款 12：复制对象时勿忘其每一个成分</h3><p>如果你为 class 添加一个成员变量，就必须同时修改 copying 函数（包括 拷贝构造函数和 copy assignment 运算符）。你也需要修改 class 的所有构造函数以及任何非标准形式的 operator= 。如果你忘记了，编译器不太可能提醒你。</p><p>一旦发生继承，可能会造成更大的危机。因为大部分人的 copying 函数（包括 拷贝构造函数和 copy assignment 运算符）可能会忽略 base class 的成员。</p><p>任何时候只要你承担起 “为 derived class 编写 copying 函数”的重大责任，必须很小心地复制其 base class 成分。那些成分往往是 private ，所以你无法直接访问它们，应该让derived class 的 copying 函数调用相应的 base class 函数。</p><p>本条款题目所说的“复制每一个成分”应该很清楚了。当编写一个 copying 函数，请确保：</p><ol><li>复制所有 local 成员变量。</li><li>调用所有 base classes 内的适当 copying 函数。</li></ol><p>copy 构造函数和 copy assignment 运算符有着相同的实现本体，这有可能诱使你让某个函数调用另一个函数以避免代码重复。记住：让某个 copying 函数调用另一个 copying 函数无法让你达到想要的目标。</p><p>当你发现 copy 构造函数和 copy assignment  操作符有着相似的代码，消除代码重复的做法是，建立一个新的成员函数给两者调用，这样的函数往往是 private 而且常被命名为 init。</p><h4 id="总结-5">总结</h4><p>Copying 函数应该确保复制“对象内的所有成员变量”及“所有 base class 成分”。</p><p>不要尝试以某个 copying 函数实现另一个 copying 函数，应该将它们的共同成分放进第三个函数中，并由两个 copying 函数共同调用。</p><h2 id="三、资源管理">三、资源管理</h2><p>所谓资源就是，一旦用了它，将来必须还给系统。C++ 程序中最常使用的资源就是动态分配内存。但是内存只是你必须管理的众多资源之一，其他常见的资源还包括文件描述符(file descriptors)，互斥锁(mutex locks)，图形界面中的字型和笔刷，数据库连接，以及网络 sockets。无论哪种资源，当你不再使用它时，就必须归还给系统。</p><h3 id="条款-13：以对象管理资源">条款 13：以对象管理资源</h3><ul><li>获得资源后立刻放进管理对象内。实际上，“以对象管理资源”的观念常被称为“资源获取即初始化”（RAII）。获得一笔资源后于同一语句内以它初始化某个管理对象，有时候获得的资源被拿来赋值某个对象。无论何种做法，每一笔资源都在获得的同时立刻被放进管理对象中。</li><li>管理对象运用析构函数确保资源被释放。不论控制流如何离开区块，一旦对象被销毁其析构函数自然会被自动调用，于是资源被释放。资源的释放动作可能发生异常，不过条款 8 已经能够解决这个问题。</li></ul><h4 id="13-1-auto-ptr">13.1 auto_ptr</h4><p>auto_ptr 在 C++ 11 中已经被弃用，被 std::unique_ptr 取代 ，后者具有类似功能的新设施，具有改进的安全性</p><p>许多动态资源被动态分配于 heap 内而后被用于单一区块或函数内，它们应该在控制流离开那个区块或函数时被释放。标准库提供的 auto_ptr 正是这种情形下的产物。</p><p>auto_ptr 被称为智能指针，其析构函数自动对其所指对象调用 delete。它的使用方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Investment &#123; ... &#125;;</span><br><span class="line">// 作为工厂函数，返回指针，指向 Investment 继承体系内的动态分配对象，调用者有责任删除它</span><br><span class="line">Investment* createInvestment();</span><br><span class="line"></span><br><span class="line">void f()&#123;</span><br><span class="line">    std::auto_ptr&lt;Investment&gt; pInv(createInvestment()); </span><br><span class="line">    // 调用 factory 函数</span><br><span class="line">    // 一如以往地使用 pInv</span><br><span class="line">    // 经由 auto_ptr 的析构函数自动删除 pInv                                                      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>auto_ptr 被销毁时自动删除它所指之物，别让多个 auto_ptr 同时指向同一对象。为了预防这个问题，auto_ptr 具有不寻常的性质，如果通过 copy 构造函数或 copy assignment 操作符 复制它们，它们就会变成 null，而复制所得的指针将取得资源的唯一拥有权。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::auto_ptr&lt;Investment&gt; pInv1(createInvestment());    //pInv1 指向 createInvestment 返回物</span><br><span class="line">std::auto_ptr&lt;Investment&gt; pInv2(pInv1); // 现在 pInv2 指向对象，pInv1 被设未 null</span><br><span class="line">ppInv1 = pInv2;   // 现在 pInv1 指向对象，pInv2 被设为 null               </span><br></pre></td></tr></table></figure><h4 id="13-2-shared-ptr">13.2 shared_ptr</h4><p>auto_ptr 的替代方案是 “引用计数型智能指针”（RCSP），一个 shared_ptr 对象会跟踪共有多少对象指向某笔资源，并在无人指向它时自动删除该资源。</p><p>RCSP 有点类似于垃圾回收，但它无法打破环状引用，例如两个其实已经没被使用的对象彼此互指，因而好像还处于“被使用”状态。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void f()&#123;</span><br><span class="line">    std::shared_ptr&lt;Investment&gt; pInv(createInvestment()); </span><br><span class="line">    // 调用 factory 函数</span><br><span class="line">    // 一如以往地使用 pInv</span><br><span class="line">    // 经由 shared_ptr 的析构函数自动删除 pInv                                                      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下代码和 auto_ptr 的版本相同，但复制行为正常多了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void f()&#123;</span><br><span class="line">    std::shared_ptr&lt;Investment&gt; pInv1(createInvestment());    //pInv1 指向 createInvestment 返回物</span><br><span class="line">    std::shared_ptr&lt;Investment&gt; pInv2(pInv1); // 现在 pInv2 和 pInv1 指向同一对象</span><br><span class="line">    ppInv1 = pInv2;   // 同上，无任何改变</span><br><span class="line">    ...</span><br><span class="line">&#125;   // pInv1 和 pInv2 被销毁，它们所指的对象就会iu被自动销毁</span><br></pre></td></tr></table></figure><p>由于 shared_ptr 正常的复制行为，它们可被用于 STL 容器等。本条款并不针对 auto_ptr ，shared_ptr，只是强调 “以对象管理资源的重要性”</p><h4 id="13-3-动态数组">13.3 动态数组</h4><p>auto_ptr 和 std::shared_ptr 都在其析构函数内做 delete 而不是 delete[] 动作。意味着不能在动态分配而得到的 array 身上使用 auto_ptr 或 std::shared_ptr。可叹的是，它们仍能够通过编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::auto_ptr&lt;std::string&gt; aps(new std::string[10]);  // 搜主意，会用上错误的 delete 形式</span><br><span class="line">std::shared_ptr&lt;int&gt;spi(new int[1024]);        // 相同问题</span><br></pre></td></tr></table></figure><p>你会惊讶的发现，C++ 并没有针对“动态分配数组”而设计的类似 auto_ptr 或 std::shared_ptr。因为 vector 和 string 几乎可以取代动态分配而得到的数组。</p><p>如果你觉得拥有针对数组而设计的，类似 auto_ptr 和 std::shared_ptr 那样 classes 较好。那就看看 Boost 吧，boost::scoped_array 和 boost::shared_array classes 提供了你想要的行为。</p><p>使用手工释放资源，例如使用 delete 而不是一个资源管理类，容易发生某些错误。</p><p>有时候需要自己实现资源管理类，就需要你精巧地制作你自己的资源管理类。</p><h4 id="13-4-总结">13.4 总结</h4><ul><li>为防止资源泄漏，请使用 RAII 对象，它们在构造函数中获得资源并在析构函数中释放资源。</li><li>两个常被使用的 RAII classes 分别是 std::shared_ptr 和 auto_ptr。前者通常是较佳选择，因为其 copy 行为比较直观。若选择 auto_ptr，复制动作会使它指向 null。</li></ul><h3 id="条款14：在资源管理类中小心-coping-行为">条款14：在资源管理类中小心 coping 行为</h3><p>类似 auto_ptr 和 std::shared_ptr 比较适合位于 heap 内存的资源。除此以外的其他资源，可能需要建立自己的资源管理类。</p><h4 id="14-1-互斥锁">14.1 互斥锁</h4><p>假设现在使用 C API 函数处理类型为 Mutex 的互斥锁对象，共有 lock 和 unlock 两个函数可用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void lock(Mutex* pm);             // 锁定临界区</span><br><span class="line">void unlock(Mutex* pm);           // 解锁临界区</span><br></pre></td></tr></table></figure><p>为了确保不会忘记将一个临界区解锁，可以建立一个 class 来管理锁。这样的 class 的基本结构由 RAII 守则支配，业就是“资源在构造期间获得，在析构期间释放”：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Lock&#123;</span><br><span class="line">public:</span><br><span class="line">    explicit Lock(Mutex* pm):mutexPtr(pm)</span><br><span class="line">    &#123;lock(mutexPtr);&#125;          // 获得资源</span><br><span class="line">    </span><br><span class="line">    ~Lock() &#123; unlock(mutexPtr); &#125;  // 释放资源</span><br><span class="line">private:</span><br><span class="line">    Mutex *mutexPtr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用户对 Lock 的用法符合 RAII 方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Mutex m;         // 定义你需要的互斥锁</span><br><span class="line">...</span><br><span class="line">&#123;              // 建立一个区块用来定义 critical section(临界区)</span><br><span class="line">    Lock ml(&amp;m);    // 锁定临界区</span><br><span class="line">    ...             // 执行 critical section 内的操作</span><br><span class="line">        </span><br><span class="line">&#125;                  // 在区块末尾，自动解锁临界区</span><br></pre></td></tr></table></figure><h4 id="14-2-Coping-行为">14.2 Coping 行为</h4><p>上面工作的很好，但如果 Lock 对象被复制，会发生什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lock ml1(&amp;m);                 // 锁定 m</span><br><span class="line">Lock ml2(ml1);                // 将 ml1 复制到 ml2 身上，这会发生什么？</span><br></pre></td></tr></table></figure><p>这是某个一般化问题的特殊例子。这个一般化问题是每一位 RAII class 作者一定需要面对的，当一个 RAII 对象被复制，大多数情况有以下两种选项：</p><ul><li>禁止复制：许多时候允许 RAII 对象被复制并不合理。比如像 Lock 这样的 class，因为很少能够合理拥有 “同步化基础器物”的复件。</li></ul><p>如果复制动作对 RAII class 并不合理，就应该禁止它，条款 6 说了怎么做，将 copying 操作声明为 private，对 Lock 而言看起来这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Lock: private Uncopyable &#123;           // 禁止复制</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>对底层资源采用 “引用计数法”：有时希望保有资源，直到它的最后一个使用者被销毁。这种情况下复制 RAII 对象时，应该将资源的“被引用数”递增。类似于 std::shared_ptr</li></ul><p>通常只要内含一个 std::shared_ptr 成员变量，RAII classes 便可以实现 reference-counting copying 行为。将前述 Lock 改为使用 reference counting，它可以改变 mutexPtr 的类型，将它从 Mutex* 改为 std::shared_ptr<Mutex>，</p><p>可惜它的缺省行为是“当引用计数为 0 时删除其所指物”，那不是我们所要的行为，对于 Mutex，我们想要的释放动作是解除锁定而非删除。</p><p>幸运的是 std::shared_ptr 允许指定所谓的 “删除器”(deleter)，那是一个函数或函数对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Lock&#123;</span><br><span class="line">public:</span><br><span class="line">    explicit Lock(Mutex* pm):mutexPtr(pm,unlock) // 以某个 Mutex 初始化 shared_ptr，并以 unlock 函数为删除器</span><br><span class="line">    &#123;</span><br><span class="line">        lock(mutexPtr.get());    // 条款 15 谈到 “get”</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    std::shared_ptr&lt;Mutex&gt; mutexPtr;  // 使用 shared_ptr 替换 raw pointer</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意，本例中不再声明析构函数，因为没有必要。条款 5 说过，class 析构函数（无论是编译器生成的，或用户定义的）会自动调用其 non-static 成员变量的析构函数，对于上述例子而言，就是调用我们指定的删除器 unlock。</p><ul><li>复制底部资源</li></ul><p>只要你喜欢，可以针对一份资源拥有其任意数量的复件。而你需要“资源管理类”的唯一理由是，当你不再需要某个附件时确保它被释放。在这种情况下复制资源管理对象，应该同时也复制其所管理的资源。</p><p>例如，某些标准字符串类型是由“指向 heap 内存”的指针构成（那内存被用来存放字符串的组成字符）。这种字符串对象内含一个指针指向一块 heap 内存。当这样一个字符串对象被复制，不论指针或其所指内存都会被制作出一个复件。这样的字符串展现深度复制行为，即深拷贝。</p><ul><li>转移底部资源的拥有权</li></ul><p>某些罕见场合下可能希望永远只有一个 RAII 对象指向一个未加工资源，即使 RAII 对象被复制依然如此。此时资源的拥有权会从被复制物转移到目标物，这点类似于 auto_ptr 奉行的复制意义。</p><h4 id="14-3-总结">14.3 总结</h4><ul><li>复制 RAII 对象必须一并复制它所管理的资源，所以资源的 copying 行为决定 RAII 对象的 copying 行为。</li><li>普遍而常见的 RAII class copying 行为是：抑制 copying，采用引用计数法。不过其他行为也可能被实现。</li></ul><h3 id="条款-15：在资源管理类中提供对原始资源的访问">条款 15：在资源管理类中提供对原始资源的访问</h3><p>资源管理类保证资源的正确释放，避免了资源泄漏。许多 APIs 需要直接使用资源，因此一个资源管理类也应该提供访问原始资源的方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Investment&gt;pInv(createInvestment()); </span><br><span class="line">int daysHeld(const Investment* pi);        // 返回投资天数</span><br></pre></td></tr></table></figure><p>当这样调用的时候：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int days = daysHeld(pInv);          // 错误</span><br></pre></td></tr></table></figure><p>这样调用是错误的，因为 daysHeld 需要的是指针，但传给它的是 std::shared_ptr<Investment> 对象 。这时候需要一个函数可将 RAII class 对象转换为其所含之原始资源。有两个办法可以达成目标：显式转换和隐式转换</p><p>std::shared_ptr 和 auto_ptr 都提供一个 get 成员函数，用来执行显式类型转换，也就是它会返回智能指针内部的原始指针。</p><p>几乎所有的智能指针，包括 std::shared_ptr 和 auto_ptr 也重载了指针取值操作符（operator-&gt; 和 operator*）,它们允许隐式转换至底部原始指针。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Investment&#123;</span><br><span class="line">public:</span><br><span class="line">    bool isTaxFree() const;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Investment* createInvestment();      // factory 函数</span><br><span class="line">std::shared_ptr&lt;Investment&gt;pi1(createInvestment());</span><br><span class="line">bool taxable1 = !(pi1-&gt;isTaxFree());    // 经由 operator-&gt; 访问资源</span><br><span class="line">bool taxable2 = !((*pi1).isTaxFree());  // 经由 operator* 访问资源</span><br></pre></td></tr></table></figure><p>下面是用于字体的 RAII class</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">FontHandle getFont();</span><br><span class="line">void releaseFont(FontHandle fh);   // C API   </span><br><span class="line">  </span><br><span class="line">class Font&#123;          // RAII class</span><br><span class="line">public:</span><br><span class="line">    explicit Font(FontHandle fh):f(fh)&#123;&#125;    // 获得资源 采用 pass-by-value</span><br><span class="line">    ~Font() &#123; releaseFont(f);&#125;              // 释放资源</span><br><span class="line">private:</span><br><span class="line">    FontHandle f;                           // 原始资源</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="15-1-显式类型转换">15.1 显式类型转换</h4><p>假设有大量与字体相关的 C API，它们处理 FontHandles，那么“将 Font 对象转换为 FontHandle ”会是很频繁的需求。Font class 可为此提供一个显式转换函数，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Font&#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">    FontHandle get() const &#123; return f;&#125;;    // 显式转换函数</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用这个方法，需要 FontHandle 的每个地方都需要调用 get 函数。</p><h4 id="15-2-隐式类型转换">15.2 隐式类型转换</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Font&#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">    operator FontHandle() const       // 隐式转换函数</span><br><span class="line">    &#123;return f;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样当客户需要使用原始资源的时候就比较轻松自然：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Font f(getFont());</span><br><span class="line">int newFontSize;</span><br><span class="line">...</span><br><span class="line">changeFontSize(f,newFontSize);          // 将 Font 隐式转换为 FontHandle</span><br></pre></td></tr></table></figure><p>上述隐式转换会增加犯错误的机会。例如客户可能会在需要 Font 时意外创建一个 FontHandle：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Font f1(getFont());</span><br><span class="line">...</span><br><span class="line">FontHandle f2 = f1;          // 原义要拷贝一个 Font 对象，却反而将 f1 隐式转换为 FontHandle 然后才复制它</span><br></pre></td></tr></table></figure><p>选择隐式类型转换还是显式类型转换取决于 RAII class 被设计执行的特定工作。</p><p>通常显式转换函数如 get 是比较受欢迎的路子，因为它将“非故意之类型转换”的可能性最小化了。</p><h4 id="15-3-总结">15.3 总结</h4><ul><li>APIs 往往需要访问原始资源，所以每一个 RAII class 应该提供一个“取得其管理之资源”的办法。</li><li>对原始资源的访问可能经由显式转换或隐式转换。一般而言显式转换比较安全，但隐式转换对客户比较方便。</li></ul><h3 id="条款-16：成对使用-new-和-delete-时要采取相同形式">条款 16：成对使用 new 和 delete 时要采取相同形式</h3><p>考虑以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::string* stringArray = new std::string[100];</span><br><span class="line">...</span><br><span class="line">delete stringArray;</span><br></pre></td></tr></table></figure><p>看似井然有序，使用了 new，也搭配了对应的 delete。但还是有某样东西完全错误，该程序行为不明确。当使用 delete 回收内存的时候应该指明是回收单一对象，还是一个动态数组。</p><p>单一对象和对象数组的结构不完全一样，因为对象数组相比单一对象，其内存布局还包括“数组大小的记录”。</p><p>如果 new 和 delete 没有采用相同的形式，会造成以下未定义行为：</p><ul><li>new 对象，delete 对象数组：delete 可能会读取若干内存并将其解释为“数组大小”。</li><li>new 对象数组，delete 对象：结果亦未定义，可能导致更少的析构函数被调用。</li></ul><h4 id="16-1-typedef">16.1 typedef</h4><p>对于喜欢 typedef 的人更应该注意，当程序员以 new 创建该种 typedef 类型对象时，该以哪一种 delete 形式删除之。考虑下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typedef std::string AddressLines[4];     </span><br><span class="line">std::string* pal = new AddressLines;     // 该语句就像使用 new string[4] 一样</span><br></pre></td></tr></table></figure><p>必须匹配“数组形式”的delete：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">delete pal;           // 行为未定义</span><br><span class="line">delete []pal;         // 正确</span><br></pre></td></tr></table></figure><p>为避免类似错误，最好不要对数组形式做 typedef 动作。标准库提供了 string，vector 等 templates，可将数组的需求降至几乎为零。例如本例中 AddressLines 可定义为 “由 strings 组成的一个 vector”，也就是类型 vector<string></p><h4 id="16-2-总结">16.2 总结</h4><p>如果在 new 表达时中使用 []，必须在相应的 delete 表达式也使用[] 。如果没有在 new 表达式不使用 []，一定不要在相应的 delete 表达式中使用 []。</p><h3 id="条款17：以独立语句将-newed-对象置入智能指针">条款17：以独立语句将 newed 对象置入智能指针</h3><h4 id="17-1-资源泄漏问题">17.1 资源泄漏问题</h4><p>假设有以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int priority();</span><br><span class="line">void processWidget(std::shared_ptr&lt;Widget&gt; pw, int priority);</span><br></pre></td></tr></table></figure><p>现在考虑调用 processWidget：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processWidget(new Widget, priority());</span><br></pre></td></tr></table></figure><p>上面对 processWidget  的调用是错误的，它甚至不能通过编译，std::shared_ptr 构造函数需要一个原始指针，但该构造函数是个 explicit 构造函数，无法进行隐式转换。如果写成以下这样就可以通过编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">processWidget(std::shared_ptr&lt;Widget&gt;(new Widget),priority());</span><br></pre></td></tr></table></figure><p>表面上看没有问题，但其实上述调用可能泄漏资源。</p><p>编译器产出一个 processWidget 调用码之前，必须先首先核算即将被传递的各个实参：</p><p>第一实参 std::shared_ptr<Widget>(new Widget) 由两部分组成</p><ul><li>执行 “new Widget” 表达式</li><li>调用 std::shared_ptr 构造函数</li></ul><p>于是在调用 processWidget 之前，编译器必须创建代码，做以下三件事：</p><ul><li>调用 priority</li><li>执行 “new Widget”</li><li>调用 std::shared_ptr 构造函数</li></ul><p>C++ 编译器以什么次序完成这些事情呢？弹性很大。这和其他语言如 Java 和 C# 不同，那两种语言总是以特定次序完成函数参数的核算。可以确定的是 “new Widget” 一定执行于 std::shared_ptr 构造函数之前，但对 priority 的调用则可以排在第一或第二或第三执行。其中可能的执行次序如下：</p><ol><li>执行 “new Widget”</li><li>调用 priority</li><li>调用 std::shared_ptr 构造函数</li></ol><p>现在想想，万一对 priority 的调用导致异常，会发生什么？在这种情况下  “new Widget” 返回的指针将会遗失，因为它未被置入 std::shared_ptr  内。所以在对 processWidget 的调用过程，可能引发资源泄漏。因为在“资源创建”和“资源被转换为资源管理对象”两个时间点之间可能发出异常干扰。</p><h4 id="17-2-解决办法">17.2 解决办法</h4><p>使用分离语句，分别写出 （1）创建 Widge （2）将它置入一个智能指针，然后再把那个智能指针传给 ProcessWidget：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Widget&gt;pw(new Widget);  // 在单独对象内以智能指针存储 newed 所得对象</span><br><span class="line">processWidget(pw, priority());         // 这个调用动作绝不至于造成泄漏</span><br></pre></td></tr></table></figure><p>编译器对于“跨越语句的各项操作”没有重新排列的自由（只有在语句内它才拥有那个自由度）</p><h4 id="17-3-总结">17.3 总结</h4><p>以独立语句将 newed 对象存储于智能指针内。如果不这样做，一旦异常被抛出，有可能导致难以察觉的资源泄漏。</p><h2 id="四、设计与声明">四、设计与声明</h2><p>所谓软件设计，是“令软件做出你希望它做的事情”的步骤和做法，通常以颇为一般性的构想开始，最终演变成十足的细节，以允许特殊接口的开发。这些接口而后必须转换为 C++ 声明式。</p><h3 id="条款18：让接口容易被正确使用，不易被误用">条款18：让接口容易被正确使用，不易被误用</h3><h4 id="18-1-接口误用">18.1 接口误用</h4><p>C++ 的接口类型主要有以下几种：function 接口，class 接口，template 接口。你设计的接口应该容易被正确使用，如果客户对你所提供的接口的用法错误，你至少也得负一部分责任。</p><p>假设有以下接口：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Date &#123;</span><br><span class="line">public:</span><br><span class="line">    Date(int month, int day, int year);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>看似挺合理，但客户很容易犯以下错误：</p><ol><li>他们可能以错误的次序传递参数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date d(30 , 3, 1995);   // 应该是 &quot;3,30&quot; 而不是 &quot;30, 3&quot;  </span><br></pre></td></tr></table></figure><ol><li>他们可能传递一个无效的月份或天数</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Date d(2, 31, 2022);    // 应该是 &quot;3,31&quot; 而不是 “2，31”    </span><br></pre></td></tr></table></figure><h4 id="18-2-解决方法">18.2 解决方法</h4><p>许多错误可以通过导入新类型而获得预防，对于上述问题我们可以通过导入简单的外覆类型（wrapper types） 来区别天数，月份和年份，然后于 Date 构造函数中使用这些类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">struct Day&#123;</span><br><span class="line">explicit Day(int d):val(d)&#123;&#125;</span><br><span class="line">int val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Month&#123;</span><br><span class="line">explicit Month(int m):val(m)&#123;&#125;</span><br><span class="line">int val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct Year&#123;</span><br><span class="line">explicit Year(int y):val(y)&#123;&#125;</span><br><span class="line">int val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Date&#123;</span><br><span class="line">public:</span><br><span class="line">    Date(const Month&amp; m, const Day&amp; d, const Year&amp; y);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Date d(30, 3. 1995);                          // 错误，不正确类型</span><br><span class="line">Date d(Day(30), Month(3), Year(1995));        // 错误，不正确类型</span><br><span class="line">Date d(Month(3), Day(30), Year(1995));        // 正确</span><br></pre></td></tr></table></figure><p>当正确的类型就位，限制其值有时候也是合理的。例如一年只有 12 个有效月份，比较安全的解法就是预先定义所有有效的 Months：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Month&#123;</span><br><span class="line">public:</span><br><span class="line">    static Month Jan() &#123; return Month(1); &#125;</span><br><span class="line">    static Month Feb() &#123; return Month(2); &#125;</span><br><span class="line">    ...</span><br><span class="line">    static Month Dec() &#123; return Month(12); &#125;</span><br><span class="line">    ...</span><br><span class="line">private:</span><br><span class="line">    explicit Month(int m);            // 阻止生成新的月份，这是月份专属数据</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">Date d(Month::Jan(), Day(31), Year(2022));</span><br></pre></td></tr></table></figure><h4 id="18-3-资源泄漏">18.3 资源泄漏</h4><p>观察以下 factor 函数，它返回一个指针指向 Investment 继承体系内的一个动态分配对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Investment* createInvestment();</span><br></pre></td></tr></table></figure><p>上述代码给了用户两次犯错误的机会：</p><ol><li>没有删除指针</li><li>删除同一个指针超过一次</li></ol><p>较佳的接口如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;Investment&gt; createInvestment();</span><br></pre></td></tr></table></figure><p>这边强迫客户将返回值存储于一个 std::shared_ptr 内，几乎消除了忘记删除底部 Investment 对象的可能性。</p><h4 id="18-4-总结">18.4 总结</h4><ul><li>好的接口很容易被正确使用，不容易被误用。</li><li>“促进正确使用”的办法包括接口的一致性，以及与内置类型的行为兼容。</li><li>“阻止误用”的办法包括建立新类型，限制类型上的操作，束缚对象值，以及消除客户的资源管理责任。</li><li>std::shared_ptr 支持定制删除器，这可防止 DLL 问题，可被用来解除互斥锁。</li></ul><h3 id="条款-19：设计-class-犹如设计-type">条款 19：设计 class 犹如设计 type</h3><p>几乎每一个 class 都要求你面对以下提问：</p><ul><li>新 type 的对象应该如何被创建和销毁？：这会影响构造函数，析构函数，内存分配函数和释放函数的设计。</li><li>对象的初始化和对象的赋值该有什么样的差别？：这会影响构造函数和 赋值（assignment）操作符的行为。</li><li>新 type 如果被 passed by value （以值传递），意味着什么？：copy 构造函数用来定义一个 type 的 pass-by-value 该如何实现。</li><li>什么是新 type 的 “合法值”？</li><li>你的新 type 需要配合某个继承图系吗？ 如果新 type 继承自某些既有 classes，就会受到那些 classes 的设计的束缚，特别是受到 “它们的函数是 virtual 或 non-virtual ”的影响。如果你允许其他 classes 继承你的 class，那会影响你所声明的函数，由其是析构函数。</li><li>你的新 type 需要什么样的转换？</li><li>什么样的操作符和函数对此新 type 而言是合理的？</li><li>什么样的标准函数应该驳回？   将需驳回函数声明为 private</li><li>谁该取用新 type 的成员？也就是成员变量的权限控制</li><li>什么是新 type 的“未声明接口”？它对效率，异常安全性，以及资源运用提供何种保证？你在这方面提供的保证将为你的 class 实现代码加上相应的约束条件。</li><li>新 type 有多么一般化？ 考虑使用 class template</li><li>你真的需要一个新的 type 吗？可能定义一个或多个 non-member 函数或 templates 更能达到目标。</li></ul><h4 id="总结-6">总结</h4><p>Class 的设计就像 type 的设计。在定义一个新 type 之前，请确定已经考虑过本条款覆盖的所有讨论主题。</p><h3 id="条款20：宁以-pass-by-reference-to-const-替换-pass-by-value">条款20：宁以 pass-by-reference-to-const 替换 pass-by-value</h3><h4 id="20-1-对象切割问题">20.1 对象切割问题</h4><p>当一个 derived class 对象以 by value 方式传递并被视为一个 base class 对象，base class 的 copy 构造函数会被调用，而“造成此对象像个 derived class 对象”的那些特质化性质全部被切割调了，仅仅留下一个 base class 对象。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void printNameAndDisplay(Window w)&#123;       // 不正确，参数可能被切割</span><br><span class="line">    std::cout&lt;&lt;w.name();</span><br><span class="line">    w.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解决对象切割问题的办法，就是以 by reference-to-const 的方式传递 w</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void printNameAndDisplay(const Window&amp; w)&#123;       // 很好，参数不会被切割</span><br><span class="line">    std::cout&lt;&lt;w.name();</span><br><span class="line">    w.display();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在传进来什么类型，w 就表现出那种类型。</p><p>一般而言，可以合理假设 &quot;pass-by-value 并不昂贵&quot;的唯一对象就是内置类型和 STL 的迭代器和函数对象。至于其他任何东西都请遵守本条款的忠告，尽量以 pass-by-reference-to-const 替换 pass-by-value</p><h4 id="20-2-总结">20.2 总结</h4><p>尽量以 pass-by-reference-to-const 替换 pass-by-value。前者通常比较高效，并可以避免切割问题。</p><p>以上规则并不适用内置类型，以及 STL的迭代器和函数对象。对它们而言，pass-by-value 往往比较适当。</p><h3 id="条款-21：必须返回对象时，别妄想返回其-reference">条款 21：必须返回对象时，别妄想返回其 reference</h3><p>避免传递一个 references 指向其时并不存在的对象。</p><p>所谓 reference 只是个名称，代表某个既有对象，任何时候看到一个 reference 声明式，都应该问自己，它的另一个名称是什么。</p><p>避免写出以下糟糕代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const Rational&amp; operator*(const Rational&amp; rhs)&#123;</span><br><span class="line">    static Rational result;         // static 对象，此函数将返回其 reference</span><br><span class="line">    result = ...;                   // 将 rhs 乘以当前对象，并将结果置于 result</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是完全合理的客户代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool operator==(const Rational&amp; rhs);       // 一个针对 Rational 而写的 operator==</span><br><span class="line">Rational a,b,c,d;</span><br><span class="line"></span><br><span class="line">if((a*b)==(c*d))&#123;</span><br><span class="line">    当乘积相等，做适当的动作</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    当乘积不相等，做适当的动作</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>表达式  ((a<em>b)==(c</em>d)) 总是被核算为 true，无论 a,b,c 和 d，因为 a<em>b 和 c</em>d 的操作结果都指向同一个 static 对象。</p><h4 id="总结-7">总结</h4><p>绝不要返回 Pointer 或 reference 指向一个 local stack 对象，或返回 reference 指向一个 heap-allocated 对象，或返回 Pointer 或 reference 指向一个 local static 对象而有可能同时需要多个这样的对象</p><h3 id="条款-22：将成员变量声明为-private">条款 22：将成员变量声明为 private</h3><p>成员变量应该是 private。</p><p>将成员变量声明为 private 意味着，访问某个成员变量需要通过成员函数实现，以下是这么做的好处：</p><h4 id="22-1-权限控制">22.1 权限控制</h4><p>使用函数可以对成员变量的处理有更精确的控制，包括只读，只写，读写等。</p><h4 id="22-2-封装">22.2 封装</h4><p>将成员变量隐藏在函数接口的背后，可以为“所有可能的实现”提供弹性。如果通过函数访问成员变量，日后可以改变某个计算替换这个成员变量，而 class 客户一点也不会知道 class 的内部已经起了变化。</p><p>public 意味着不封装，不封装意味着不可改变。即使拥有 class 的原始码，改变任何 public 事物的能力还是极端受到束缚，因为那会破坏太多客户端。</p><p>protected 成员变量也类似，假设我们有一个 public 成员变量，而我们最终取消了它，会导致所有使用它的 derived classes 被破坏。</p><p>protected 成员变量就像 public 成员变量一样缺乏封装性，因为在这两种情况下，如果成员变量被改变，都会有不可预知的大量代码受到破坏。</p><p>记住：从封装的角度看，其实只有两种访问权限：private（提供封装）和其他（不提供封装）。</p><h4 id="22-3-总结">22.3 总结</h4><p>切记将成员变量声明为 private。这可赋予客户端访问数据的一致性，可细微划分访问控制，并提供 class 作者以充分的实现弹性。</p><p>protected 并不比 public 更具封装性。</p><h3 id="条款-23：宁以-non-member-non-friend-替换-member-函数">条款 23：宁以 non-member non-friend 替换 member 函数</h3><h4 id="23-1-影响封装性的因素">23.1 影响封装性的因素</h4><p>说的比较抽象：</p><p>如果某些东西被封装，它就不再可见。愈多东西被封装（成员变量），愈少人可以看到它。而愈少人看到它，我们就有愈大的弹性去改变它，因为我们的改变仅仅直接影响看到改变的那些人。</p><p>愈少代码可以看到数据（也就是访问它），愈多的数据可被封装，而我们也就愈能自由地改变对象数据，例如改变成员变量的数量，类型等等。那么如何测量“有多少代码可以看到某一块数据”呢？计算能够访问该数据的函数数量，作为一种粗糙的量测，愈多函数可以访问它，数据的封装性愈低。</p><p>因此将 member 函数替换为 non-member non-friend 函数，可以提高对象的封装性。</p><h4 id="23-2-提高代码可扩展性">23.2 提高代码可扩展性</h4><p>在 C++，比较自然的做法就是让那些从类里抽离出来的 non-member non-friend 函数位于与该类所在的同一个 namespace 内：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">namespace WebBrowserStuff&#123;</span><br><span class="line">    class WebBrowser &#123; ... &#125;;</span><br><span class="line">    void clearBrowser(WebBrowser&amp; wb);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样只是看起来比较自然，namespace 和 class 不同，前者可以跨越多个源码文件而后者不能。一个像WebBrowser 这样的 class 可能拥有大量的便利函数，将它们分门别类可以使代码结构更清晰。分离这些便利函数的最直接做法就是将相关的一组函数分别在一个头文件中声明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 头文件 &quot;webbrowser.h&quot; 这个头文件针对 class WebBrowser 自身 以及 WebBrowser 核心机能</span><br><span class="line">namespace WebBrowserStuff &#123;</span><br><span class="line">class WebBrowser &#123; ... &#125;</span><br><span class="line">...               // 核心机能，例如几乎所有客户都需要的 non-member 函数</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 头文件 &quot;webbrowserbookmark.h&quot; </span><br><span class="line">namespace WebBrowserStuff &#123;</span><br><span class="line">    ...     // 与书签相关的便利函数</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">// 头文件 &quot;webbrowsercookies.h&quot;</span><br><span class="line">namespace WebBrowserStuff &#123;</span><br><span class="line">    ...     // 与cookie相关的便利函数</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>这正是 C++ 标准程序库的组织方式。标准程序库并不是拥有单一，整体，庞大的&lt;C++StandardLibrary&gt; 头文件并在其中内含 std 命名空间内的每一样东西，而是有数十个头文件（<vector> &lt;algorithm <memory>）</p><p>将所有便利函数放在多个头文件内但隶属于同一个命名空间，意味着客户可以轻松扩展这一组便利函数，他们需要做的就是添加更多 non-member non-friend 函数到此命名空间。记住，class 定义式对客户而言是不能扩展的。</p><h4 id="23-3-总结">23.3 总结</h4><p>宁可拿 non-member non-friend 函数替换 member 函数。这样做可以增加封装性，包裹弹性（packaging flexibility）和机能扩充性。</p><h3 id="条款-24：若所有参数皆需要类型转换，请为此采用-non-member-函数">条款 24：若所有参数皆需要类型转换，请为此采用 non-member 函数</h3><p>假设这样设计有理数 class:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Rational &#123;</span><br><span class="line">public:</span><br><span class="line">    Rational(int numerator=0,int denominator = 1);    // 可以不为 explicit ，允许 int 隐式转换为 Rational</span><br><span class="line">    int numerator() const;</span><br><span class="line">    int denominator() const;</span><br><span class="line">private:</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在要让 Rational 支持诸如加法，乘法等等。很可能你会想在 Rational class 内为有理数实现 operator*：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Rational &#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">    const Rational operator*(const Rational&amp; rhs) const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样就可以这样将两个有理数以最轻松自在的方式相乘：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Rational oneEight(1,8);</span><br><span class="line">Rational oneHalf(1,2);</span><br><span class="line">Rational result = oneHalf * oneEight;   // 很好</span><br><span class="line">result = result * oneEight; </span><br></pre></td></tr></table></figure><p>但你还不满足，希望它支持混合运算，如下所式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = oneHalf * 2;        // 很好</span><br><span class="line">result = 2*oneHalf;          // 错误</span><br></pre></td></tr></table></figure><p>为什么错误呢？当以对应的函数形式重写上述两个式子，问题所在就一目了然了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result = oneHalf.operator*(2);    // 很好</span><br><span class="line">result = 2.operator*(oneHalf);    // 错误</span><br></pre></td></tr></table></figure><p>很明显，整数 2 并没有相应的 class，也就没有 operator* 成员函数。编译器也会尝试寻找可被以下这般调用的 non-member operator*（也就是在命名空间内或在 global 作用域内）：</p><p>result = operator*(2,oneHalf)；  // 错误</p><h4 id="24-1-重载-运算符">24.1 重载 * 运算符</h4><p>为了解决上述问题，让 operator* 成为一个 non-member 函 ,m数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Rational &#123;</span><br><span class="line">    ...                // 不包括 operator*</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const Rational operator*(const Rational&amp; lhs, const Rational&amp; rhs)&#123;</span><br><span class="line">    return Rational(lhs.numerator()*rhs.numerator(),lhs.denominator()*rhs.denominator())</span><br><span class="line">;&#125;</span><br><span class="line"></span><br><span class="line">Rational oneFourth(1,4);</span><br><span class="line">Rational result;</span><br><span class="line">result = oneFourth * 2;    // 没问题</span><br><span class="line">result = 2 * oneFourth;    // 万岁，通过编译了</span><br></pre></td></tr></table></figure><p>这是一个快乐的结局，但还有一个问题？ operator* 是否应该成为 Rational class 的一个 friend 函数呢？</p><p>就本例而言是否定的，因为 operator* 可完全由 Rational 的 public 接口完成任务。无论何时如果可以避免 friend 函数就该避免。</p><h4 id="24-2-总结">24.2 总结</h4><p>如果需要为某个函数的所有参数（包括被 this 指针所指向的那个隐喻参数）进行类型转换，那么这个函数必须是个 non-member</p><h3 id="条款-25：考虑写出一个不抛出异常的-swap-函数">条款 25：考虑写出一个不抛出异常的 swap 函数</h3><p>swap 是个有趣的函数，原本它只是 STL 的一部分，后来成为异常安全性编程的脊柱，以及用来处理自我赋值可能性的一个常见机制。</p><h4 id="25-1-缺省实现">25.1 缺省实现</h4><p>缺省情况下 swap 动作可由标准程序库提供的 swap 算法完成，其典型实现如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">namespace std&#123;</span><br><span class="line">    template&lt;typename T&gt;          // std::swap 的典型实现</span><br><span class="line">    void swap(T&amp;a, T&amp;b)&#123;</span><br><span class="line">        T temp(a);</span><br><span class="line">        a = b;</span><br><span class="line">        b = tem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要类型 T 支持 copying（copy 构造函数和 copy assignment 操作符）</p><p>缺省版本实现十分平淡，它涉及三个对象的复制，对某些类型而言，这些复制动作无一必要。比如 “以指针指向一个对象，内含真正数据”那种类型，这种设计的常见表现形式是所谓的“pimpl手法”(pointer to implementation)，以这种手法设计 Widget class：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class WidgetImpl&#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">private:</span><br><span class="line">    int a,b,c;                          // 可能有许多数据</span><br><span class="line">    std::vector&lt;double&gt;v;               // 意味着复制时间很长</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Widget &#123;                // 这个 class 使用 pimpl 手法</span><br><span class="line">public:</span><br><span class="line">    Widget(const Widget&amp; rhs);</span><br><span class="line">    Widget&amp; operator=(const Widget&amp; rhs)&#123;    // 复制 widget 时，令它复制其 WidgetImpl 对象</span><br><span class="line">        ...                                  // 关于 operator= 的一般性实现</span><br><span class="line">        *pImpl = *(rhs.pImpl);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    WidgetImpl* pImpl;           // 所指对象内含 Widget 数据</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>一旦要置换两个 Widget 对象值，唯一需要做的就是置换其 pImpl 指针，但缺省的 swap 算法不知道这一点。它不只复制三个 Widgets，还复制三个 WidgetImpl 对象</p><h4 id="25-2-全特化版本">25.2 全特化版本</h4><p>我们希望告诉 std::swap，当 widgets 被置换时真正该做的是置换其内部的 pImpl 指针。确切实践这个思路的一个做法是：将 std::swap 针对 Widget 特化。下面是基本构想，还无法通过编译：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">namespace std&#123;</span><br><span class="line">    template&lt;&gt;</span><br><span class="line">    void swap&lt;Widget&gt;(Widget&amp; a, Widget&amp; b)  // 这是 std::swap 针对 “T是Widget”的特化版本</span><br><span class="line">    &#123;</span><br><span class="line">        swap(a.pImpl,b.pImpl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>“template&lt;&gt;” 表示它是 std::swap 的一个全特化（total template specialization）版本，函数名称之后的 “<Widget>”表示这一特化版本系统针对“T 是 Widget ”而设计。换句话说：当一般性的 swap template 施行于 Widgets 身上便会启用这个版本。</p><p>通常我们不能改变 std 命名空间内的任何东西，但可以为标准 templates（如 swap）制造特化版本，使他专属于我们自己的 classes（如 Widget）。</p><p>上述代码无法通过编译，原因是它企图访问 a 和 b 内的 pImpl 指针，而它们却是 private，我们可以将这个特化版本声明为 friend，但我们不那么做，而是令 Widget 声明一个名为 swap 的 public 成员函数做真正的置换工作，然后将 std::swap 特化，令他调用该成员函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Widget&#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">    void swap(Widget&amp; other)&#123;</span><br><span class="line">        using std::swap;</span><br><span class="line">        swap(pImpl,other.pImpl);            // 若要置换 Widgets 就置换其 pImpl 指针</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">namespace std&#123;</span><br><span class="line">    template&lt;&gt;</span><br><span class="line">    void swap&lt;Widget&gt;(Widget&amp;a, Widget&amp;b)&#123;</span><br><span class="line">        a.swap(b);            // 若要置换 Widgets，调用其 swap 成员函数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码不只能通过编译，还与 STL 容器有一致性，因为所有 STL 容器都提供 public swap 成员函数 和 std::swap 特化版本。</p><p>模板特化以后，实际上其本身已经不是templatized，而偏特化，仍然带有templatized。</p><p>关于模板的特化与偏特化：<a href="https://www.jianshu.com/p/4be97bf7a3b9">https://www.jianshu.com/p/4be97bf7a3b9</a></p><h4 id="25-3-偏特化版本">25.3 偏特化版本</h4><p>假设 Widget 和 WidgetImpl 都是 class templates 而非 classes:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class WidgetImpl &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">template&lt;typename T&gt;</span><br><span class="line">class Widget &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">namespace std&#123;</span><br><span class="line">    template&lt;typename T&gt;                               // 偏特化 swap</span><br><span class="line">    void swap&lt;Widget&lt;T&gt;&gt;(Widget&lt;T&gt;&amp;a, Widget&lt;T&gt;&amp;b)&#123;    // 错误 不合法</span><br><span class="line">        a.swap(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>声明一个 non-member swap 让他调用 member swap，但不再将那个 non-member swap 声明为 std::swap 的特化版本或重载版本。不能在 std 命名空间内偏特化 swap，假设 Widget 的所有相关机能都被置于命名空间 WidgetStuff 内：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">namespace WidgetStuff&#123;</span><br><span class="line">    ...                  // 模板化的 WidgetImpl 等等</span><br><span class="line">    template&lt;typename T&gt;    // 同前，内含 swap 成员函数</span><br><span class="line">    class Widget &#123; ... &#125;;</span><br><span class="line">    ...</span><br><span class="line">    template&lt;typename T&gt;     // non-member swap 函数</span><br><span class="line">    void swap(Widget&lt;T&gt;&amp; a, Widget&lt;T&gt;&amp; b)&#123;    // 这里并不属于 std 命名空间</span><br><span class="line">        a.swap(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在任何地点的任何代码如果打算置换两个 Widget 对象，因而调用 swap，C++ 的名称查找法则(name lookup rules) 会找到 WidgetStuff 内的 Widget 专属版本。如果你想让你的 “class 专属版” swap 在尽可能多的语境下被调用，你需要同时在该 class 所在命名空间内写一个 non-member 版本以及一个 std::swap 特化版本。</p><h4 id="25-4-using-std-swap">25.4 using std::swap</h4><p>假设现在正在编写一个 function template，其内需要置换两个对象值：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void doSomething(T&amp; obj1, T&amp; obj2)&#123;</span><br><span class="line">    ...</span><br><span class="line">    swap(obj1,obj2);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>应该调用哪个 swap？是 std 既有的那个一般化版本？还是某个可能存在的特化版本？抑或是一个可能存在的 T 专属版本而且可能栖身于某个命名空间（但当然不可以是 std）。</p><p>你希望的是调用 T 专属版本，并在该版本不存在的情况下调用 std 内的一般化版本，下面是你希望发生的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void doSomething(T&amp; obj1, T&amp; obj2)&#123;</span><br><span class="line">    using std::swap;      // 令 std::swap 在此函数内可用</span><br><span class="line">    ...</span><br><span class="line">    swap(obj1,obj2);      // 为 T 型对象调用最佳 swap 版本</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦编译器看到对 swap 的调用，它便会查找适当的 swap 并调用。C++ 的名称查找法则确保找到 global 作用域或 T 所在的命名空间内的任何 T 专属的 swap。</p><p>注意不要以这种方式调用 swap:</p><p>std::swap(obj1, obj2);           // 这是错误的 swap 调用方式</p><p>这将迫使编译器只认 std 内的 swap，而不太可能调用一个定义于它处的较适当 T 专属版本。</p><p>如果 swap 缺省实现版本的效率不足（那几乎总是意味着你的 class 或 template 使用了某种 pimpl 手法），试着做以下事情：</p><ol><li>提供一个 public swap 成员函数，让他高效地置换你的类型的两个对象值。</li><li>在你的 class 或 template 所在命名空间提供一个 non-member swap，并令它调用上述 swap 成员函数</li><li>如果你正在编写一个 class（而非 class template），为你的 class 特化 std::swap，并令它调用你的 swap 成员函数</li></ol><p>最后，如果你调用 swap ，请确定包含一个 using 声明式，以便让 std::swap 在你的函数内曝光可见，然后不加任何 namespace 修饰符，赤裸裸地调用 swap。</p><p>千万记住，成员版 swap 绝不可抛出异常。那是因为 swap 的一个最好的应用是帮助 classes（和 class templates）提供强烈的异常安全性（exception-safety）保障。</p><p>上述约束只施行于成员版！不可施行于非成员版，因为 swap 缺省版本是以 copy 构造函数和 copy assignment 操作符为基础，而一般情况下两者都允许抛出异常。</p><p>当你写下一个自定版本的 swap，往往提供的不只是高效率置换对象的办法，而且不抛出异常。一般而言这两个特性是连在一起的，因为高效率的 swaps 几乎总是对内置类型操作（例如 pimpl 手法的底层指针），而内置类型上的操作绝不会抛出异常。</p><h4 id="25-5-总结">25.5 总结</h4><ul><li>当 std::swap 对你的效率不高时，提供一个 swap 成员函数，并确定这个成员函数不抛出异常</li><li>如果你提供一个 member swap，也该提供一个 non-member swap 用来调用前者。对于 classes（而非 templates）,也请特化 std::swap</li><li>调用 swap 时应针对 std::swap 使用 using 声明式，然后调用 swap 并且不带任何“命名空间修饰符”</li><li>为“用户定义类型”进行 std templates 全特化是好的，但千万不要尝试在 std 内加入某些对 std 而言全新的东西。</li></ul><h2 id="五、实现">五、实现</h2><h3 id="条款-26：尽可能延后变量定义式的出现时间">条款 26：尽可能延后变量定义式的出现时间</h3><p>以下函数过早定义变量 “encrypted”</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::string encryptPassword(const std::string&amp; password)</span><br><span class="line">&#123;</span><br><span class="line">    using namespace std;</span><br><span class="line">    string encrypted;</span><br><span class="line">    if(password.length() &lt; MinimumPasswordLength)&#123;</span><br><span class="line">        throw logic_error(&quot;Password is too short&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    ...                    // 必要动作，例如将一个加密后的密码置入变量 encrypted 内</span><br><span class="line">    return encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象 encrypted 在此函数中并位被完全使用，如果有个异常被丢出，它就没有被真正使用，而它的构造和析构成本就浪费了。</p><p>稍微改进的版本，将 encrypted 放到较后位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void encrypt(std::string&amp; s);        // 在其中的适当地点对 s 加密</span><br><span class="line"></span><br><span class="line">std::string encryptPassword(const std::string&amp; password)</span><br><span class="line">&#123;</span><br><span class="line">    using namespace std;</span><br><span class="line">    if(password.length() &lt; MinimumPasswordLength)&#123;</span><br><span class="line">        throw logic_error(&quot;Password is too short&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    string encrypted;</span><br><span class="line">    encrypted = password;</span><br><span class="line">    encrypt(encrypted);</span><br><span class="line">    return encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上版本，对于变量 “encrypted” ，它首先调用 default 构造函数，然后调用 copy assignment 运算符。</p><h4 id="26-1-最优化版本">26.1 最优化版本</h4><p>以下版本可以避免无意义的 default 构造行为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std::string encryptPassword(const std::string&amp; password)</span><br><span class="line">&#123;</span><br><span class="line">    using namespace std;</span><br><span class="line">    if(password.length() &lt; MinimumPasswordLength)&#123;</span><br><span class="line">        throw logic_error(&quot;Password is too short&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    string encrypted(password);</span><br><span class="line">    encrypt(encrypted);</span><br><span class="line">    return encrypted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="26-2-循环内构造对象">26.2 循环内构造对象</h4><p>下面两个一般性结构，哪一个比较好？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 方法A，定义于循环外 </span><br><span class="line">Widget w;</span><br><span class="line">for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">    w = i 的某个值</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 方法B，定义于循环内</span><br><span class="line">for(int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">    Widget w(i 的某个值);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>做法 A：1 个构造函数 + 1 个析构函数 + n 个赋值操作</li><li>做法 B：n 个构造函数 + n 个析构函数</li></ul><p>如果 classes 的一个赋值成本低于一组构造+析构成本，做法 A 更高效，由其当 n 值很大的时候。否则做法 B 或许较好。</p><p>做法 A 造成名称 w 的作用域比做法 B 更大，有时对程序的可理解性和易维护性性造成冲突。因此除非明确（1）一个赋值成本低于一组构造+析构成本，（2）你正在处理代码中效率高度敏感的部分。否则，你应该使用做法 B。</p><h3 id="条款-27：尽量少做转型动作">条款 27：尽量少做转型动作</h3><h4 id="27-1-C-风格类型转换">27.1 C 风格类型转换</h4><p>被称为旧式转型：</p><p>(T)expression                  // 将 expression 转型为 T</p><p>函数风格的类型转换：</p><p>T(expression)                  // 将 expression 转型为 T</p><p>两种形式并无差别，只是小括号的摆放位置不同罢了。</p><h4 id="27-2-C-风格类型转换">27.2 C++ 风格类型转换</h4><p>被称为新式转型：</p><p>const_cast<T>(expression)</p><p>dynamic_cast<T>(expression)</p><p>reinterpret_cast<T>(expression)</p><p>static_cast<T> (expression)</p><p>各有不同目的：</p><ul><li>const_cast 通常用来将对象的常量性移除，它也是唯一有此能力的 C+±style 转型操作符。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const int constant = 1024;</span><br><span class="line">int *p =  const_cast&lt;int*&gt;(&amp;constant);</span><br><span class="line">int&amp; r = const_cast&lt;int&amp;&gt;(constant);</span><br><span class="line">(*p)++;</span><br><span class="line">r++;</span><br><span class="line">std::cout &lt;&lt; *p &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; r &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure><ul><li>dynamic_cast 主要用来执行 “安全向下转型”，用来决定某对象是否归属某继承体系中的某个类型。它是唯一无法由旧式语法执行的动作，也是唯一可能耗费重大运行成本的转型动作。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct A &#123;</span><br><span class="line">  virtual void f() &#123; cout &lt;&lt; &quot;Class A&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct B : A &#123;</span><br><span class="line">  virtual void f() &#123; cout &lt;&lt; &quot;Class B&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">struct C : A &#123;</span><br><span class="line">  virtual void f() &#123; cout &lt;&lt; &quot;Class C&quot; &lt;&lt; endl; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void f(A* arg) &#123;</span><br><span class="line">  B* bp = dynamic_cast&lt;B*&gt;(arg);</span><br><span class="line">  C* cp = dynamic_cast&lt;C*&gt;(arg);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  if (bp)</span><br><span class="line">    bp-&gt;f();</span><br><span class="line">  else if (cp)</span><br><span class="line">    cp-&gt;f();</span><br><span class="line">  else</span><br><span class="line">    arg-&gt;f();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  A aobj;</span><br><span class="line">  C cobj;</span><br><span class="line">  A* ap = &amp;cobj;</span><br><span class="line">  A* ap2 = &amp;aobj;</span><br><span class="line">  f(ap);</span><br><span class="line">  f(ap2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Class C</span><br><span class="line">Class A</span><br></pre></td></tr></table></figure><ul><li>static_cast 用来强迫隐式转换，功能是把一个表达式转换为某种类型，但没有运行时类型检查来保证转换的安全性。例如将 non-const 对象转为 const 对象，或将 int 转为 double 等等。它也可以用来执行上述多种转换的反向转换，例如将 void* 指针 转换为 typed 指针，将 pointer-to-base 转为 ponter-to-derived</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int  i;</span><br><span class="line">float f = 166.71;</span><br><span class="line">i =  static_cast&lt;int&gt;(f);</span><br></pre></td></tr></table></figure><ul><li>reinterpret_cast 执行低级转型，将数据以二进制存在形式的重新解释，实际动作(及结果)可能取决于编译器，造成了它不可移植，例如将一个 pinter to int 转型为一个 int。这一类转型在低级代码以外很少见。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">        int address = 0xFF1234;</span><br><span class="line">        int *p = reinterpret_cast&lt;int*&gt;(address);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        void *v = reinterpret_cast&lt;void*&gt;(p);</span><br><span class="line">        </span><br><span class="line">        printf(&quot;%0x %p\n&quot;,address,p);</span><br><span class="line">        printf(&quot;%p\n&quot;,v);</span><br><span class="line">         return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>static_cast 为什么比 reinterpret_cast 更安全：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">class A &#123;</span><br><span class="line">    public:</span><br><span class="line">    int m_a;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class B &#123;</span><br><span class="line">    public:</span><br><span class="line">    int m_b;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">class C : public A, public B &#123;&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">        C c;</span><br><span class="line">        printf(&quot;%p, %p, %p&quot;, &amp;c, reinterpret_cast&lt;B*&gt;(&amp;c), static_cast &lt;B*&gt;(&amp;c));</span><br><span class="line">        return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0x7ffe1d06b3a0, 0x7ffe1d06b3a0, 0x7ffe1d06b3a4</span><br></pre></td></tr></table></figure><p>c 的类结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$1 = &#123;</span><br><span class="line">  &lt;A&gt; = &#123;</span><br><span class="line">    m_a = -8368</span><br><span class="line">  &#125;, </span><br><span class="line">  &lt;B&gt; = &#123;</span><br><span class="line">    m_b = 32767</span><br><span class="line">  &#125;, &lt;No data fields&gt;&#125;</span><br></pre></td></tr></table></figure><p>前两个的输出值是相同的，最后一个则会在原基础上偏移4个字节，这是因为static_cast计算了父子类指针转换的偏移量，并将之转换到正确的地址（c里面有m_a,m_b，转换为B*指针后指到m_b处），而reinterpret_cast却不会做这一层转换。</p><p>旧式转型仍然合法，但新式转型更受欢迎，原因如下：</p><ol><li>它们容易在代码中辨识出来（不论是通过人工辨识或使用工具如 grep），因而得以简化“找出类型系统在哪个地点被破坏”的过程。</li><li>转型动作的目标愈窄化，编译器愈可能诊断出错误的运用。</li></ol><h4 id="27-3-为什么使用旧式转换">27.3 为什么使用旧式转换</h4><p>唯一使用旧式转型的时机，当需要调用一个 explicit 构造函数将一个对象传递给一个函数时。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit Widget(int size);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">void doSomeWork(const Widget&amp; w);</span><br><span class="line"></span><br><span class="line">doSomeWork(Widget(15));   // 以一个 int 加上 “函数风格” 的转型动作创建一个 Widget</span><br><span class="line">doSomeWork((Widget)15);   // C 风格的强制类型转换</span><br><span class="line">doSomeWork(static_cast&lt;Widget&gt;(15));// 以一个 int 加上 “C++ 风格” 的</span><br><span class="line">                                    // 转型动作创建一个 Widget</span><br></pre></td></tr></table></figure><h4 id="27-4-类型转换误用">27.4 类型转换误用</h4><p>许多程序员错误地相信，转型其实什么都没做，只是告诉编译器把某种类型视为另一种类型。其实，任何一个类型转换（不论是通过转型操作而进行的显式转换，或通过编译器完成的隐式转换）往往真的令编译器编译出运行期间执行的代码。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int x,y;</span><br><span class="line">...</span><br><span class="line">double d = static_cast&lt;double&gt;(x)/y;      // x 除以 y，使用 浮点数除法</span><br></pre></td></tr></table></figure><p>将 int 转型为 double 肯定会产生一些代码，因为大部分计算器体系结构中，int 的底层表述不同于 double 的底层表述。</p><h5 id="避免基于-C-对象的内存布局作任何转型动作">避免基于 C++ 对象的内存布局作任何转型动作</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123; ... &#125;;</span><br><span class="line">class Derived: public Base &#123; ... &#125;;</span><br><span class="line">Derived d;</span><br><span class="line">Derived *pd = &amp;d;</span><br><span class="line">Base *pb = pd;             // 隐喻地将 Derived* 转换为 Base*</span><br></pre></td></tr></table></figure><p>在这种情况下会有个偏移量(offset) 在运行期被施行于 Derived* 指针身上，用以取得正确的 Base* 指针值。</p><p>上述例子表明，单一对象（例如一个类型为 Derived 的对象）可能拥有一个以上的地址（例如 “以 Base* 指向它”时的地址和 “以 Derived* 指向它” 时的地址），这在 C 不可能发生，Java 和 C# 也不可能发生这种事，但 C++ 可以。实际上，一旦使用多重继承，这事几乎一直发生者。</p><p>所以意味着你通常应该避免做出“对象在 C++ 中如何布局的假设”，当然更不该以此假设为基础执行任何转型动作。例如，将对象地址转型为 char* 指针然后在它们身上进行指针算术，几乎总是导致无定义行为。</p><p>例如通过一定的偏移，将 将 Derived* 转换为 Base*。对象的布局方式和它们的地址计算方式随编译器的不同而不同，那意味着“由于知道对象如何布局”而设计的转型，在某一个平台行得通，而在其他平台并不一定行得通。</p><h5 id="避免修改派生类中其基类部分">避免修改派生类中其基类部分</h5><p>例如许多应用框架都要求 derived classes 内的 virtual 函数代码的第一个动作就是先调用 base class 的对应函数。假设我们由个 window base class 和一个 SpecialWindow derived class，两者都定义了 virtual 函数 onResize。进一步假设 SpecialWindow 的 onResize 函数被要求首先调用 window 的 onResize。以下是实现方式之一，看似是对的，其时是错的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Window &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void onResize()&#123; ... &#125;     </span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SpecialWindow: public Window&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void onResize()&#123;                 // 将 derived onResize 实现代码</span><br><span class="line">        static_cast&lt;Window&gt;(*this).onResize(); // 将 *this 转型为 window，然后调用其 onResize</span><br><span class="line">                                               // 这不可行  </span><br><span class="line">        ...  // 在这里进行 SpecialWindow 专属行为     </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码的最初预期应该是，将 *this 转型为 window，对函数 onResize的调用也因此调用了 Window::onResize。但事实上，它调用的并不是当前对象上的函数，而是稍早转型动作所建立的一个 “*this 对象的 base class 成分”的暂时副本身上调用 onResize。</p><p>再说一次，上述代码并非在当前对象上调用 Window::onResize 之后又在该对象身上执行 SpecialWindow 专属动作。不，它是在“当前对象之 base class 成分”的副本上调用 Window::onResize，然后在当前对象身上执行 SpecialWindow 专属动作。如果 Window::onResize 修改了对象内容，当前对象其实没被改动，改动的是副本。这会使得当前对象进入一种 “伤残”状态：其 base class 成分的更改没有落实，而 derived class 成分的更改倒是落实了。</p><p>解决方法是拿掉转型动作，而不是哄骗编译器将 *this 视为一个 base class 对象。如果只是想调用 base class 版本的 onResize 函数，请这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class SpecialWindow: public Window&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void onResize()&#123;                 </span><br><span class="line">        Window::onResize();   // 调用 Window::onResize 作用于 *this 身上   </span><br><span class="line">                                              </span><br><span class="line">        ...  // 在这里进行 SpecialWindow 专属行为     </span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个例子说明，如果你打算转型，这就是一个活脱脱的警告信号：你可能正将局面发展至错误的方向。</p><h4 id="27-5-dynamic-cast">27.5 dynamic_cast</h4><p>dynamic_cast  的许多实现版本执行速度相当慢。一个很普遍的实现版本是基于 “class 名称的字符串比较”。对四层深的单继承体系内的某个对象执行 dynamic_cast 可能会耗用多达四次的 strcmp 调用，用以比较 class 名称。深度继承或多重继承的成本更高。这些实现版本这么做是为了支持动态连接。</p><p>在注重效率的代码中，对 dynamic_cast 保持机敏与猜疑。</p><p>当你想在一个你认定为 derived class 对象身上执行 derived class 操作函数，但你的手上却只有一个 “指向 base” 的 pointer 或 reference。有两个一般性做法可以避免这个问题。</p><ol><li><h6 id="存储-derived-class-对象指针">存储 derived class 对象指针</h6></li></ol><p>使用容器并在其中存储直接指向 derived class 对象的指针（通常是智能指针），如此便消除了“通过 base class 接口处理对象”的需要。假设先前的 Window/SpecialWindow 继承体系中只有 SpecialWindow 才支持闪烁效果，可以这么做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef std::vector&lt;std::shared_ptr&lt;SpecialWindow&gt;&gt; VPSW;</span><br><span class="line">VPSW winPtrs;</span><br><span class="line">...</span><br><span class="line">for(VPSW::iterator iter = winPters.begin(); iter!=winPters.end(); ++iter)</span><br><span class="line">    (*iter)-&gt;blink();</span><br></pre></td></tr></table></figure><p>如果容器中存储的是 Window 类型指针，那么在执行 blink() 函数的时候就需要调用 dynamic_cast 将基类指针转换为派生类指针。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for(VPSW::iterator iter = winPters.begin(); iter!=winPters.end(); ++iter)&#123;</span><br><span class="line">    if(SpecialWindow *psw = dynamic_cast&lt;SpecialWindow*&gt;(iter-&gt;get()))&#123;</span><br><span class="line">        psw-&gt;bink();</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然啦，这种做法无法在同一个容器内存储指针“指向所有可能的Window 派生类”。如果真要处理多种窗口类型，你可能需要多种容器，它们都必须具备类型安全性。</p><ol><li><h6 id="通过-base-接口处理-“所有可能的-Window-派生类”">通过 base 接口处理 “所有可能的 Window 派生类”</h6></li></ol><p>在 base class 内提供 virtual 函数做你想对各个 window 派生类做的事。举个例子，虽然只有 SpecialWindow 可以闪烁，但可以将闪烁函数声明于 base class 内并提供一份 “什么也没做”的缺省实现，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Window &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void blink() &#123;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class SpecialWindow: public Window&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void blink() &#123; ... &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">typedef std::vector&lt;std::shared_ptr&lt;SpecialWindow&gt;&gt; VPSW;</span><br><span class="line">VPSW winPtrs;</span><br><span class="line">...</span><br><span class="line">for(VPSW::iterator iter = winPters.begin(); iter!=winPters.end(); ++iter)</span><br><span class="line">    (*iter)-&gt;blink();</span><br></pre></td></tr></table></figure><p>无论哪一种写法——“使用类型安全容器”或“将 virtual 函数往继承体系上方移动”，都并不是放之四海皆准，但在许多情况下它们都提供一个可行的 dynamic_cast 替代方案。</p><p>优良的 C++ 代码很少使用转型，我们应该尽可能隔离转型动作，通常是把它隐藏在某个函数内。</p><h4 id="27-5-总结">27.5 总结</h4><ul><li>如果可以，尽量避免转型。特别是在注重效率的代码中避免 dynamic_cast。如果有个设计需要转型动作，试着发展无需转型的替代设计。</li><li>如果转型是必要的，试着将它隐藏在某个函数背后。客户随后可以调用该函数，而不需将转型放进他们自己的代码。</li><li>宁可使用 C+±style 转型，不要使用旧式转型。前者很容易辨识出来，而且有个各自的职责。</li></ul><h3 id="条款-28：避免返回-handles-指向对象内部成分">条款 28：避免返回 handles 指向对象内部成分</h3><p>假设所编写的程序涉及矩形，每个矩形可以由两个点来表示（左上角和右下角），为了让 Rectangle 对象尽可能小，可以不把定义矩形的点放在 Rectangle 对象内，而是放在一个辅助的 struct 内再让 Rectangle 去指向它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Point &#123;                      // 这个类用来表示点</span><br><span class="line">public:</span><br><span class="line">    Point(int x, int y);</span><br><span class="line">    ...</span><br><span class="line">    void setX(int newVal);</span><br><span class="line">    void setY(int newVal);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct RectData &#123;                 // 表示一个矩形</span><br><span class="line">    Point ulhc;                   // ulhc=&quot;upper left-hand corner&quot; 左上角</span><br><span class="line">    Point lrhc;                   // lrhc=&quot;lower right-hand corner&quot; 右下角</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Rectangle &#123;</span><br><span class="line">    ...</span><br><span class="line">private:</span><br><span class="line">    std::shared_ptr&lt;RectData&gt; pData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Rectangle 客户端必须能够计算 Rectangle 的范围，所以这个 class 提供 upperLeft 函数和 lowerRight 函数。Point 是用户自定义类型，根据条款 20，我们令这些函数返回 reference，代表底层的 Point 对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle &#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">    Point&amp; upperLeft() const &#123; return pData-&gt;ulhc; &#125;</span><br><span class="line">    Point&amp; lowerRight() const &#123;return pData-&gt;lrhc; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码可通过编译，但却是错误的，实际上它是自我矛盾的。</p><p>一方面 upperLeft 和 lowerRight 被声明为 const 成员函数，因为他们的目的是提供客户一个读取 Rectangle 相关坐标的方法，而不是让客户修改 Rectangle。另一方面这两个函数却都返回 reference 指向 private 内部数据，调用者可通过这些 reference 更改内部数据，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Point coord1(0, 0);</span><br><span class="line">Point coord2(100, 100);</span><br><span class="line">const Rectangle rec(coord1, coord2);//rec 是个 const 矩形 从 (0,0) 到 (100,100)</span><br><span class="line">rec.upperLeft().setX(50);  // 变成了 (50,0) 到 (100, 100)</span><br></pre></td></tr></table></figure><p>upperLeft 的调用者能够使用被返回的 reference（指向 rec 内部的 Point 成员变量）。但 rec 其实应该是不可变的(const)。这个告诉我们：</p><ol><li>成员变量的封装性最多只等于 “返回其 reference”的函数的访问级别。本例中虽然 ulhc 和 lrhc 都被声明为 private，但它们实际上却是 public，因为 public 函数 upperLeft 和 lowerRight 传出了他们的 reference</li><li>如果 const 成员函数传出一个 reference，后者所指数据与对象自身有关联，而它又被存储于对象之外，那么这个函数的调用者可以修改那笔数据，这正是 bitwise constness 的一个附带结果。</li></ol><p>上前的情况都是由于“成员函数返回 reference”,如果它们返回的是指针或迭代器，相同的情况还会发生。reference，指针和迭代器统统都是所谓的 handles（号码牌，用于取得某个对象）</p><p>对象的“内部”就是指它的成员变量，但其实不被公开使用的成员函数（被称为 protected 或 private）也是对象“内部”的一部分。因此也应该留心不要返回它们的 handles。</p><p>我们上述遇到的问题可以轻松去除，只要在它们的返回类型上加上 const 即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Rectangle &#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">    const Point&amp; upperLeft() const &#123; return pData-&gt;ulhc; &#125;</span><br><span class="line">    const Point&amp; lowerRight() const &#123;return pData-&gt;lrhc; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="28-1-空悬问题">28.1 空悬问题</h4><p>虽然这些函数的写权力被禁止了，但 upperLeft 和 lowerRight 还是返回了“代表对象内部的” handles，有可能在其他场合带来问题，更明确地说是 dangling handles（空悬的号码牌），这种 handles 所指东西不复存在。这种“不复存在的对象”最常见的来源就是函数返回值。</p><p>例如某个函数返回 GUI 对象的外框，这个外框采用矩形表示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class GUIObject &#123; ... &#125;;</span><br><span class="line">const Rectangle boundingBox(const GUIObject&amp; obj); // 以by value 方式返回一个矩形</span><br></pre></td></tr></table></figure><p>现在客户端可以这么使用这个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GUIObject* pgo;          // 让 pgo 指向某个 GUIObject</span><br><span class="line">...</span><br><span class="line">const Point* pUpperLeft = &amp;(boundingBox(*pgo).upperLeft());//取得一个指针指向外框左上点</span><br></pre></td></tr></table></figure><p>对 boundingBox 的调用获得一个匿名对象，对该函数的调用语句结束后，该匿名对象将被销毁，其内的 Point 将析构。最终导致 pUpperLeft 指向一个不再存在的对象，也就是说一旦产生 pUpperLeft 的语句结束，pUpperLeft 也就变成空悬指针。</p><p>这就是为什么函数如果“返回一个 handle 代表对象内部成分”总是危险的原因，不论这个 handle 是否为 const，也不论那个返回 handle 的成员函数是否为 const。这里的唯一关键是：有个 handle 被传出去，一旦如此就暴露了“handle 比其所指对象更长寿”的风险下。</p><h4 id="28-2-例外">28.2 例外</h4><p>并不意味着不可以让成员函数返回 handle，例如 operator[] 就允许访问 string 或 vector 的个别元素。尽管如此，这样的函数毕竟是例外，不是常态。</p><h4 id="28-3-总结">28.3 总结</h4><p>避免返回 handle（包括 reference，指针，迭代器）指向对象内部。遵守这个条款可增加封装性，帮助 const 成员函数的行为像个 const，并将发生 &quot;虚吊号码牌&quot;的可能性降至最低。</p><h3 id="条款-29：为-“异常安全”而努力是值得的">条款 29：为 “异常安全”而努力是值得的</h3><p>假设有个 class 用来表示带背景图案的 GUI 菜单，这个 class 希望用于多线程环境，所以它有个互斥器(mutex)作为并发控制之用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class PrettyMenu&#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">    void changeBackground(std::istream&amp; imgSrc);</span><br><span class="line">    ...</span><br><span class="line">private:</span><br><span class="line">    Mutex mutex;               // 互斥器</span><br><span class="line">    Image* bgImage;            // 目前的背景图像</span><br><span class="line">    int imageChanges;          // 改变背景图像的次数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>下面是 PrettyMenu 的 changeBackground 函数的一个可能实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void PrettyMenu::changeBackground(std::istream&amp; imgSrc)&#123;</span><br><span class="line">    lock(&amp;mutex);             // 取得互斥器</span><br><span class="line">    delete bgImage;           // 删除旧的图像</span><br><span class="line">    ++imageChanges;           // 修改图像变更次数</span><br><span class="line">    bgImage = new Image(imgSrc);    // 安装新的背景图像</span><br><span class="line">    unlock(&amp;mutex);                 // 释放互斥器   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 “异常安全性”的观点来看，这个函数很糟。“异常安全”有两个条件，而这个函数一个都不满足。</p><p>当异常抛出时，带有异常安全性的函数会：</p><ul><li>不泄漏任何资源。上述代码一旦 “new Image(imgSrc)” 导致异常，对 unlock 的调用就不会执行，导致互斥器永远不会被释放。</li><li>不允许数据败坏。如果 “new Image(imgSrc)” 抛出异常，bgImage 就指向被删除的对象，imageChanges 也已经被累加，而其实并没有新的图像被成功安装起来。</li></ul><h4 id="解决资源泄漏">解决资源泄漏</h4><p>解决资源泄漏的问题很容易，条款 13 讨论如何以对象管理资源，条款 14 也导入了 Lock class 作为一种 “确保互斥器被及时释放”的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void PrettyMenu::changeBackground(std::istream&amp; imgSrc)</span><br><span class="line">&#123;</span><br><span class="line">    Lock ml(&amp;mutex);</span><br><span class="line">    delete bgImage;</span><br><span class="line">    ++imageChanges;</span><br><span class="line">    bgImage = new Image(imgSrc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决数据败坏">解决数据败坏</h4><p>此刻我们需要做个抉择，在能够做抉择之前，先学习一些术语：</p><ul><li>基本承诺：如果异常被抛出，程序内的任何事物仍然保持在有效状态下。没有任何对象或数据结构会因此而败坏，所有对象都处于一种内部前后一致的状态（例如所有的 class 约束条件都继续获得满足）。例如：changeBackground 一旦异常了被抛出，PrettyMenu 对象可以继续拥有原背景图像，或者令它拥有某个缺省背景图像，但客户无法预知哪一种情况。</li><li>强烈保证：如果异常被抛出，程序状态不改变。调用这样的函数需要这样的认知：如果函数成功，就是完全成功，如果函数失败，程序会恢复到“调用函数之前的状态”。</li><li>不抛掷（nothrow）保证，承诺绝不抛出异常，因为它们总是能够完成它们原先承诺的功能。作用与内置类型（例如 int，指针等等）身上的所有操作都提供 nothrow 保证。这是异常安全码中一个必不可少的基础材料。</li></ul><p>如果我们假设，函数带着“空白的异常明细”者必为 nothrow 函数，似乎合情合理，但其实不尽然。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int doSomething() throw();  // 空白的异常明细</span><br></pre></td></tr></table></figure><p>这并不代表 doSomething 绝不会抛出异常，而是如果 doSomething 抛出异常，将是严重错误。实际上 doSomething 也许完全没有提供任何异常保证。函数的声明式（包括异常明细）并不能告诉你是否它是正确的，可移植的或高效的，也不能告诉你它是否提供任何异常安全保证。所有那些性质都由函数决定，无关乎声明。</p><p>为我们写的每一个函数提供一种安全保证。</p><h4 id="为-changeBackground-提供强烈保证">为 changeBackground 提供强烈保证</h4><p>首先改变 PrettyMenu 的 bgImage 成员变量的类型，从一个 Image* 的内置指针改为 “用于资源管理”的智能指针。</p><p>第二，重新排列 changeBackground 内的语句次序，使得在更换图像之后才累加 imageChanges。一般这是个好策略：不要为了表示某件事发生而改变对象的状态，除非那件事真的发生了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class PrettyMenu &#123;</span><br><span class="line">    ...</span><br><span class="line">    std::shared_ptr&lt;Image&gt;bgImage;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void PrettyMenu::changeBackground(std::istream&amp; imgSrc)&#123;</span><br><span class="line">    Lock ml(&amp;mutex);</span><br><span class="line">    bgImage.reset(new ImaSrc);   // 以 &quot;new Image&quot; 的执行结果设定 bgImage 内部指针</span><br><span class="line">    ++imageChanges;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里不需要再手动去 delete 旧图像，因为这个动作已经由智能指针内部处理调了，而且删除动作只发生在新图像被成功创建之后。更准确的说：std::shared_ptr::reset 函数只有在其参数被成功生成之后被调用，delete 只在 reset 函数内被使用。</p><p>美中不足是参数 imgSrc，如果 Image 构造函数抛出异常，有可能输入流（input stream）的读取记号（read marker）已被移走，而这样的搬移对程序其余部分是一种可见的状态改变。</p><p>所以 changeBackground 在解决这个问题之前只提供基本的安全保证。</p><h4 id="另一个方法-copy-and-swap">另一个方法 copy and swap</h4><p>还有个一般化的设计策略会导致强烈保证，这个策略被称为 copy and swap。原则很简单，将打算修改的对象做出一份副本，然后在那副本身上做一切必要修改。若有任何修改动作抛出异常，原对象仍然保持不变。待所有改变都成功后，再将修改过的副本和原对象在一个不抛出异常的操作中置换（swap）。</p><p>通常将所有“隶属于对象的数据”从原对象放进另一个对象内，然后赋予原对对象一个指针，指向那个所谓的实现对象（implementation object）。这种手法称为 pimpl idiom。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">struct PMImpl&#123;</span><br><span class="line">    std::shared_ptr&lt;Image&gt;bgImage;</span><br><span class="line">    int imageChanges;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class PrettyMenu&#123;</span><br><span class="line">    ...</span><br><span class="line">private:</span><br><span class="line">    Mutex mutex;</span><br><span class="line">    std::shared_ptr&lt;PMImpl&gt; pImpl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void PrettyMenu::changeBackground(std::istream&amp; imgSrc)&#123;</span><br><span class="line">    using std::swap;</span><br><span class="line">    Lock ml(&amp;mutex);</span><br><span class="line">    std::shared_ptr&lt;PMImpl&gt;pNew(new PMImpl(*pImpl));</span><br><span class="line">    pNew-&gt;bgImage.reset(new Image(imgSrc));   // 修改副本</span><br><span class="line">    ++pNew-&gt;imageChanges;</span><br><span class="line">    swap(pImpl,pNew);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为啥将 PMImpl 成为一个 struct 而不是一个 class，因为 PrettyMenu 的数据封装性已经由于“pImpl 是 private”而获得了保证。</p><p>“copy-and-swap” 策略是对对象状态做出 “全有或全无”改变的一个很好办法，但一般而言它并不保证整个函数有强烈的异常安全性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void someFunc()&#123;</span><br><span class="line">    ...             // 对 local 状态做一份副本</span><br><span class="line">    f1();</span><br><span class="line">    f2();</span><br><span class="line">    ...             // 将修改后的状态置换过来 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很显然，如果 f1 或 f2 的异常安全性比 “强烈保证”低，就很难让 someFunc 成为“强烈异常安全”。</p><p>当写代码或修改代码时，思考如何让他具备异常安全性，首先是“以对象管理资源”，那可阻止资源泄漏，然后是挑选三个“异常安全保证”中的一个实施于我们写的每一个函数身上。应该选择合理条件下的最强烈等级，只有当你的代码调用了传统代码，才别无选择地将它设为“无任何保证”。将此决定写成文档，一来为函数用户着想，二来为将来的维护者着想。函数的“异常安全性”是其可见接口的一部分。</p><h4 id="总结-8">总结</h4><ul><li>异常安全函数即使发生异常也不会泄漏资源或允许任何数据结构败坏。这样的函数分为三种可能的保证：基本型，强烈型，不抛异常型。</li><li>“强烈保证”往往能够以 copy-and-swap 实现出来，但“强烈保证”并非对所有函数都可实现或具备现实意义。</li><li>函数提供的“异常安全保证”通常最高只等于其所调用之各个函数的“异常安全保证”中的最弱者。</li></ul><h3 id="条款-30：透彻了解-inlining-的里里外外">条款 30：透彻了解 inlining 的里里外外</h3><p>inlining 函数原理：将对此函数的每一个调用都以函数本体替换。编译器最优化机制通常被设计用来浓缩那些“不含函数调用”的代码，当将一个函数 inline 之后，编译器或许有能力对函数本体执行语境进行优化。</p><p>inling 函数的优点是避免了函数调用产生的开销，但缺点是可能会大大增大目标码的大小，它可能会导致额外的换页行为，降低指令高速缓存装置的命中率，以及伴随这些而来的效率损失。</p><h4 id="隐喻声明-inline">隐喻声明 inline</h4><p>记住，inline 只是对编译器的申请，不是强制命令。这项申请可以隐喻提出，也可以明确提出。隐喻方式是将函数定义于 class 定义式内：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">    int age() const &#123; return theAge;&#125;//一个隐喻的 inline 申请：age 被定义于 class 定义式内</span><br><span class="line">private:</span><br><span class="line">    int theAge;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>friend 函数也可以被定义于 class 内，它们也是被隐喻声明为 inline</p><h4 id="显式声明-inline">显式声明 inline</h4><p>显式声明 inline 的方法是在其定义式前加关键字 inline。例如标准的 max template 是这样实现的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;                        </span><br><span class="line">inline const T&amp; std::max(const T&amp; a, const T&amp; b)&#123;</span><br><span class="line">    return a&lt;b?b:a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大部分编译器拒绝将太过复杂（例如带有循环或递归）的函数 inlining。一个表面看似 inline 的函数是否真的 inline 取决于内置环境，主要取决于编译器。</p><h4 id="outlined-函数本体">outlined 函数本体</h4><p>有时候编译器愿意 inlining 某个函数，还是可能为该函数生成一个函数本体。例如，如果程序要取某个 inline 函数的地址，编译器通常为此函数生成一个 outlined 函数本体。</p><p>编译器通常不对“通过函数指针而进行的调用”实施inlining，这意味着对 inline 函数的调用有可能被 inlined，也可能 inlined，也可能不被inlined，取决于该调用的实施方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inline void f() &#123; ... &#125;  // 假设编译器有意愿 inline “对 f 的调用”</span><br><span class="line">void (*pf)() = f;  // pf 指向 f</span><br><span class="line">...</span><br><span class="line">f();                // 这个调用将被 inlined，因为它是一个正常调用</span><br><span class="line">pf();               // 这个调用或许不被 inlined，因为它通过函数指针完成</span><br></pre></td></tr></table></figure><p>inline 函数无法随着程序的升级而升级，如果 f 是程序库内的一个 inline 函数，客户将 &quot;f 函数本体&quot;编进程序中。一旦程序库设计者决定改变 f，所有用到 f 的客户端程序都必须重新编译。而如果 f 是 non-inline 函数，一旦它有任何修改，客户端只需重新连接就好。</p><p>平均而言：一个程序往往将  80% 的执行时间花费在 20% 的代码上，作为一个软件开发者，你的目标应该是找出这可以有效增进程序整体效率的 20% 代码，然后将它inline 或将他瘦身。</p><h4 id="总结-9">总结</h4><p>将大多数 inlining 限制在小型，被频繁调用的函数身上。这可以使日后的调试和二进制升级更容易，也可以使潜在的代码膨胀问题最小化。</p><p>不要只因为 function templates 出现在头文件，就将它们声明为 inline</p><h3 id="条款-31：将文件间的编译依存关系降至最低">条款 31：将文件间的编译依存关系降至最低</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &quot;date.h&quot;</span><br><span class="line">#include &quot;address.h&quot;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">    Person(const std::string&amp; name, const Date&amp; birth, const Address&amp; addr);</span><br><span class="line">    std::string name() const;</span><br><span class="line">    std::string birthDate() const;</span><br><span class="line">    std::string address() const;</span><br><span class="line">    ...</span><br><span class="line">private:</span><br><span class="line">    std::string theName;       // 实现细目</span><br><span class="line">    Date theBirthDate;         // 实现细目</span><br><span class="line">    Address theAddress;        // 实现细目</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="31-1-编译依存关系">31.1 编译依存关系</h4><p>上述代码存在一种编译依存关系（compilation dependency），如果上述头文件中的任何一个被改变，或这些头文件所依赖的其他头文件有任何改变，那么每一个含入 Person class 的文件就得重新编译，任何使用 Person class 的文件也必须重新编译。这样的连串编译依存关系会对许多项目造成麻烦。</p><h4 id="31-2-前置声明">31.2 前置声明</h4><p>定义一个类型时，编译器必须在编译期间知道对象的大小：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int x;              // 定义一个 int</span><br><span class="line">    Person p(params);   // 定义一个 Person</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译器看到 x 的定义式，它必须知道分配多少内存，看到 p 也一样，它必须分配足够空间以放置一个 Person。编译器获得这些信息的唯一方法就是询问 class 的定义式。那么如果 class 定义式可以合法地不列出实现细目，编译器该如何分配多少空间？</p><p>对于 Java，Smalltalk 等语言这些问题并不存在，因为以那种语言分配对象，编译器只分配足够空间给一个指针（用以指向该对象）使用，也就是它们将上述代码视同这样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;</span><br><span class="line">    int x;                // 定义一个 int</span><br><span class="line">    Person* p;            // 定义一个指针指向 Person 对象</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个也是合法的 C++ 代码，因此我们也可以“将对象的实现细目隐藏于一个指针背后”，针对 Person 我们可以这么做：把 Person 分割为两个 classes，一个只提供接口，另一个负责实现该接口。将那个负责实现的 class 称为 implementation class，取名为 PersonImpl，Person 定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;memory&gt;</span><br><span class="line"></span><br><span class="line">class PersonImpl;   // Person 实现类的前置声明</span><br><span class="line">class Date;         // Person 接口用到的 classes 的前置声明</span><br><span class="line">class Address;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">    Person(const std::string&amp; name, const Date&amp; birth, const Address&amp; addr);</span><br><span class="line">    std::string name() const;</span><br><span class="line">    std::string birthDate() const;</span><br><span class="line">    std::string address() const;</span><br><span class="line">    ...</span><br><span class="line">private:</span><br><span class="line">    std::shared_ptr&lt;PersonImpl&gt;pImpl;      // 指针，指向实现物</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样 Person 只含一个指针成员，指向其实现类（PersonImpl）。这种设计被称为 pimpl idiom（pimpl 是 “pointer to implementation” 的缩写）。</p><p>这样的设计下，Person 的客户端就完全与 Date，Address 以及 Person 的实现细目分离了。那些 classes 的任何实现修改都不需要 Person 客户端重新编译。</p><p>此外，由与客户无法看到 Person 的实现细目，也就不可能写出“取决于那些细目”的代码，这就是“接口与实现分离”。</p><p>这个分离的关键是以“声明的依存性”替换“定义的依存性”，那就是编译依存性最小化的本质：现实中让头文件尽可能自我满足，万一做不到，则让他与其他文件内的声明式（而非定义式）相依。</p><ul><li>如果使用 object references 或 object pointers 可以完成任务，就不要使用 objects。因为只靠一个类型声明就可以定义指向该类型的 references 和 pointers。但如果定义某类型的 objects，就需要用到该类型的定义式。</li><li>尽量以 class 声明式替换 class 定义式。注意：当你声明一个函数而它用到某个 class 时，你并不需要该 class 的定义，即使函数以 by value 方式传递该类型的参数（或返回值）亦然：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Date;           // class 声明式</span><br><span class="line">Date today();         // 没问题</span><br><span class="line">void clearAppointments(Date d);   // Date 定义式</span><br></pre></td></tr></table></figure><p>声明 today 函数和 clearAppointments 函数而无需定义 Date，因为一旦任何人调用这些函数，调用之前 Date 定义式一定得先曝光才行。假设一个函数库包含数百个函数声明，不太可能每个客户调用每一个函数，如果能够将 “提供 class 的定义式”（通过 #include）的义务从“函数声明所在”的头文件转移到“函数被调用”的客户端文件，就可以将“并非真正必要的类型定义”与客户端之间的编译依存性取除掉。例如：</p><ul><li>为声明式和定义式提供不同的头文件。为了遵守上述准则，需要两个头文件，一个用于声明，一个用于定义式。如果某个声明式文件被改变了，两个文件都得改变。因此程序库客户端应该总是 #include 一个声明文件而非前置声明若干函数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;datafwd.h&quot;        // 这个头文件内声明（但未定义） class Date</span><br><span class="line">Date today();</span><br><span class="line">void clearAppointments(Date d);   // Date 定义式</span><br></pre></td></tr></table></figure><p>只含声明式的头文件名为  “datafwd.h” ，命名方式采用 C++ 标准程序库头文件的 <iosfwd>， <iosfwd> 内含 iostream 各组件的声明式，其对应定义则分布在若干不同的头文件内，包括 <sstream> <streambuf> <fstream> 和 <iostream></p><h4 id="31-3-export">31.3 export</h4><p>C++ 提供关键字 export，允许将 template 声明式和 template 定义式分割于不同的文件内。但有些编译器可能并不支持这个关键字。</p><h4 id="31-4-Handle-class">31.4 Handle class</h4><p>像 Person 这样使用 pimpl idiom 的classes，往往被称为 Handle classes，将它们的所有函数转交给相应的实现类并由后者完成实际工作。例如下面是 Person 两个成员函数的实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 我们正在实现 Person class，所以必须 #include 其定义式</span><br><span class="line">#include &quot;Person.h&quot;    </span><br><span class="line"> </span><br><span class="line">// 必须#include PersonImpl 的 class 定义式，否则无法调用其成员函数</span><br><span class="line">// PersonImpl 有着和 Person 完全相同的成员函数，两者接口完全相同 </span><br><span class="line">#include &quot;PersonImpl.h&quot; </span><br><span class="line"></span><br><span class="line">Person::Person(const std::string&amp; name, const Date&amp; birth, const Address&amp; addr)</span><br><span class="line">    :pImpl(new PersonImpl(name,birth,addr))&#123;&#125;</span><br><span class="line">    </span><br><span class="line">std::string Person::name() const&#123;</span><br><span class="line">    return pImpl-&gt;name();</span><br><span class="line">&#125;    </span><br><span class="line">                            </span><br><span class="line">                            </span><br></pre></td></tr></table></figure><p>让 Person 变成一个 Handle class 并不会改变它做的事，只会改变它做事的方法。</p><h4 id="31-5-Interface-class">31.5  Interface class</h4><p>另一个制作 Handle class 的办法是，令 Person 成为一种特殊的 abstract base class（抽象基类），称为 Interface class。这种 class 的目的是详细一一描述 derived class 的接口，因此它通常不带成员变量，也没有构造函数，只有一个 virtual 析构函数，以及一组 pure virtual 函数，用来描述整个接口。</p><p>一个针对 Person 而写的 Interface class 获取看起来像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ~Person();</span><br><span class="line">    virtual std::string name() const = 0;</span><br><span class="line">    virtual std::string birthDate() const = 0</span><br><span class="line">    virtual std::string address() const = 0;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个 class 的客户必须以 Person 的pointers 或 reference 来编写应用程序，因为它不可能针对“内含 pure virtual 函数”的 Person classes 具现出实体（然而却可能对派生自 Person 的 classes 具现出实体）。就像 Handle classes 的客户一样，除非 Interface class 的接口被修改否则其客户不需要重新编译。</p><p>Interface class 的客户必须有办法为这种 class 创建对象，它们通常调用一个特殊函数，用来构造那个 derived class 对象，这样的函数称为工厂函数或 virtual 构造函数，它们返回指针（更可取的智能指针）指向动态分配的对象，而该对象支持 Interface class 的接口，这样的函数往往在 Interface class 内被声明为 static</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual ~Person();</span><br><span class="line">    virtual std::string name() const = 0;</span><br><span class="line">    virtual std::string birthDate() const = 0;</span><br><span class="line">    virtual std::string address() const = 0;</span><br><span class="line"></span><br><span class="line">    static std::shared_ptr&lt;Person&gt; create(const std::string&amp; name, const Date&amp; brithday, const Address&amp; addr)&#123;</span><br><span class="line">        return std::shared_ptr&lt;Person&gt; (new RealPerson(name,brithday,addr));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>客户会这样使用它们：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">std::string name;</span><br><span class="line">Date dateofBirth;</span><br><span class="line">Address address;</span><br><span class="line">...</span><br><span class="line">// 创建一个对象，支持 Person 接口</span><br><span class="line">std::shared_ptr&lt;Person&gt; pp(Person::create(name,dataofBirth,address));</span><br><span class="line">...</span><br><span class="line">// 通过 Person 的接口来使用这个对象</span><br><span class="line">std::cout &lt;&lt; pp-&gt;name() &lt;&lt; &quot; &quot; &lt;&lt; pp-&gt;birthDate()&lt;&lt; &quot; &quot; &lt;&lt; pp-&gt;address();</span><br><span class="line"></span><br><span class="line">// 当 pp 离开作用域，对象会被自动删除</span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>当然，支持 Interface class 的那个具象类(concrete classes)必须被定义出来，而且真正的构造函数必须被调用。一切都在 virtual 构造函数实现代码所在文件内发生。假设 Interface class Person 有个具象类 deriveded class RealPerson，后者提供继承而来的 virtual 函数的实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class RealPerson: public Person &#123;</span><br><span class="line">public:</span><br><span class="line">    RealPerson(const std::string&amp; name, const Date&amp; brithday, const Address&amp; addr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    virtual ~RealPerson() &#123;&#125;</span><br><span class="line">    std::string name() const;</span><br><span class="line">    std::string birthDate() const;</span><br><span class="line">    std::string address() const;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    std::string theName;       // 实现细目</span><br><span class="line">    Date theBirthDate;         // 实现细目</span><br><span class="line">    Address theAddress;        // 实现细目</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有了 RealPerson 之后，写出 Person::create 就很容易了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static std::shared_ptr&lt;Person&gt; Person::create(const std::string&amp; name, const Date&amp; brithday, const Address&amp; addr)&#123;</span><br><span class="line">        return std::shared_ptr&lt;Person&gt; (new RealPerson(name,brithday,addr));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>一个更现实的 Person::create 实现代码会创建不同类型的 derived class 对象，取决于诸如额外的参数值，然后实现接口所覆盖函数。</p><p>Handle classes 和 Interface classes 解除了接口和实现之间的耦合关系，从而降低了文件间的编译依存性。但代价就是：运行期间丧失若干速度，为每个对象超额付出若干内存。</p><p>Handle classes的缺点：</p><ul><li>速度方面——成员函数必须通过 implementation pointer 取得对象数据，那会为每一次访问增加一层间接性。implementation pointer 必须被初始化，指向一个动态分配得来的 implementation object，又产生了动态内存分配和释放的开销</li><li>空间方面——每一个对象消耗的内存必须增加 implementation pointer 的大小</li><li>异常：动态内存分配因内存不足，而遭遇 bad_alloc 的可能性</li></ul><p>Interface classes 的缺点：</p><ul><li>速度方面——每个函数都是 virtual ，必须为每个函数调用付出一个间接跳跃成本（查询虚函数表）</li><li>空间方面——Interface class 派生的对象必须包含一个 vptr，这个指针可能会增加存放对象所需的内存数量——实际取居于这个对象除了 Interface class 之外是否还有其他 virtual 函数来源。</li></ul><p>最后，无论是 Handle classes 还是 Interface classes，一旦脱离 inline 函数都无法有太大作为。条款 30 解释了为什么函数本体为了被 inlined 必须置于头文件内，但 Handle classes 和 Interface classes 正是特别被设计用来隐藏实现细节如函数本体。</p><h4 id="31-6-总结">31.6 总结</h4><ul><li>支持“编译依存性最小化”的一般构想：相依于声明式，不要相依于定义式，基于此构想的两个手段是 Handle classes 和 Interface classes。</li><li>程序库头文件应该以“完全且仅有声明式”的形式存在，这种做法无论是否涉及 templates 都适用。</li></ul><h2 id="六、继承与面向对象设计">六、继承与面向对象设计</h2><p>C++ 的面向对象编程（OOP）具有以下特点：</p><ul><li>支持单一继承或多重继承</li><li>继承类型可以是：public, protected 或 private，也可以是 virtual</li><li>成员函数类型有：virtual, non-virtual, pure virtual</li><li>virtual 函数意味着“接口必须被继承”</li><li>non-virtual 函数意味着“接口和实现都必须被继承”</li></ul><h3 id="条款-32：确定你的-public-继承塑模出-is-a-关系">条款 32：确定你的 public 继承塑模出 is-a 关系</h3><h4 id="32-1-public-继承">32.1 public 继承</h4><p>一个 class D 以 public 形式继承 class B，意味着每一个类型为 D 的对象同时也是一个类型为 B 的对象，反之不成立。B 表现出比 D 更一般化的概念，D 比 B 表现出更特殊的概念。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123; ... &#125;;</span><br><span class="line">class Student: public Person &#123; ... &#125;; </span><br></pre></td></tr></table></figure><p>根据常识，每个学生都是人，但并非每个人都是学生。这就是 public 继承体系的主张。</p><p>于是，在 C++ 领域中，任何函数如果期望获得一个类型为 Person（pointer-to-Person 或 reference-to-Person） 的实参，都愿意接受一个 Student 对象（pointer-to-Student 或 reference-to-Student）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void eat(const Person&amp; p);      // 任何人都会吃</span><br><span class="line">void study(const Student&amp; s);   // 只有学生才到校学习</span><br><span class="line">Person p;</span><br><span class="line">Student s;</span><br><span class="line">eat(p);    // 没问题，p 是人</span><br><span class="line">eat(s);    // 没问题，s 是学生，而学生也是（is-a）人</span><br><span class="line">study(s);  // 没问题，s 是个学生</span><br><span class="line">study(p);  // 错误，p 不是个学生</span><br></pre></td></tr></table></figure><h4 id="32-2-is-a-关系">32.2  is-a 关系</h4><p>is-a 关系，翻译为中文表示“是一个/是一种”关系。例如前面的 Student 和 Person 的例子，一个学生也“是一个”人。这就是所谓的 is-a 关系。</p><p>public 继承和 is-a 之间的等价关系听起来简单，但也需要注意某些违反直觉的问题。例如：</p><h5 id="企鹅和鸟">企鹅和鸟</h5><p>企鹅(penguin) 是一种鸟，鸟可以飞，这些都是事实。观察以下继承关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Bird&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fly();       // 鸟可以飞</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Penguin: public Bird&#123;   // 企鹅是一种鸟</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个继承体系表明企鹅可以飞，根据常识，企鹅不会飞，很明显这个继承关系有问题。</p><p>如果思想再严谨一些，我们知道，不是所有鸟都会飞。现在我们设计以下继承关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Bird &#123;</span><br><span class="line">    ...             // 没有声明 fly 函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class FlyingBird: public Bird &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fly();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Penguin: public Bird &#123;</span><br><span class="line">    ...           // 没有声明 fly 函数</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样的继承体系比原先的设计更能反映我们真实的意思。</p><p>即便如此，我们仍然未能完全处理好这些鸟事，因为对某些系统而言，可能不需要区分会飞的鸟和不会飞的鸟。如果我们的程序完全不在乎飞行，那么原先的“双 classes 继承体系”就令人满足了。这反应了一个事实，世界上并不存在一个“适用于所有软件”的完美设计。所谓的最佳设计，取决于系统希望做什么事，包括现在与未来。</p><p>另一种办法是为企鹅重新定义 fly 函数，令它产生一个运行期错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void error(const std::string&amp; msg);    // 定义于另外某处</span><br><span class="line">class Penguin: public Bird &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fly() &#123; error(&quot;试图让一只企鹅飞&quot;); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这是一种在运行期侦测错误的办法。</p><p>除此之外，我们还可以在编译期间就可以侦测出错误用法，如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Bird&#123;</span><br><span class="line">    ...                // 没有声明 fly 函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Penguin: public Bird &#123;</span><br><span class="line">    ...                // 没有声明 fly 函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 现在，如果企图让企鹅飞，编译器会发出警告</span><br><span class="line">Penguin p;</span><br><span class="line">p.fly();     // 错误</span><br></pre></td></tr></table></figure><h4 id="32-3-总结">32.3 总结</h4><p>&quot;public 继承&quot;意味着 is-a。适用于 base classes 身上的每一件事情一定也适用于 derived classes 身上，因为每一个 derived class 对象也都是一个 base class 对象。</p><h3 id="条款-33：避免遮掩继承而来的名称">条款 33：避免遮掩继承而来的名称</h3><h4 id="33-1-作用域与查找规则">33.1 作用域与查找规则</h4><p>本条款所讲的内容主要和作用域有关。例如以下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int x;             // global 变量</span><br><span class="line">void someFunc()&#123;</span><br><span class="line">    double x;      // local 变量</span><br><span class="line">    std::cin &gt;&gt; x; // 读取一个新值赋予 local 变量 x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取数据的语句，使用的是 local 变量 x，而不是 global 变量 x，因为内层作用域的名称会遮盖外围作用域的名称。</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=MDA2ZDM1MmJkNGE1MmVhMmYxZDg4MzlmMTk0ZDczNDNfZFZaNm5ueFQ4QjBOQUdsSk8ybllGQVdIZ2J2ZzlzMzVfVG9rZW46Ym94azQ1dGVFU2FsWTdxQXlQOGtDaEpYeE5oXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>当涉及到继承时，derived class 作用域被嵌套在 base class 作用域内，像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">private:</span><br><span class="line">    int x;</span><br><span class="line">public:</span><br><span class="line">    virtual void mf1() = 0;</span><br><span class="line">    virtual void mf2();</span><br><span class="line">    void mf3();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived: public Base &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void mf1();</span><br><span class="line">    void mf4();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NGRjNWQ3NzUzOGI1NGMwMWRmZWQ2N2VmNjY2MWE4MTlfVjAzRVFDcXFaeG1NQnkyUDdSemxSd0VLZXFIeFg5TlpfVG9rZW46Ym94azRRQkxVeVVPUmdGVzVWeE9rNFdFM3lnXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>上述例子中混合了 public 和 private 名称，成员函数包括 pure virtual, virtual, non-virtual 三种，只是为了强调接下来我们讨论的只和名称有关，和其它无关。</p><p>假设 derived class 内的 mf4 的实现代码部分像这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">void Derived::mf4()&#123;</span><br><span class="line">    ...</span><br><span class="line">    mf2();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当编译器看到名称 mf2，它会查找各个作用域。</p><ol><li>编译器首先查找 local 作用域（也就是 mf4 覆盖的作用域）</li><li>在那没找到任何名为 mf2，于是查找外围作用域，也就是 class Derived 覆盖的作用域</li><li>如果还是没找到任何东西名为 mf2，就再往外围移动，本例为 base class，在那编译器找到一个名为 mf2 的东西，于是就停止查找。</li></ol><p>如果 Base 内还是没有 mf2，就查找 Base 所在的  namespace（如果有的话），最后查找 global 作用域。</p><p>现在我们重载 mf1 和 mf3，并且添加一个新版 mf3 到 Derived 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">private:</span><br><span class="line">    int x;</span><br><span class="line">public:</span><br><span class="line">    virtual void mf1() = 0;</span><br><span class="line">    virtual void mf1(int);</span><br><span class="line">    virtual void mf2();</span><br><span class="line">    void mf3();</span><br><span class="line">    void mf3(double);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived:public Base&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void mf1();</span><br><span class="line">    void mf3();</span><br><span class="line">    void mf4();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=YzFkMTkwYjJlMzE4ODU4ZTZjNjcxYzIzNDU1Mjc1ZTZfUVpsV3RyeHdHWXphQ2R2ZWNIOWtUMjdxZUpnUGs0ZmpfVG9rZW46Ym94azQ3WFhrV21jZ21ZSnlJUEhweWJZUm9mXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>Base class 内所有名为 mf1 和 mf3 的函数都被 derived class 内的 mf1 和 mf3 函数遮掩掉了。从名称查找观点来看，Base::mf1 和 Base::mf3 不再被 Derived 继承</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">int x;</span><br><span class="line">...</span><br><span class="line">d.mf1();             // 没问题，调用 Derived::mf1</span><br><span class="line">d.mf1(x);            // 错误，因为 Derived::mf1 遮掩了 Base::mf1</span><br><span class="line">d.mf2();             // 没问题，调用 Base::mf2</span><br><span class="line">d.mf3();             // 没问题，调用 Derived::mf3</span><br><span class="line">d.mf3(x);            // 错误，因为 Derived::mf3 遮掩了 Base::mf3</span><br></pre></td></tr></table></figure><p>这些行为背后的理由是为了防止你在程序库或应用框架内建立新的 derived class 时附带地从疏远的 base class 继承重载函数。</p><h4 id="33-2-using-声明式">33.2 using 声明式</h4><p>不幸的是我们通常会想使用被遮掩的名称，可以这么做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">private:</span><br><span class="line">    int x;</span><br><span class="line">public:</span><br><span class="line">    virtual void mf1() = 0;</span><br><span class="line">    virtual void mf1(int);</span><br><span class="line">    virtual void mf2();</span><br><span class="line">    void mf3();</span><br><span class="line">    void mf3(double);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived:public Base&#123;</span><br><span class="line">public:</span><br><span class="line">    using Base::mf1;       // 让 Base class 内名为 mf1 和 mf3 的所有东西</span><br><span class="line">    using Base::mf3;       // 在 Derived 作用域内可见</span><br><span class="line">    virtual void mf1();    </span><br><span class="line">    void mf3();</span><br><span class="line">    void mf4();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Derived d;</span><br><span class="line">int x;</span><br><span class="line">...</span><br><span class="line">d.mf1();             // 没问题，调用 Derived::mf1</span><br><span class="line">d.mf1(x);            // 没问题，调用 Base::mf1</span><br><span class="line">d.mf2();             // 没问题，调用 Base::mf2</span><br><span class="line">d.mf3();             // 没问题，调用 Derived::mf3</span><br><span class="line">d.mf3(x);            // 没问题，调用 Base::mf3</span><br></pre></td></tr></table></figure><p>如果想使用被 Derived 遮掩的 Base 名称，可以使用 using 声明式，该 using 声明式可被继承。</p><h4 id="32-3-转交函数">32.3 转交函数</h4><p>加入在 private 继承下，如果我们只想继承某个被遮掩的函数，而不是以某个名字命名的所有函数，这个时候就不能使用 using。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Base &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void mf1();</span><br><span class="line">    virtual void mf1(int);</span><br><span class="line">    ...             // 与前相同</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Derived::private Base &#123;</span><br><span class="line">public:</span><br><span class="line">    virutal void mf1()&#123;    // 转交函数</span><br><span class="line">        Base::mf1();       // 暗自成为 inline</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line">Derived d;</span><br><span class="line">int x;</span><br><span class="line">d.mf1();              // 很好，调用了 Derived::mf1</span><br><span class="line">d.mf1(x);             // 错误！Base::mf1 被遮掩了 </span><br></pre></td></tr></table></figure><p>inline 转交函数的另一个用途是为那些不支持 using 声明式的老旧编译器提供访问被遮掩名称的方法。</p><h4 id="32-4-总结">32.4 总结</h4><p>derived classes 内的名称会遮掩 base classes 内的名称。</p><p>为了让被遮掩的名称再次被使用，可以使用 using 声明式或转交函数。</p><h3 id="条款-34：区分接口继承和实现继承">条款 34：区分接口继承和实现继承</h3><p>C++ 的 public 继承分为：</p><ul><li>函数接口(function interfaces)继承</li><li>函数实现(function implementations)继承</li></ul><p>现通过以下继承关系举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Shape&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void draw() const = 0;</span><br><span class="line">    virtual void error(const std::string&amp; msg);</span><br><span class="line">    int objectID() const;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Rectangle: public Shape &#123; ... &#125;;</span><br><span class="line">class Ellipse: public Shape &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>Shape 强烈影响所有以 public 形式继承它的 derived classes，因为以下方面：</p><ul><li>成员函数的接口总是被继承</li></ul><p>如条款 32 所说，public 继承意味着 is-a（是一种）。对 base class 为真的任何事情一定也对其 derived classes 为真。如果某个函数可以施行于某 class 身上，一定也可施行于其 derived classes 身上。</p><p>Shape 声明了三种类型的成员函数，分别是 pure virtual 函数，virtual 函数，non-virtual 函数。这些不同的声明分别表示什么呢？</p><p>首先考虑 pure virtual 函数 draw:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Shape&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void draw() const = 0;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该 pure virtual 函数具有两个突出特性：</p><ul><li>它们必须被任何“继承了它们”的具象 class 重新声明。</li><li>它们在抽象 class 中通常没有定义。</li></ul><p>把上述两个性质放在一起，我们就知道：</p><h4 id="34-1-声明一个-pure-virtual-函数的目的是为了让-derived-classes-只继承函数的接口">34.1 声明一个 pure virtual 函数的目的是为了让 derived classes 只继承函数的接口</h4><ul><li>Shape::draw 的声明式好像在对具象 derived classes 设计者说：“你必须提供一个 draw 函数，但我不干涉你怎么实现它。”</li><li>令人意外的一点是，我们可以为 pure virtual 函数提供定义，也就是可以为 Shape::draw 供应一份实现代码，但调用它的唯一途径是“调用时明确指出其 class 名称”：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Shape* ps = new Shape;       // 错误！Shape 是抽象的</span><br><span class="line">Shape* ps1 = new Rectangle;  // 没问题</span><br><span class="line">ps1-&gt;draw();                 // 调用 Rectangle::draw</span><br><span class="line">Shape* ps2 = new Ellipse;    // 没问题 </span><br><span class="line">ps2-&gt;draw();                 // 调用 Ellipse::draw</span><br><span class="line">ps1-&gt;Shape::draw();          // 调用 Shape::draw</span><br><span class="line">ps2-&gt;shape::draw();          // 调用 Shape::draw</span><br></pre></td></tr></table></figure><p>为 pure virtual 函数提供定义用途有限，但接下来你会看到，它可以实现一种机制，为 (非纯) impure virtual 函数提供更平常更安全的缺省实现。</p><p>Base class 定义一个 virtual 函数，Derived class 可以选择实现该虚函数，也可以选择不实现该虚函数，当选择不实现它时，Base class 的相应 virutal 函数作为一个缺省实现版本。</p><h4 id="34-2-声明简朴的（非纯）impure-virtual-函数的目的，是让-derived-classes-继承该函数的接口和缺省实现">34.2 声明简朴的（非纯）impure virtual 函数的目的，是让 derived classes 继承该函数的接口和缺省实现</h4><p>考虑 Shape::error 这个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void error(const std::string&amp; msg);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该接口表示，每个 class 都必须支持一个“当遇上错误时可调用”的函数，但每个 class 可自由处理错误。如果某个 class 不想针对错误做出任何特殊行为，它可以退回到 Shape class 提供的缺省错误处理行为。</p><p>Shape::error 的声明式告诉 Derived classes 的设计者：“你必须支持一个 error 函数，但如果你不想自己写一个，可以使用 Shape class 提供的缺省版本”。</p><p>但是，允许 impure virtual 函数同时指定函数声明和函数缺省行为，有可能造成危险。为了探讨原因，下以 XYZ 航空公司的飞机继承体系举例，该公司只有 A 型和 B 型两种飞机，两者都以相同方式飞行。因此 XYZ 设计出这样的继承体系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Airport &#123; ... &#125;;  // 用以表示机场</span><br><span class="line">class Airplane &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fly(const Airport&amp; destination);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Airplane::fly(const Airport&amp; destination)&#123;</span><br><span class="line">    缺省代码，将飞机飞至指定的目的地</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ModelA: public Airplane &#123; ... &#125;;</span><br><span class="line">class ModelB: public Airplane &#123; ...&#125;;</span><br></pre></td></tr></table></figure><p>因为原则上“不同型号飞机需要不同的 fly 实现”，Airplane 被声明为 virtual，然而为了避免在 ModelA 和 ModelB 中撰写相同代码，缺省飞行行为由 Airplane::fly 提供，它同时被 ModelA 和 ModelB 继承。</p><p>现在假设 XYZ 决定购买一种新式 C 型飞机，C 型和 A 型及 B 型的飞行方式不同。XYZ 公司的程序员在继承体系中针对 C 型飞机添加了一个 class，但由于他们着急让新飞机上线服务，竟忘了重新定义 fly 函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class ModelC: public Airplane&#123;</span><br><span class="line">    ...                   // 未声明 fly 函数</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 然后在代码中有一些诸如此类的动作</span><br><span class="line">Airport PDX(...);      </span><br><span class="line">Airplane* pa = new ModelC;</span><br><span class="line">...</span><br><span class="line">pa-&gt;fly(PDX);          // 调用 Airplane::fly</span><br></pre></td></tr></table></figure><p>这样将酿成大灾难，这个程序试图以 ModelA 或 ModelB 的飞行方式来飞 ModelC。</p><p>问题不在 Airplane::fly 有缺省行为，而在于 ModelC 未重写该虚函数，而是继承了该缺省行为。幸运的是我们可以轻易做到“提供缺省实现给 derived classes，但除非它们明白要求否则面谈”，此方法在于切断“virtual 函数接口”和其“缺省实现”之间的连接。下面是一种做法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Airplane &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fly(const Airport&amp; destination) = 0;</span><br><span class="line">    ...</span><br><span class="line">protected：</span><br><span class="line">    void defaultFly(const Airport&amp; destination);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Airplane::defaultFly(const Airport&amp; destination)&#123;</span><br><span class="line">    缺省行为，将飞机飞至指定的目的地</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Airplane::fly 已被改为一个 pure virtual 函数，只提供飞行接口，其缺省行为只出现在 Airplane class 中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class ModelA: public Airplane &#123; </span><br><span class="line">public:</span><br><span class="line">    virtual void fly(const Airport&amp; destination)&#123;</span><br><span class="line">        defaultFly(destination);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">class ModelB: public Airplane &#123; </span><br><span class="line">public:</span><br><span class="line">    virtual void fly(const Airport&amp; destination)&#123;</span><br><span class="line">        defaultFly(destination);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>现在 ModelC 不可能意外继承不正确的 fly 实现代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class ModelC: public Airplane&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fly(const Airport&amp; destination);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void ModelC::fly(const Airport&amp; destination)&#123;</span><br><span class="line">    将 C 型飞机飞至目的地</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 Airplane::defaultFly 现在成了 protected，因为它是 Airplane 及其derived classes 的实现细目。乘客应该只在意飞机能不能飞，不在意它们怎么飞。</p><p>有些人也反对以不同的函数分别提供接口和缺省实现，他们担心因过度雷同的函数名称而引起的 class 命名空间污染问题，但他们也同意，接口和缺省实现应该分开。这个矛盾应该如何解决呢？我们可以利用“pure virtual 函数必须在 derived classes 中重新声明，但他们也可以拥有自己的实现”这一事实。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Airplane &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fly(const Airport&amp; destination) = 0;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Airplane::fly(const Airport&amp; destination)   // pure virtual 函数实现</span><br><span class="line">&#123;</span><br><span class="line">    缺省行为，将飞机飞至目的地</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class ModelA: public Airplane &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fly(const Airport&amp; destination)&#123;</span><br><span class="line">        Airplane::fly(destination);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ModelB: public Airplane &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fly(const Airport&amp; destination)&#123;</span><br><span class="line">        Airplane::fly(destination);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class ModelC : public Airplane &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void fly(const Airport&amp; destination);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void ModelC::fly(const Airport&amp; destination)&#123;</span><br><span class="line">    将 C 型飞机飞至指定的目的地</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="34-3-声明-non-virtual-函数的目的是为了令-derived-classes-继承函数的接口及一份强制性实现">34.3 声明 non-virtual 函数的目的是为了令 derived classes 继承函数的接口及一份强制性实现</h4><p>最后，讨论 Sharp 的 non-virtual 函数 objectID:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Shape &#123;</span><br><span class="line">public:</span><br><span class="line">    int objectID() const;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果成员函数是 non-virtual 函数，意味着它并不打算在 derived classes 中有不同的行为。</p><p>可以把 Sharpe::objectID 的声明看作是：“每个 Sharp 对象都有一个用来产生对象识别码的函数；此识别码总是采用相同计算方法，该方法由 Sharpe::objectID 的定义式决定，任何 derived class 都不应该尝试改变其行为”。</p><h4 id="34-4-总结">34.4 总结</h4><p>接口继承和实现继承不同。在 public 继承下，derived classes 总是继承 base class 的接口</p><p>pure virtual 函数只具体指定接口继承</p><p>简朴的（非纯）impure virtual 函数具体指定接口继承及缺省实现继承。</p><p>non-virtual 函数具体指定接口继承以及强制性实现继承。</p><h3 id="条款-35：考虑-virtual-函数以外的其他选择">条款 35：考虑 virtual 函数以外的其他选择</h3><p>现在为一个游戏内的人物设计一个继承体系，现提供一个成员函数 healthValue，它返回一个整数，表示人物的健康程度。不同的人物有不同的方式计算他们的健康程度，将 healthValue 声明为 virtual 是很常见的做法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class GameCharacter &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual int healthValue() const;    // 返回人物的健康指数</span><br><span class="line">    ...                                 // derived classes 可重新定义它</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为将 healthValue 声明为 pure virtual，是想为其保留一个默认实现。从某些角度来看上述设计存在某些弱点，现在考虑一些其他解法。</p><h4 id="35-1-由-Non-Virtual-Interface-手法实现-Template-Method-模式（模板方法模式）">35.1 由 Non-Virtual Interface 手法实现 Template Method 模式（模板方法模式）</h4><p>关于模板方法模式可以参考：<a href="https://refactoringguru.cn/design-patterns/template-method">https://refactoringguru.cn/design-patterns/template-method</a></p><p>所谓 Template Method 模式，当多个派生类存在结构相似的代码时，可以将共同的代码提取到超类中，将这些代码比喻为一个大型算法，不同的派生类可以重写这个大型算法的一部分。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class GameCharacter &#123;</span><br><span class="line">public:</span><br><span class="line">    int healthValue() const                    // derived classes 不重新定义它</span><br><span class="line">    &#123;</span><br><span class="line">        ...                                    // 做一些事前工作</span><br><span class="line">        int retVal = doHealthValue();     </span><br><span class="line">        ...                                    // 做一些事后工作</span><br><span class="line">        return retVal;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    virtual int doHealthValue() const          // derived classes 可重新定义它</span><br><span class="line">    &#123;</span><br><span class="line">        ...                                    // 缺省算法，计算健康指数</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上述这样令 “客户通过 public non-virtual 成员函数间接调用 private virtual 函数”称为 non-virtual interface（NVI）手法。我们把这个 non-virtual 函数(healthValue) 称为 virtual 函数的外覆器(wrapper)。</p><p>这个手法的优点：</p><ul><li>调用 doHealthValue 之前可以做一些事前工作：锁定互斥器，日志记录，验证 class 的约束条件，验证函数先诀条件</li><li>调用 doHealthValue 之后做一些事后工作：解除互斥器锁定，验证函数的事后条件，再次验证 class 的约束条件等等。</li></ul><p>在 NVI 手法下 virtual 函数不一定得是 private。某些 class 继承体系要求 derived class 在 virtual 函数的实现内必须调用其  base class 的某些属性或方法，virtual 函数就必须是 protected。</p><h4 id="35-2-由-std-function-完成-Strategy-模式">35.2 由  std::function 完成 Strategy 模式</h4><h5 id="函数指针法">函数指针法</h5><p>另一个主张是：“人物健康指数与人物类型无关”，那这样的计算就不需要“人物”这个 成分，例如我们可能要求每个人物的构造函数接受一个指针，指向一个健康计算函数，可以调用该函数进行实际的计算：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class GameCharacter;           // 前置声明</span><br><span class="line">//以下函数是计算健康指数的缺省算法</span><br><span class="line">int defaultHealthCalc(const GameCharacter&amp; gc);</span><br><span class="line">class GameCharacter &#123;</span><br><span class="line">public:</span><br><span class="line">    typedef int (*HealthCalcFunc)(const GameCharacter&amp;);</span><br><span class="line">    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc):healthFunc(hcf)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    int healthValue() const;</span><br><span class="line">    &#123; return healthFunc(*this); &#125;</span><br><span class="line">private:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个做法是常见的 Strategy 设计模式的简单应用，相比使用 virtual 函数，它提供了某些有趣弹性：</p><ul><li>同一人物类型的不同实体可以有不同的健康计算函数：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class EvilBadGuy: public GameCharacter &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit EvilBadGuy(HealthCalcFunc hcf = defaultHealthCalc):GameCharacter(hcf)</span><br><span class="line">    &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line">int loseHealthQuickly(const GameCharacter&amp;);    // 健康指数计算函数1</span><br><span class="line">int loseHealthSlowly(const GameCharacter&amp;);     // 健康指数计算函数2</span><br><span class="line">EvilBadGuy edg1(loseHealthQuickly);</span><br><span class="line">EvilBadGuy edg2(loseHealtySlowly);              // 相同类型的人物搭配不同的健康计算方式</span><br></pre></td></tr></table></figure><ul><li>某已知人物的健康计算函数可以在运行期变更。例如 GameCharacter 可提供一个成员函数 setHealthCalculator，用来替代当前的健康指数计算函数</li></ul><h5 id="std-function-对象">std::function 对象</h5><p>基于函数指针的做法有点死板，为什么一定是个函数指针，而不是函数对象；为不是不能是个成员函数。</p><p>现在我们不再使用函数指针，而是改用一个类型为 std::function 的对象，这样的对象可持有任何可调用物（函数指针，函数对象，成员函数指针），例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class GameCharacter;           // 前置声明</span><br><span class="line">//以下函数是计算健康指数的缺省算法</span><br><span class="line">int defaultHealthCalc(const GameCharacter&amp; gc);</span><br><span class="line">class GameCharacter &#123;</span><br><span class="line">public:</span><br><span class="line">    typedef std::function&lt;int (const GameCharacter&amp;)&gt; HealthCalcFunc;</span><br><span class="line">    explicit GameCharacter(HealthCalcFunc hcf = defaultHealthCalc):healthFunc(hcf)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    int healthValue() const;</span><br><span class="line">    &#123; return healthFunc(*this); &#125;</span><br><span class="line">private:</span><br><span class="line">    HealthCalcFunc healthFunc;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>和前一个设计几乎相同，唯一的不同是 GameCharacter 持有一个 std::function 对象，相当于一个指向函数的泛化指针，它可以提供更多的弹性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">short calcHealth(const GameCharacter&amp;);   // 健康计算函数，注意其返回类型是 short</span><br><span class="line"></span><br><span class="line">struct HealthCalculator&#123;                  // 为计算健康而设计的函数对象</span><br><span class="line">    int operator()(const GameCharacter&amp;) const</span><br><span class="line">    &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class GameLevel &#123;</span><br><span class="line">public：</span><br><span class="line">    float health(const GameCharacter&amp;) const; // 成员函数，用以计算健康</span><br><span class="line">    ... </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class EvilBadGuy: public GameCharacter &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit EvilBadGuy(HealthCalcFunc hcf = defaultHealthCalc):GameCharacter(hcf)</span><br><span class="line">    &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class EyeCandyCharacter: public GameCharacter &#123; // 另一个人物类型，假设构造函数与 EvilBadGuy 同</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">EvilBadGuy ebg1(calcHealth);    // 人物1，使用某个函数计算健康指数</span><br><span class="line">EyeCandyCharacter eccl(HealthCalculator());   // 人物 2，使用某个函数对象</span><br><span class="line"></span><br><span class="line">GameLevel currentLevel;</span><br><span class="line">EvilBadGuy egb2(</span><br><span class="line">    std::bind(&amp;GameLevel::health, &amp;currentLevel, _1) </span><br><span class="line">); // 人物3，使用某个成员函数</span><br></pre></td></tr></table></figure><p>GameLevel::health 接受两个参数，一个是  this 指针，绑定到 &amp;currentLevel，另一个是 const GameCharacter&amp;，_1 表示占位符，即调用 healthFunc 传入的第一个参数。</p><h4 id="35-3-古典的-Strategy-模式">35.3 古典的 Strategy 模式</h4><p>古典的 Strategy 做法会把健康计算函数做成一个分离的继承体系中的 virtual 成员函数，如下 UML 所示：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=OTdkMjQxYWMxZmU2MDE1Zjg5NjMyOTYzZDExMmNkZTBfUEdQN3JHdWd4WEJid1RiUEVhQlNDYlFLVmNGNGYzNEtfVG9rZW46Ym94azRCdkQ0c0RLcHVlS3lBTG1zTlFpS3FnXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>对应的代码如下：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NWEzNzI1ZDYyNmRmYzM1MDQ1OGQ2YTU0N2RmOGJkZGRfSlBJeFZKOXJlSGpNUlNmY0VQOFpYZWh0RnpNTlNVcFpfVG9rZW46Ym94azRUWjVMUmFOUTZwQzc5WEdETkJPakdlXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>本条款的根本忠告是，当为解决问题而寻找某个设计方法时，不妨考虑 virtual 函数的替代方案：</p><ul><li>使用 non-virtual interface（NVI）手法，那是 Template Method 设计模式的一种特殊形式，</li><li>将 virtual 函数替换为 “函数指针成员变量”，这是 Strategy 设计模式的一种。</li><li>以 std::function 成员变量替换 virtual 函数，这也是 Strategy 设计模式的传统实现手法。</li><li>将继承体系内的 virtual 函数替换为另一个继承体系内的 virtual 函数，这是 Strategy 设计模式的传统实现手法。</li></ul><h3 id="条款-36：绝不重新定义继承而来的-non-virtual-函数">条款 36：绝不重新定义继承而来的 non-virtual 函数</h3><p>观察以下例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class B &#123;</span><br><span class="line">public:</span><br><span class="line">    void mf();</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class D: public B &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>先定义一个类型为 D 的对象 <code>D x;</code></p><p>现有以下行为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B* pB = &amp;x;         // 获得一个指针指向 x</span><br><span class="line">pB-&gt;mf();           // 经指针调用 mf</span><br></pre></td></tr></table></figure><p>异于以下行为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">D* pD = &amp;x; </span><br><span class="line">pD-&gt;mf();</span><br></pre></td></tr></table></figure><p>按照正常的逻辑，两者都通过对象 x 调用成员函数 mf，所以他们的行为应该相同，是这样吗？</p><p>但是，如果 mf 是个 non-virtual 函数，而 D 定义有自己的 mf 版本，两次调用的行为就不一样了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class D: public B &#123;</span><br><span class="line">public:</span><br><span class="line">    void mf();      // 遮掩了 B::mf</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">pB-&gt;mf();           // 调用 B::mf</span><br><span class="line">pD-&gt;mf();           // 调用 D::mf</span><br></pre></td></tr></table></figure><p>造成此行为的原因是，non-virtual 函数，如 B::mf 和 D::mf 都是静态绑定，意思是，由于 pB 被声明为 pointer-to-B，通过 pB 调用的 non-virtual 函数永远是 B 所定义的版本，即使 pB 指向一个类型为“B 的派生对象”。</p><p>另一方面，virtual 函数却是动态绑定，如果 mf 是个 virtual 函数，无论是通过 pB 或 pD 调用 mf，都会导致调用 D::mf，因为 pB 和 pD 真正指的都是一个类型为 D 的对象</p><p>所谓的 public 继承意味 is-a（是一种）关系，对于 B 和 D 以及 non-virtual 成员函数 B::mf ：</p><ul><li>适用于 B 对象的每一件事，也适用于 D 对象，因为每个 D 对象都是一个 B 对象</li><li>B 的 derived classes 一定会继承 mf 的接口和实现，因为 mf 是 B 的一个 non-virtual 函数</li></ul><p>现在如果 D 重新定义 mf，上述设计就会出现矛盾。</p><p>总之，任何情况下都不该重新定义一个继承而来的 non-virtual 函数。</p><h3 id="条款-37：绝不重新定义继承而来的缺省参数值">条款 37：绝不重新定义继承而来的缺省参数值</h3><p>本条款成立的理由是：virtual 函数是动态绑定，而缺省参数值却是静态绑定。</p><h4 id="37-1-静态绑定">37.1 静态绑定</h4><p>对象的所谓静态，就是它在程序中被声明时所采用的类型。考虑以下继承体系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// 一个用以描述几何形状的 class</span><br><span class="line">class Shape &#123;</span><br><span class="line">public:</span><br><span class="line">    enum ShapeColor &#123;Red, Green, Blue &#125;;</span><br><span class="line">    // 所有形状都必须提供一个函数，用来绘出自己</span><br><span class="line">    virtual void draw(ShapeColor color = Red) const = 0;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Rectangle: public Shape &#123;</span><br><span class="line">public:</span><br><span class="line">    // 注意，赋予了不同的参数值，这很糟糕</span><br><span class="line">    virtual void draw(ShapeColor color = Green) const;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Circle: public Shape&#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void draw(ShapeColor color) const;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这个继承体系图如下：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=MzVmZjE1YmRhNjQzZmVlYzlhMTg3NDg4Y2Y3Y2M3ZWVfZVo2dzh1V05hYndBN2pmRzhud1ByUjc5VnBPTTBiTnNfVG9rZW46Ym94azR6N2ZPQUx6RHVKZHY5OVI3bkVmTDBlXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>现在考虑这些指针：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Shape* ps;                 // 静态类型为 Shape*</span><br><span class="line">Shape* pc = new Circle;    // 静态类型为 Shape*</span><br><span class="line">Shape* pr = new Rectangle; // 静态类型为 Shape*</span><br></pre></td></tr></table></figure><p>上述的 ps, pc, pr 都被声明为 pointer-to-Shape 类型，不论他们真正指向什么，它们的静态类型都是 Shape*</p><h4 id="37-2-动态绑定">37.2 动态绑定</h4><p>所谓的动态类型是指：“目前所指向对象的类型”，也就是说，动态类型可以表现出一个对象将会有什么行为。就上述例子，pc 的动态类型为 Circle*，pr 的动态类型为 Rectangle*，ps 没有动态类型，因为它尚未指向任何对象。</p><p>动态类型可以在程序执行过程中改变（通常经由赋值动作）：</p><p>ps = pc;       //  ps 的动态类型是 Circle*</p><p>ps = pr;       //  ps 的动态类型是 Rectangle*</p><p>virtual 函数是动态绑定而来，调用一个 virtual 函数时，究竟调用哪一份函数实现代码，取决于发出调用的那个对象的动态类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pc-&gt;draw(Shape::Red);        // 调用 Circle::draw(Shape::Red)</span><br><span class="line">pr-&gt;draw(Shape::Red);        // 调用 Rectangle::draw(Shape::Red)     </span><br></pre></td></tr></table></figure><h4 id="37-3-带有缺省参数值的-virtual-函数">37.3 带有缺省参数值的 virtual 函数</h4><p>virtual 函数是动态绑定，而缺省参数值却是动态绑定。意思是可能会在“调用一个定义于 derived class 内的virtual 函数”的同时，却使用 base class 为它指定的缺省参数值：</p><p>pr-&gt;draw();            // 调用 Rectangle::draw(Shape::Red)!</p><p>此例中，pr 的动态类型是 Rectangle*，所以调用的是 Rectangle 的 virtual 函数。Rectangle::draw 函数的缺省参数值应该是 GREEN，但由于 pr 的静态类型是 Shape*，所以此调用的缺省参数值来自 Shape class 而非 Rectangle class!</p><p>为什么 C++ 坚持这种做法呢？答案在于运行期效率。如果缺省参数值是动态绑定，编译器就必须有某种办法在运行期为 virtual 函数决定适当的缺省参数值。这比目前所实行的“在编译器决定”的机制更慢且更复杂。</p><p>如果现在尝试遵守这条规则，并且同时提供缺省参数值给 base 和 derived classes ，又会发生什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Shape&#123;</span><br><span class="line">public:</span><br><span class="line">    enum ShapeColor &#123;Red, Green, Blue &#125;;</span><br><span class="line">    virtual void draw(ShapeColor color = Red) const = 0;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Rectangle: public Shape &#123;</span><br><span class="line">public:</span><br><span class="line">    virtual void draw(ShapeColor color = Red) const;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看出，代码重复了，代码还带着相依性，如果 Shape 内的缺省参数值改变了，所有“重复给定缺省参数值”的那些 derived classes 也必须改变，否则它们又会导致“重复定义一个继承而来的缺省参数值”，那怎么办？</p><p>聪明的做法是考虑替代设计，条款 35 列了不少 virtual 函数的替代设计，其中之一是 NVI（non-virtual interface）手法：令 base class 内的一个 public non-virtual 函数调用 private virtual 函数，后者可被 derived classes 重新定义。这里可以让 non-virtual 函数指定缺省参数，而 private virtual 函数负责真正的工作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Shape&#123;</span><br><span class="line">public:</span><br><span class="line">    enum ShapeColor &#123;Red, Green, Blue&#125;;</span><br><span class="line">    void draw(ShapeColor color = Red) const       // 如今它是 non-virtual</span><br><span class="line">    &#123;</span><br><span class="line">        doDraw(color);                            // 调用一个 virtual</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">private:</span><br><span class="line">    virtual void doDraw(ShapeColor color) const=0;  // 真正的工作在此完成</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Rectangle: public Shape &#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">private:</span><br><span class="line">    virtual void doDraw(ShapeColor color) const;      // 不需要指定缺省参数值</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="37-4-总结">37.4 总结</h4><p>绝对不要重新定义一个继承而来的缺省参数值，因为缺省参数值都是静态绑定，而 virtual 函数却是动态绑定。</p><h3 id="条款-38：通过复合塑模出-has-a-或-根据某物实现出">条款 38：通过复合塑模出 has-a 或&quot;根据某物实现出&quot;</h3><p>复合（composition）是类型之间的一种关系，当某种类型的对象内含它种类型的对象，便是这种关系。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Address &#123; ... &#125;;    // 某人的住址</span><br><span class="line">class PhoneNumber &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">class Person &#123;</span><br><span class="line">public:</span><br><span class="line">    ...</span><br><span class="line">private:</span><br><span class="line">    std::string name;    // 合成成分物</span><br><span class="line">    Address address;</span><br><span class="line">    PhoneNumber voiceNumber</span><br><span class="line">    PhoneNumber faxNumber;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>条款 32 说的是，“public 继承”带有 is-a（是一种）的意义。</p><p>复合也有它自己的意义，实际上它有两个意义：</p><ul><li>has-a（有一个）</li><li>is-implemented-in-terms-of（根据某物实现出）</li></ul><p>当涉及到复合时，我们需要在软件中处理两个不同的领域：</p><ol><li>程序中的对象其实相当于我们所塑造的世界中的某些事物，例如人，汽车，一张张视频画面等等。这样的对象属于应用域（application domain）部分。</li><li>其他对象则纯粹是实现细节上的人工制品，像是缓冲区（buffers）,互斥器（mutexes），查找树（search trees）等等。这些对象相当于我们软件的实现域（implementation domain）。</li></ol><p>当复合发生于应用域内的对象之间，表现出 has-a 的关系；当它发生于实现域内则是表现 is-implemented-in-terms-of 的关系。</p><p>上述的 Person class 是一种 has-a 关系。Person 有一个名称，一个地址，以及语音和传真两笔电话号码。我们不会认为“人是一个名称”或“人是一个地址”，而会认为“人有一个名称”和“人有一个地址”。这就是 is-a 和 has-a 的关系。</p><p>比较麻烦的是区分 is-a（是一种）和 is-implemented-in-term-of（根据某物实现出）这两种对象关系。</p><h4 id="38-1-问题">38.1 问题</h4><p>假设我们需要一个 templates，希望制造出一组 classes 用来表示由不重复对象组成的 sets。</p><p>可能最容易想到的就是标准程序库提供的 set template。不幸的是 set 的每个元素都由“三个指针组成”，会导致额外的开销。因为 sets 通常以平衡查找树实现而来，使它们在查找，插入，删除元素时保证拥有对数时间效率。这个设计适用于速度比空间重要。</p><h4 id="38-2-错误做法">38.2 错误做法</h4><p>当我们对空间的要求大于对速度的要求时，就需要自己去写个 template。实现 sets 的方法太多，其中之一就是在底层采用 linked lists。而且标准库有一个 list template，于是我们决定复用它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;        // 将 list 应用于 Set 。错误做法</span><br><span class="line">class Set::public std::list&lt;T&gt; &#123; ... &#125;;</span><br></pre></td></tr></table></figure><p>条款 32 告诉我们，public 继承意味着 is-a （是一种）。意味着 D 是一种 B，对 B 为真的每一件事情对 D 也应该为真。对于上述例子，list 可以包含重复元素，而 Set 不可以包含重复元素。因此这两个 classes 之间并非 is-a 的关系，所以 public 继承不适合用来塑模它们。</p><h4 id="38-3-正确做法">38.3 正确做法</h4><p>正确做法是 Set 对象可根据一个 list 对象实现出来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt;             // 将 list 应用于 Set，正确做法</span><br><span class="line">class Set &#123;</span><br><span class="line">public:</span><br><span class="line">    bool member(const T&amp; item) const;</span><br><span class="line">    void insert(const T&amp; item);</span><br><span class="line">    void remove(const T&amp; item);</span><br><span class="line">    std::size_t size() const;</span><br><span class="line">private:</span><br><span class="line">    std::list&lt;T&gt; rep;              // 用来表述 Set 的数据</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="38-4-总结">38.4 总结</h4><p>复合（composition）的意义和 public 继承完全不同。</p><p>在应用域（application domain），复合意味 has-a（有一个）。在实现域（implementation domain），复合意味 is-implemented-in-terms-of（根据某物实现出）</p><h3 id="条款-39：明智而审慎地使用-private-继承">条款 39：明智而审慎地使用 private 继承</h3><p>private 继承意味着什么？观察下列代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123; ... &#125;;</span><br><span class="line">class Student:private Person &#123; ... &#125;;</span><br><span class="line">void eat(const Person&amp; p);              // 任何人都会吃</span><br><span class="line">void study(const Student&amp; s);           // 只有学生才在校学习</span><br><span class="line"></span><br><span class="line">Person p;              // p 是人</span><br><span class="line">Studeng s;             // s 是学生</span><br><span class="line"></span><br><span class="line">eat(p);                // 没问题，p 是人，会吃</span><br><span class="line">eat(s);                // 错误，难道学生不是人？</span><br></pre></td></tr></table></figure><p>显然 private 继承并不意味着 is-a 关系，那么它意味着什么？</p><p>如果 classes 之间的继承关系是 private：</p><ol><li>编译器不会将一个 derived class 对象（例如 Student）转换为一个 base class 对象（例如 Person）。这就是通过 s 调用 eat 会失败的原因。</li><li>由 private base class 继承而来的所有成员，在 derived class 中都会变成 private 属性。</li></ol><p>Private 继承意味着 implemented-in-terms-of（根据某物是现出）。如果让 class D 以 private 形式继承 class B，意思是采用 class B 内已经备妥的某些特性，不是因为 B 对象和 D 对象存在任何观念上的关系。</p><p>Private 继承纯粹只是一种实现技术，借用条款 34 提出的术语，private 继承意味着只有实现部分被继承，接口部分因略去。如果 D 以 private 形式继承 B，意思是 D 对象根据 B 对象实现而得，在没有其他意蕴了。Private 继承在软件“设计”层面没有意义，其意义只在软件实现层面。</p><p>Private 继承意味着 is-implemented-in-terms-of（根据某物实现出），复合（条款 38）的意义也是这样。那我们在两者之间如何取舍呢？答案是：尽可能使用复合，必要时才使用 private 继承，何时算必要呢？</p><ol><li>主要当 protected 成员 or virtual 函数被牵扯进来时。</li><li>当空间方面的利害关系足以踢翻 private 继承。</li></ol><h4 id="问题">问题</h4><p>现在我们有以下需求：我们有一个类 Widget class，我们需要记录每个成员函数的被调用次数，为完成这项工作，我们需要设定某种定时器，使我们知道收集统计数据的时候是否到了。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Timer &#123;</span><br><span class="line">public:</span><br><span class="line">    explicit Timer(int tickFrequency);</span><br><span class="line">    virtual void onTick() const;    // 定时器每滴答一次</span><br><span class="line">    ...                             // 此函数就被自动调用一次</span><br><span class="line">                              </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="private-继承">private 继承</h4><p>为了让 Widget 重新定义 Timer 内的 virtual 函数，Widget 必须继承自 Timer。public 继承显然不合适，因为 Widget 并不是个 Timer。我们必须 private 继承：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class Widget: private Timer&#123;</span><br><span class="line">private:</span><br><span class="line">    virtual void onTick() const;  // 查看 Widget 的数据等等</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="复合">复合</h4><p>要以复合取代 private 继承，只需在 Widget 内声明一个嵌套式 private class，后者以 public 形式继承 Timer 并重新定义 onTick，然后放一个这种类型的对象于 Widget 内。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">private:</span><br><span class="line">    class WidgetTimer: public Timer &#123;</span><br><span class="line">    public:</span><br><span class="line">        virtual void onTick() const;</span><br><span class="line">        ...</span><br><span class="line">    &#125;;</span><br><span class="line">    WidgetTimer timer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NTA4YzA3OWE2YzQ0OGZiZGJjOTczZTk2YWJlYzBhOGVfYnA0RzVqcVFwajdHRTJaMVlKaHN0OEFpeEtLWHV2VXdfVG9rZW46Ym94azRjM1NtWkViODBFZ2FVVVZjcGtreTdiXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>提出本例子也是为了说明一个道理，训练自己思考多种做法是值的的。</p><p>选择复合而不是 private 的理由如下：</p><ol><li>这样可以让 Widget 拥有 derived classes，但同时可以阻止 derived classes 重新定义 onTick。（条款  35 曾说，derived classes 可以重新定义 virtual 函数）。但如果 WidgetTimer 是 Widget 内部的一个 private 成员并继承 Timer，Widget 的 derived class 将无法取用 WidgetTimer，因此无法继承它或重新定义它的 virtual 函数。这个方法可以用来模拟“阻止 derived classes 重新定义 virtual 函数”。</li><li>将 Widget 的编译依存性降至最低。如果 Widget 继承 Timer，当 Widget 被编译时 Timer 的定义必须可见。但如果 WidgetTimer 移出 Widget 之外而 Widget 内含指针指向一个 WidgetTimer，Widget 可以只带着一个简单的 WidgetTimer 声明式。</li></ol><p>为什么使用 private 继承：</p><ol><li>一个类想成为一个 derived class 且想访问一个 base class 的 protected 成分，或为了重新定义一或多个 virtual 函数。这时候两个 classes 之间的概念关系其实是 is-implemented-in-terms-of（根据某物实现出）而非 is-a。</li><li>另一种情况较为激进，只适用于所处理的 class 不带任何数据。这样的 class 没有 non-static 成员变量，没有 virtual 函数，也没有 virtual base classes。于是这种所谓的 empty classes 对象不使用任何空间，因为没有任何隶属于对象的数据需要存储。然后由于技术上的理由，C++ 里凡是独立对象都必须有非零大小。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Empty &#123;&#125;;     // 没有数据</span><br><span class="line"></span><br><span class="line">class HoldsAnInt &#123;</span><br><span class="line">private:</span><br><span class="line">    int x;</span><br><span class="line">    Empty e;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br></pre></td></tr></table></figure><p>sizeof(HoldsAnInt) &gt; sizeof(int)，在大多数编译器中 sizeof(Empty)=1，对于这样的“大小为零的独立对象”，C++ 官方默默安插一个 char 到空对象内。</p><p>上述所谓的独立，其对立面非独立指的是 derived class 对象内的 base class 成分：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class HoldsAnInt:private Empty &#123;</span><br><span class="line">private:</span><br><span class="line">    int x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>几乎可以确定</p><p>sizeof(HoldsAnInt) &gt; sizeof(int)。这就是所谓的 EBO（empty base optimization：空白基类最优化）：这个性质对于程序库开发人员而言可能有用，由于其客户特别在意空间。EBO 一般只在单一继承下可行。</p><p>现实中的 “empty” classes，并不真的是 empty，虽然它们没有 non-static 成员变量，但却往往含有 typedefs，enums，static 成员变量，或 non-virtual 函数。</p><p>STL 许多技术用到 empty classses，其中内含有用的成员（通常是 typedefs），包括 base classes unary_function 和 binary_function，这些是“用户自定义函数对象”通常会继承的 classes。</p><h4 id="总结-10">总结</h4><p>Private 继承意味着 is-implemented-in-terms of（根据某物实现出）。它通常比复合（composition）的级别低。当 derived classes 需要访问 protected base class 的成员，或者需要重新定义继承而来的 virtual 函数时</p><p>和复合不同，private 继承可以造成 empty base 最优化。</p><h3 id="条款-40：明智而审慎地使用多重继承">条款 40：明智而审慎地使用多重继承</h3><p>多重继承指继承一个以上的 base classes，这些 base classes 又有更高级的 base classes。某种情况下可能导致钻石继承问题。</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=OWMyYWMyMGIzNzM4ZWI2ODAxYmQzOGY1ODRlOGI4NGNfbUJCcjhsWTloeDJEc2Q5dU1rbzBRVUdsR0RrV0ZRdENfVG9rZW46Ym94azQyaXFoV2FOMlhTUElsWHR2UDdJb2pnXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>任何时候，如果某一个继承体系中某个 base class 和某个 derived class 之间有一条以上的相通路线，就必须面对以下问题：</p><ol><li>是否让 base class 内的成员经由每一条路被复制，假设 File class 有个成员变量 fileName，这样 IOFile 将有两份 fileName。</li><li>从现实角度看， IOFile 对象只该有一个文件名称，所以它继承自两个 base classes 而来的 fileName 不该重复。</li></ol><p>C++ 对于这两个方案都支持，但其默认做法是方案1。如果想要方案2，就必须让带有此数据的 class（File）成为一个 virtual base class。为了这样做，必须令所有直接继承自它的 classes 采用“virtual 继承”：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=MzZlNWU1M2U5NDAyNmIxZTM4YzY4MjA4Mjg4NzJlYmZfdWxlNzEyUjAzYW5vS0RpWkNsOFo5SzJHNU16cGlka1pfVG9rZW46Ym94azRQQnlEZ1R2RkpzSlRha0hMUzhhakFjXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>注意：使用 virutal 继承的那些 classes 所产生的对象往往比使用 non-virtual 继承的对象体积更大，访问 virtual base classes 的成员变量时，也比访问 non-virtual base classes 的成员变量速度慢。</p><p>支配 &quot;virtual base classes 初始化&quot;的规则比起 non-virtual bases 的情况更复杂且不直观。virtual base 的初始化责任是由继承体系中的最低层 class 负责。这表明：</p><ul><li>classes 若派生自 virtual bases 而需要初始化，必须明确其 virtual bases——不论那些 bases 距离多远</li><li>当一个新的 derived class 加入继承体系，它必须承担其 virtual bases 的初始化责任。</li></ul><p>建议：</p><ol><li>非必要不使用 virtual bases</li><li>如果必须使用 virtual base classes，尽可能避免在其中放置数据。这样就不涉及到这些 virtual bases 的初始化和赋值等行为。</li></ol><p>以下是一个使用多重继承的例子：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=MTcwYjViM2NhNmMxMDEzNjg1MjI2MDAzZmYzZmE5MTRfY2JsUUhZVEdaREZod00xTE4xMkRaaHpLUmJTWTAwZWlfVG9rZW46Ym94azRxTVl6bjVvNjNpT1FJQzBobHRGaVBoXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=YzJjNTA4M2U2ZGZjM2M1ZGUwYWE3MjhiZDI0OWM3NzlfQlZxbXprbk9ZQkVsT2lyaUthNk5heU91b0JoTUxkeVJfVG9rZW46Ym94azRlUXJLRWRzNnNkMmxPRm5ocEh5ZW1FXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>在 UML 图中这个设计看起来是这样：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=MGNkN2M0MzA3NWJmOGZiYjBlMDMxZDEwMDkxMTllODFfdXQ5cW5TZzdxUGRGT0tEV2hnajJtQlZvdG56Y3B2ak5fVG9rZW46Ym94azRtT2JpWVUzcWY2NnJ6eEc0ODJhaDJnXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>上述代码中的多重继承将“public 继承自某接口”和“private 继承自某实现”结合起来。</p><h4 id="总结-11">总结</h4><ul><li>多重继承比单一继承复杂。为了避免歧义，应该使用 virutal 继承。</li><li>virtual 继承会增加大小，速度，初始化复杂度等等成本。如果 virtual base classes 不带任何数据，将是最具实用价值的情况。</li><li>多重继承的典型用途如：涉及“public 继承某个 Interface class”和 &quot;private 继承某个协助实现的 class&quot;的两相组合。</li></ul><h2 id="七、模板与泛型编程">七、模板与泛型编程</h2><p>C++ templates 最初发展的动机是：建立“类型安全”的容器，如 vector，list 和 map。容器当然很好，但基于 templates 的泛型编程——写出的代码和其所处理的对象类型彼此独立则更好。</p><p>最终，人们发现，C++ template 机制自身是一部完整的图灵机：它可以被用来计算任何可计算的值。于是产生了模板元编程（template metaprogramming），创作出“在 C++ 编译器内执行并于编译完成时停止执行”的程序。</p><p>容器只是 C++ template 应用的一小部分，有一组核心观念一直支撑着所有基于 template 的编程，这些观念是本章讨论的焦点。</p><h3 id="条款-41：了解隐式接口和编译期多态">条款 41：了解隐式接口和编译期多态</h3><p>面向对象编程世界总是以显式接口（explicit interfaces）和运行期多态（runtime polymorphism）解决问题。</p><h4 id="41-1-运行期多态与显式接口">41.1 运行期多态与显式接口</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Widget &#123;</span><br><span class="line">public:</span><br><span class="line">    Widget();</span><br><span class="line">    virtual ~Widget();</span><br><span class="line">    virtual std::size_t size() const;</span><br><span class="line">    virtual void normalize();</span><br><span class="line">    void swap(Widget&amp; other);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void doProcessing(Widget&amp; w)&#123;</span><br><span class="line">    if(w.size() &gt; 10 &amp;&amp; w != someNastyWidget)&#123;</span><br><span class="line">        Widget temp(w);</span><br><span class="line">        temp.normalize();</span><br><span class="line">        temp.swap(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于函数 doProcessing：</p><ul><li>w 的类型为 Widget，所以 w 必须支持 Widget 接口，我们可以在源代码中找出这个接口，看看它是什么样子，这样的接口称为显式接口。</li><li>由与 Widget 的某些成员函数是 virtual，w 对那些函数的调用将表现出运行期多态，也就是说将于运行期根据 w 的动态类型（见条款 37）决定调用哪一个函数。</li></ul><h4 id="41-2-隐式接口与编译期多态">41.2 隐式接口与编译期多态</h4><p>Template 及泛型编程的世界，与面向对象有根本上的不同。在此世界中显式接口和运行期多态仍然存在，但重要性降低，关键在于隐式接口（implicit interfaces）和编译期多态（compile-time polymorphism）。为了解释它们，我们现在将  doProcessing 从函数转变成函数模板（function template）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">void doProcessing(T&amp; w)&#123;</span><br><span class="line">    if(w.size() &gt; 10 &amp;&amp; w != someNastyWidget)&#123;</span><br><span class="line">        Widget temp(w);</span><br><span class="line">        temp.normalize();</span><br><span class="line">        temp.swap(w);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 doProcessing，我们可以说：</p><ul><li>w 必须支持哪一种接口，是由 template 中执行于 w 身上的操作来决定。例如，本例中 w 的类型 T 好像必须支持 size, normalize 和 swap 成员函数，copy 构造函数，不等比较。其实这并不完全准确，重要的是，这一组表达式（对此 template 而言必须有效编译）是 T 必须支持的一组隐式接口。</li><li>模板的具现化发生于编译期，“以不同的 template 参数具现化 function templates”会导致调用不同的函数，这便是编译期多态。</li></ul><p>显式接口由函数的签名式（也就是函数名称，参数类型，返回类型）构成。</p><p>隐式接口并不基于函数签名式，而是有效表达式（valid expressions）组成，再次看 doProcessing template 一开始的条件：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ZjNmNTQ2NmIwOTBjNWIxYWZiOWIwODk5MDY0NzQ3NzFfd0tLeGZLb0pCWHNjSHQxdXdxZTNYRmlqWmNvalV3dWhfVG9rZW46Ym94azRQd0ExcFQzbVdFZm9IV05nWTRVQk5jXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>T（w 的类型）的隐式接口看来好像有这些约束：</p><ul><li>它必须提供一个名为 size 的成员函数，该函数返回一个整数值。</li><li>它必须支持一个 operator!= 函数，用来比较两个 T 对象。</li></ul><p>因为操作符重载的存在，这两个约束都不需要满足。T 必须支持 size 成员函数，这个成员函数不需要返回一个整数值，甚至不需要返回一个数值类型，它甚至不需要返回一个定义有 operator&gt; 的类型，它唯一需要做的是返回一个类型为 x 的对象，而 x 对象加上一个 int（10的类型）必须能够调用一个 operator&gt;。这个 operator&gt; 不需要非得取得一个类型为 x 的参数不可，它也可以取得类型为 Y 的参数，只要存在一个隐式转换能构将类型为 X 的对象转换为类型为 Y 的对象。</p><p>同样，T 并不需要支持 operator!=，如果 operator!= 接受一个类型为 X 的对象和一个类型为 Y 的对象，T 可被转换为 X 而 someNastyWidget 的类型可悲转换为 Y，这样就可以调用 operator!=</p><p>隐式接口仅仅是由一组有效表达式构成，表达式自身可能看起来很复杂，但它们要求的约束条件一般而言相当直接又明确。例如以下条件式：</p><p>if(w.size() &gt; 10 &amp;&amp; w != someNastyWidget)</p><p>从整体上看，if 语句的条件式必须是个布尔表达式，无论 “w.size() &gt; 10 &amp;&amp; w != someNastyWidget”导致什么，它都必须与 bool 兼容。</p><p>这是 template doProcessing 中，类型参数 T 的隐式接口的一部分。doProcessing 要求的其他隐式接口：copy 构造函数，normalize 和 swap 也都必须对 T 型对象有效。</p><p>template 参数身上的隐式接口和 class 对象身上的显式接口都在编译期完成检查，无法在 template 中使用“不支持 template 要求的隐式接口”的对象（代码通不过编译）</p><h4 id="41-3-总结">41.3 总结</h4><ul><li>classes 和 templates 都支持接口和多态</li><li>对 classes 而言接口是显式的，以函数签名为中心。多态则是通过 virtual 函数发生于运行期</li><li>对 template 参数而言，接口是隐式的，奠基于有效表达式。多态则是通过 template 具现化和函数重载解析（function overloading resolution）发生于编译期。</li></ul><h3 id="条款-42：了解-typename-的双重意义">条款 42：了解 typename 的双重意义</h3><h4 id="42-1-typename-与-class">42.1 typename 与 class</h4><p>提一个问题，以下 template 声明式中，class 和 typename 有什么不同？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">template&lt;class T&gt; class Widget;</span><br><span class="line">template&lt;typename T&gt; class Widget; </span><br></pre></td></tr></table></figure><p>答案：没有不同。当我们声明 template 类型参数，class 和 typename 的意义完全相同。作者比较喜欢 typename，因为它暗示参数并非一定得是个 class 类型。</p><h4 id="42-2-typename-作为嵌套从属类型名称的前缀词">42.2 typename 作为嵌套从属类型名称的前缀词</h4><p>C++ 并不总是把 class 和 typename 视为等价。有时候你一定得使用 typeame。现在谈谈在 template 中涉及到的两种名称：</p><p>假设先有一个 template function，接受一个 STL 兼容容器为参数，进一步假设这个函数只是打印其第二个元素值，注意该模板函数无法通过编译，稍后解释原因：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NzU1Njg4OGE4YzMxYWY2YzU5MDdjNzhjZTQ5ZTZiODFfdXB1OHJma0QxY0V1Y0EyeGpCOXRUbGhURE16NDlPZThfVG9rZW46Ym94azRyZU1CSGpIcWsyYUpjR0x2RllscTliXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>代码中有两个 local 变量 iter 和 value。iter 的类型是 C::const_iterator，实际是什么取决于 template 参数 C。</p><ul><li>template 内出现的名称如果相依于某个 template 参数，称之为从属名称（dependent names）。</li><li>如果从属名称在 class 内呈嵌套状，我们称它为嵌套从属名称（nested dependent name）。</li><li>C::const_iterator 就是这样一个名称。实际上它还是个嵌套从属类型名称（nested dependent type name）,也就是个嵌套从属名称并且指涉某类型。</li><li>另一个 local 变量 value，其类型是 int。int 是一个并不倚赖任何 template 参数的名称，这样的名称是非从属名称（non-dependent names）。</li></ul><p>嵌套从属名称可能导致解析（parsing）困难，假设我们令上述模板函数更愚蠢些：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=MTgxYzczMDg4ZDk0NTE4Y2UyYjFlMzEzZTc5YWRjYTNfS2ZnQmtzVzdGQzd6TWFMMGJQYUltdGZ4N3RDcTlCZ05fVG9rZW46Ym94azQ5clI4M0lyd3FoWXlqc01PRXFXQ1plXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>看起来好像声明 x 为一个 local 变量，它是一个指针，指向一个 C::const_iterator。我们之所以这么认为，只因为我们“已经知道”C::const_iterator 是个类型。如果 C::const_iterator 不是个类型呢？如果 C 有个 static 成员变量而碰巧被命名为 const_iterator，如果 x 碰巧是个 global 变量名称呢？那样的话上述代码就不再是声明一个 local 变量，而是一个相乘动作。</p><p>C++ 编译器的作者必须操心所有可能的输入，甚至是上面这么疯狂的输入。在我们知道 C 是什么之前，无法知道 C::const_iterator 是否为类型，C++ 有个规则可以解析此为歧义转态：如果解析器在 template 中遭遇一个嵌套从属名称，它便假设这名称不是类型，除非明确告诉它是。</p><p>现在再看 print2nd：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=MTgxYzczMDg4ZDk0NTE4Y2UyYjFlMzEzZTc5YWRjYTNfS2ZnQmtzVzdGQzd6TWFMMGJQYUltdGZ4N3RDcTlCZ05fVG9rZW46Ym94azQ5clI4M0lyd3FoWXlqc01PRXFXQ1plXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>现在应该很清楚为什么这不是有效的 C++ 代码了。 iter 声明式只有在 C::const_iterator 是个类型时才合理，但我们并没有告诉 C++ 它是。解决办法是：使用 typename 告诉C++ 编译器 C::const_iterator 是个类型。</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NjFmNmQyNGQ0MTkwZTEyNmMzMjQ4ZTM3NDczOTIyNGFfeEF0NnlQbHV2SXE3azFSUmd4V3AzanMyaUpvZjRvM2NfVG9rZW46Ym94azRCcGRYajRqelYzTjA5VEFhNk16TlNjXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>一般规则很简单，任何时候想要在 template 中使用一个嵌套从属类型名称，就必须在紧临它的前面放上关键字 typename。</p><p>typename 只被用来证明嵌套从属类型名称：前它名称不该有它存在。例如：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ZjhjYTVhNDMwNWJhN2EyOThhYTdlYjI4MGFjMGVhNGFfRXA2dUY1U0RaVTRDWHBMQ1JLNjdobG83WEx6VDBaQ3dfVG9rZW46Ym94azRpN2k3R0VxYkhNeG1GZ2VhejVueWlmXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>上述的 C 并不是嵌套从属类型名称（并非嵌套于任何“取决于 template 参数”的东西内），所以声明 container 时并不需要以 typename 为前导，但 C::iterator 是个嵌套从属类型名称，所以必须以 typename 为前导。</p><h4 id="42-3-typename-作为嵌套从属类型名称的前缀词的例外">42.3 typename 作为嵌套从属类型名称的前缀词的例外</h4><p>&quot;typename 必须作为嵌套从属类型名称的前缀词&quot;这一规则的例外是，typename 不可以出现在base classes list 内的嵌套从属名称之前，也不可以在 member initialization list（成员初始化列表）中作为 base class 修饰符，例如：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=MzViM2I3ZmZhZjFiMjBjNjNmZTI1N2MzNWNhODFmYThfeDN6akJWcXpobHRPN1VDTklPenpnT0FnTUtvdVd6RWNfVG9rZW46Ym94azRLeUV1VHB6N3k1eGRtcmE5WWN0RkZmXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><h4 id="42-4-代表性例子">42.4 代表性例子</h4><p>该例子可能会在真实程序中碰到，假设我们正在编写一个 function template，它接受一个迭代器，而我们打算为该迭代器指向的对象做一份复件 temp，我们可以这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename IterT&gt;</span><br><span class="line">void workWithIterator(IterT iter)&#123;</span><br><span class="line">    typename std::iterator_traits&lt;IterT&gt;::value_type temp(*iter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码是 traits class （见条款 47）的一种运用，相当于“类型为 IterT 的对象所指之物的类型”。这个语句声明一个 local 变量 temp，使用 IterT 对象所指物的相同类型，并将 temp 初始化为 iter 所指物。如果 IterT 是 list<int>::iterator，temp 的类型就是 int，如果 IterT 是 vector<string>::iterator，temp 的类型就是 string。</p><p>value_type 被嵌套于 iterator_traits<IterT> 之内而 IterT 是个 template 参数，所以必须在它之前放置 typename。</p><p>如果“std::iterator_traits<IterT>::value_type”读起来不畅快，有经验的程序员应该会想到 typedef。对于 trait 成员名称如 value_type，使用 typedef 名称以代表某个 traits 成员名称，常常可以在实际的代码中看到这样的 local typedef：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=YWQ5ZTg1MWI1MGQ1NjhkYjhkZmYwMjFjYWM0ODc5YzhfR0lNSVFZcmx6bGxVZ1dEUFpwd1gxS0ZLcURURHpGcERfVG9rZW46Ym94azRVcHltbm1uTVVJZkhZZkc1RnVVd3JiXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><h4 id="42-5-总结">42.5 总结</h4><ul><li>声明 template 参数时，前缀关键字 class 和 typename 可互换。</li><li>请使用关键字 typename 标识嵌套从属类型名称，但不得在 base class lists（基类列）或 member initialization list（成员初始化列表）内以它作为 base class 修饰符。</li></ul><h3 id="条款-43：学习处理模板化基类内的名称">条款 43：学习处理模板化基类内的名称</h3><p>假设需要编写以下程序，它能够传送信息到若干不同的公司去，可以发送加密信息，也可以发送明文信息。如果编译期间有足够信息来决定哪一个信息传至哪一家公司，就可以采用 template：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=OTAwNWJhMWM3OTFiOTQ0YmVkNGZkNWNkMzZlNWVlNDBfOFI5b1ozcTVYSnByVFU0ZmVKa1pTdHF1dEdaZ3NvWWtfVG9rZW46Ym94azRaY2JsYnROSldJRlM4SHU3QUFoRlBoXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>这个做法行得通，假设我们需要在每次发送信息前后，标记（log）某些信息，derived class 可以轻易实现：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=YTlmMzE1MWQyYmU5ZThmNzA4ZjZmNTUwZmE2MWE0ZjlfQzZUUUZEN3A4bHUyaU9xMWdYSE9HYUVqZHpVMVd6dmhfVG9rZW46Ym94azR6QkZpbXJhTTVCQ05PT0Z4YzY5TWNkXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>注意这个 derived class 的信息传送函数有一个不同的名称（sendClearMsg），与其base class 内的名称（sendClear）不同。这是个好设计，因为避免“名称遮掩”和“重新定义一个继承而来的 non-virtual 函数”。但上述代码无法运行，因为编译器不知道 sendClear 的存在。我们可以看到 sendClear 存在于 base class 内，编译器却看不到它们，为什么？</p><p>问题在于，当编译器遭遇 class template LoggingMsgSender 定义式时，并不知道它继承什么样的 class。当然是继承的是 MsgSender<Company>，但其中 Company 是个 template 参数。除非 LoggingMsgSender 被具现化，否则无法确切知道它是什么，因而也就无法知道它是否有 sendClear 函数。</p><h4 id="模板特化">模板特化</h4><p>为了让问题更具体化，假设现有个 class companyZ 坚持使用加密通讯：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=YTYzNGRkN2Y2MDE3YjJmZmNlZWI1MTk3ZmRiMjViMWVfQ0lIc1hvZnJqMVRGc29DMXhhM3FYNDZFWGhRcEpyZk9fVG9rZW46Ym94azRrZlM4eWVhR013OHJrRnBLcEhocHFiXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>很明显上述 CompanyZ 对一般性的 MsgSender template 并不合适，因为其并未定义 SendCleartext 函数。为了矫正这个问题，我们可以针对 CompanyZ 产生一个 MsgSender 特化版：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=YWE2ODc3NmNmNjBlYWEyOTI5NGY0OTVmMzcxMThjOGZfQjFXblNReDZBNmpWV0o0TXQ5cWdCM0czM1BRb0twTkdfVG9rZW46Ym94azRpc2p3T01WajJjM1NBMldYa2pqOUJoXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>上述 “template&lt;&gt;” 表示这既不是 template，也不是标准 class，而是个特化版的 MsgSender template，在 template 实参是 CompanyZ 时被使用。</p><p>现在，MsgSender 针对 CompanyZ 进行了全特化，现在再次考虑 derived class LoggingMsgSender：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=YzQ0NWU4MWEwMDU4NDM2Y2E5MWIyZmRjMTVjZWY3ZDJfOWd5RWlZdmRUWmtrSGhXYmNXcmNUWXdUTnBraG1xYk1fVG9rZW46Ym94azRFZnByUlBCWWhaUTc3MDZVV3lTVlpEXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>当 base class 被指定为 MsgSender<CompanyZ> 时这段代码不合法，因为那个 class 并未提供 sendClear 函数。</p><p>这就是为什么 C++ 拒绝这个调用的原因：它知道 base class templates 有可能被特化，而那个特化版本可能不提供和一般性 template 相同的接口。因此它往往拒绝在 templatized base classes（模板化基类）内寻找继承而来的名称。</p><p>当我们从 Object oriented C++ 跨进 Template C++，继承会受到某些限制。</p><h4 id="解决办法">解决办法</h4><p>为了解决上述问题，我们必须有某种办法令 C++ 进入 templatized base classes，有三个办法。</p><ol><li>在 base class 函数调用的动作前加上 this-&gt;</li></ol><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=YmFhY2UyZDU1YzEwZjM3NDU5ZjM2NTM2MjQyMmExMmJfRE1JVW9TbkRqaHlKM2pqeVdDanp2VGFiZ1JyYkl1OEhfVG9rZW46Ym94azRaV0tCSW1OdEp4OGthcnVLQ1JJaE5lXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><ol><li>使用  using 声明式</li></ol><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=MzczMDI1ODdkZTVkNTRkNGUyNGRiYzgwNzA0M2NlYzZfY214cEUxSVBuV2pwdFUyZU1EVVA2eGhjZHNPU1hVUWtfVG9rZW46Ym94azREcW81ejJWM2NTVXVmN1B0dmpmT2pNXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>这里表示编译器不进入 base class 作用域内查找，于是我们通过 using 告诉它，请它那么做。</p><ol><li>明白指出被调用的函数位于 base class 内：</li></ol><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ZjRjNjE5NmE2MzYwYjAyY2U2MDNmN2VhYTNlNGY5ZmVfVWp2alpmbVdWcHFHR2ZuRk00Q1FlMXlDTkRib05IMEhfVG9rZW46Ym94azRVNkVjQjBaNUI5MVR1UERTZ3RQWmVlXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>但这往往是最不让人满意的一个解法，因为如果被调用的是 virtual 函数，上述的明确资格修饰（explicit qualification）会关闭“virtual 绑定行为”。</p><p>如果在稍后的源码内包含以下代码：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NWQwYWQzZDNmZGI1ZmUzNGNjZDU1YWEzMjgwYmU3NmJfV3JBZHdVZWZFYUFHZ21nTjh4Q0Q1bVc0cDE5ZUpoM3ZfVG9rZW46Ym94azRRRHVUVlpmQ0wyOUExOFdoVk50VnVjXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>其中对 sendClearMsg 的调用动作将无法通过编译，因为在那个点上，编译器知道 base class 是个  template 特化版本 MsgSender<CompanyZ>，而且知道那个 class 不提供 sendClear 函数。</p><p>编译器寻找代码错误的时间可能发生在早期（解析 derived class template 的定义式时），也可能发生在晚期（当那些 template 被特定的 template 实参具现化时）。C++ 的政策是宁愿较早诊断。</p><h4 id="总结-12">总结</h4><p>可在 derived class template 内通过 “this-&gt;” 完成对 base class templates 内的成员的访问，或由一个写出的“base class 资格修饰符” 完成。</p><h3 id="条款-44：将与参数无关的代码抽离-templates">条款 44：将与参数无关的代码抽离 templates</h3><p>Template 是节省时间和避免代码重复的一个好方法，class templates 的成员函数只有在被使用时才暗中具现化。但必须注意，使用 templates 也可能导致代码膨胀（code bloat）：其二进制码带着重复（或几乎重复）的代码，数据。</p><p>为了避免这个问题，我们通常使用一个叫做：共性与变形分析（commonality and variability  analysis）的方法。其概念也很简单，看下列例子：</p><ul><li>当我们编写某个函数，其中的实现码和另一个函数的实现码实质相同，我们会抽出两个函数的共同部分，把它们放进第三个函数中，然后令原先两个函数调用这个新函数。（也就是找出共同的部分和不变的部分）</li><li>当我们编写某个 class，其中的一部分和另一个 class 的某些部分相同，我们会把共同的部分搬到新 class 中去，然后使用继承或复合（见条款 32，38，39）令原先的 classes 取用这些共同特性。</li></ul><p>编写 templates 时，也做相同的分析，以相同的方式避免重复，有以下窍门：</p><p>在 template 代码中，重复是隐晦的：毕竟只存在一份 template 源码，所以必须训练自己去感受当 template 被具现化多次时可能发生的重复。</p><h4 id="44-1-问题">44.1 问题</h4><p>举个例子：假如我们想为固定尺寸的正方形矩阵编写一个 template，该矩阵的性质之一是支持逆矩阵运行（matrix inversion）。</p><h4 id="44-2-方案一">44.2 方案一</h4><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ZTVlNzdjMzBmYzM0YmU2NTE2YmM5YjhmZDVkZGNiOTJfdHRyRGtyQ3dKZVJ4NHJDSDlXNGtZMnE5enRqckFHdzhfVG9rZW46Ym94azRWejVDdTdSSXF0YTlNM1BwbmlGVFN2XzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>这个 template 接受一个类型参数 T，除此之外还接受一个类型为 size_t 的参数，这是个非类型参数（non-type parameter），这种参数和类型参数比起来较不常见，但它们完全合法。</p><p>现在，观察这些代码：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NGExYjA1NTE0M2VjMTgyNjU5ODEzOTcwMWQyNDUyNDRfbXRidGdoa1d6OGJPNHJIcmZaZHpMSGV3RFozT05WYUJfVG9rZW46Ym94azRXajAyd1JTN0ZNWkt3Zk1JbVJHU2dlXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>上述代码会具现化两份 invert，但这两份 invert，除了常量 5 和 10，两个函数的其他部分完全相同。这是 template 引发代码膨胀的一个典型例子。</p><h4 id="44-3-方案二">44.3 方案二</h4><h5 id="关于-invert">关于 invert</h5><p>第一次修改，我们将创建一个带数值参数的函数，然后以 5 和 10 来调用这个带参数的函数，而不重复代码：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=YjY2ODczZGE0MGQxNTFjZWIzZjNlMGIyOWNmMTRkYjFfd3dIYlEyVkdGWm9oUVdBSHl6VDlaYXR3cGE0TkNHWUJfVG9rZW46Ym94azRPaGNFc3hCUE1GT0tOT1NCc0Ryd2lnXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>带参数的 invert 位于 base class SquareMatrixBase 中，和 SquareMatrix 一样，base class SquareMatrixBase 也是 template，不同的是它只对&quot;矩阵元素的类型&quot;参数化，不对矩阵的尺寸参数化。因此，对于元素对象类型相同的矩阵，它们都共享同一个 SquareMatrixBase ，它们也将共享这唯一一个 class 内的 invert。</p><ul><li>SquareMatrixBase::invert 只是企图“避免 derived classes 代码重复”的一种方法，所以它是 protected。</li><li>调用 SquareMatrixBase::invert 成本应该是 0，因为 derived classes 的 invert 调用 base class 版本时用的 inline</li></ul><p>关于 “this-&gt;”，原文说的是如果不使用，模板化基类内的函数名称会被 derived classes 遮掩。</p><p>注：其实，在这里不是用 “this-&gt;” 也可以，因为前面已经使用了 using 让 base class 内的 invert 在该类中可见，而且 SquareMatrixBase::invert 和 SquareMatrix::invert，存在重载关系，系统会选择合适的函数执行。</p><h5 id="矩阵存储在哪">矩阵存储在哪</h5><p>这一次我们要面对的问题是 SquareMatrixBase::invert 如何知道该操作什么数据？它如何知道哪个特定矩阵的数据在哪儿？</p><p>一个可能的做法是为 SquareMatrixBase::invert 添加另一个参数，指向一块用来放置矩形数据的内存起点。如果有若干这样的函数，我们可以对所有这样的函数添加一个额外参数，却得一次又一次地告诉 SquareMatrixBase 相同的信息，这似乎不好。</p><p>另一个办法是令 SquareMatrixBase 存储一个指针，指向矩阵数值所在的内存。顺便也可以在  SquareMatrixBase 存储矩阵的尺寸。如下所示：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ZTg5MzYxZTg0NGYxNTZiODMxYTRhM2M0ZTk2ZTkxMmNfNnVjSTNXRTExOTNwVU05ejN0a0xNcHE0WnVKVFZiQTZfVG9rZW46Ym94azRvaFpyaFZoSW43ZjB5ejFwbmpyT0hlXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>这允许 derived class 决定内存分配方式。某些实现版本也许会将矩阵数据存储在 SquareMatrix 对象内部：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NzM3OWRjOWJlM2ZjOTYwZGYwM2U1MDI5YWRiNjc5ZTRfcVFUVGxKdHo3M0hlUlVoNDNRMzhrbllCRk05ZFJmdlFfVG9rZW46Ym94azRrR3B0OGw5WWlwVkQ5S213NW5pUnRlXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>这种类型的对象不需要动态分配内存，但对象自身可能非常大。另一种做法是让每一个矩阵的数据放进 heap：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=M2EyZmEwZDc0ZmUzMzY1M2I3MGVlMjhkNjI2YWVlNTNfdGx1aTFNNjZvSG82dVR1ZDRHSTBWZkJFcXkzQ0NCOVpfVG9rZW46Ym94azQzak9sNkhTWVQ3RUFVQXp3VjhCeUtiXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><h4 id="取舍">取舍</h4><p>在上面所述的方案中，不同大小的 SquareMatrix 对象有着不同的类型，所以即使（例如：SquareMatrix&lt;double,5&gt; 和 SquareMatrix&lt;double, 10&gt;）对象使用相同的 SquareMatrixBase<double> 成员函数，我们也没机会传递一个 SquareMatrix&lt;double,5&gt; 对象到一个期望获得 SquareMatrix&lt;double, 10&gt; 的函数去。</p><h5 id="方案一优点">方案一优点</h5><p>如前所述，方案一中的 invert 版本，有可能生成比共享版本（其中尺寸以函数参数传递或存储在对象内）更佳的代码。例如在尺寸专属版（方案一）中，尺寸是个编译期常量，因此可以由常量的广传达到最优化，包括把它们折进被生成指令中成为直接操作数。这一特性是，“与尺寸无关”版本（方案二）无法办到的。</p><h5 id="方案二优点">方案二优点</h5><p>从另一个角度，不同大小的矩阵只拥有单一版本的 invert，可减少执行文件大小，也就因此降低程序的 working set 大小，并强化指令高速缓存区内的引用集中化（locality of reference）。这些都可能使程序执行得更快速，超越“尺寸专属版”invert 的最优化效果。</p><blockquote><p>所谓 working set 是指在一个“虚内存环境”下执行的进程而言，其所使用的那一组内存页（pages）</p></blockquote><h5 id="决择">决择</h5><p>那到底该选择哪一个版本更好呢？唯一的办法是两者都尝试并观察我们所使用平台的行为以及面对代表性数据组时的行为。</p><h5 id=""></h5><h4 id="总结-13">总结</h4><p>本条款只讨论由 non-type template parameters（非类型模板参数）带来的膨胀，其实 type parameters（类型参数）也会导致膨胀。例如：</p><ul><li>在许多平台，int 和 long 有相同的 二进制表示，所以像 vector<int> 和 vector<long> 的成员函数有可能完全相同。有些连接器（linkers）会合并完全相同的函数实现，但有些不会。后者意味着 template 被具化为 int 和 long 两个版本，并因此可能造成代码膨胀。</li><li>类似的，在大多数平台，所有指针类型都有相同的二进制表述，因此凡 template 持有指针者，（例如 list&lt;int*&gt;, list&lt;const int*&gt;, list&lt;SquareMatrix&lt;long, 3&gt;*&gt;等等）往往应该对每一个成员函数使用唯一一份底层实现。</li></ul><p>如果我们实现某些函数而它们操作强型指针（srongly typed pointers，即 T*），应该令它们调用另一个操作无类型指针（untyped pointers，即 void*）的函数，由后者完成实际工作。</p><ul><li>Templates 生成多个 classes 和多个函数，所以任何 template 代码都不该与某个造成膨胀的 template 参数产生相依关系。</li><li>因非类型参数（non-type template parameters）而造成的代码膨胀，往往可以消除，做法是以函数参数或 class 成员变量替换 template 参数。</li><li>因类型参数（type parameters）而造成的代码膨胀，往往可降低，做法是让带有完全相同二进制表述（binary representations）的具现类型（instantiation types）共享实现码。</li></ul><h3 id="条款-45：运用成员函数模板接受所有兼容类型">条款 45：运用成员函数模板接受所有兼容类型</h3><p>真实指针做得很好的一件事是：支持隐式类型转换（implicit conversions）。Derived class 指针可以隐式转换为 base class 指针，“指向 non-const 对象”的指针可以转换为“指向 const 对象”。如下所示：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ODYzODQ2MGE5ZGM5MGQyMThiYzhjNTk2Yzg3NmVhYjlfWGViV1hEUnFMOEZ5UFpvM2NmUGJQU0RXR1NhZHlodkNfVG9rZW46Ym94azQzSVllUW1ieUVWeHo1NldPbXVKTWNoXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>如果用户想在自定义的智能指针中模拟上述转换，稍微有点麻烦，我们希望如下代码通过编译：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NDBmNzQwN2ZjY2JjMzRlZjEzNmNiNDMwYzhkNmUxY2NfZWw1dHlqSWhydVFwc1Q1WnpIOU43eVEwbEZSRER4RWdfVG9rZW46Ym94azROQnJMY25qTWhjR3F6RzFuVnNiZjdkXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>同一个 template 的不同具现体（instantiations）之间并不存在什么与生俱来的固有关系，所以编译器视 SmartPtr<Middle> 和 SmartPtr<Top> 为完全不同的 classes。</p><p>为了获得我们希望的 SmartPtr classes 之间的转换能力，我们必须将它们明确地编写出来。</p><h4 id="Templates-和-泛型编程（Generic-Programming）">Templates 和 泛型编程（Generic Programming）</h4><p>从上述代码示例中可以看出，每个语句都创建了一个新式智能指针对象，所以现在我们重点关注如何编写智能指针的构造函数，使其行为满足我们的转换需要。如下所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt;</span><br><span class="line">class SmartPtr &#123;</span><br><span class="line">public:</span><br><span class="line">    SmartPtr(const SmartPtr&lt;Middle&gt;&amp; other);</span><br><span class="line">    SmartPtr(const SmartPtr&lt;Bottom&gt;&amp; other);</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码我们可以根据一个 SmartPtr<Middle> 或一个 SmartPtr<Bottom> 构造出一个 SmartPtr<Top>。假设这个继承体系未来所有扩充，SmartPtr<Top> 对象又必须能够根据其它指针指针构造自己，例如日后添加了：</p><p>class BelowBottom: public Bottom { … }</p><p>我们又必须写出以下构造函数：</p><p>SmartPtr(const SmartPtr<BelowBottom>&amp; other);</p><p>一个很关键的观察结果是：我们永远无法写出我们需要的所有构造函数。</p><p>现在我们尝试写一个 Template 来满足所有类似需求，因为一个 template 可被无限量具现化，以至生成无限量函数。因此我们需要为它写一个构造模板，这样的模板（templates）是所谓的 membe function template（常简称 member templates），其作用是为 class 生成函数：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=YWJmN2RlMTA1MjEyZTAzNzlkODdhZjliOGE2N2RmOWVfTWl2MDZFMWtjSjNWWGRzMmhFT1NMaUo2b0FBcEZoN1ZfVG9rZW46Ym94azRiUFNtZHE4R1pWblR2aW9EZXE3alJjXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>以上代码意思是，对任何类型 T 和任何类型 U，可以根据 SmartPtr<U> 生成一个 SmartPtr<T>。因为它的构造函数模板产生的构造函数可以根据对象  u 创建对象 t（例如根据 SmartPtr<U> 创建一个 SmartPtr<T>），而 u 和 t 的类型是同一个 template 的不同具现体，有时我们称之为泛化（generalized）copy 构造函数。</p><p>上面的泛化 copy 构造函数并未被声明为 explicit，那是故意的，因为原始指针类型之间的转换是隐式的，所以让智能指针效仿这种行为是合理的。</p><p>由于上述为 SmartPtr 所写的“泛化 copy 构造函数”提供的东西比我们需要的更多。我们不希望根据一个 SmartPtr<Top> 创建一个 SmartPtr<Bottom>，因为那对 public 继承而言是矛盾的。</p><p>假设我们提供一个 get 成员函数，返回智能指针对象所持有的那个原始指针的副本，那么我们可以在“构造模板”实现代码中约束转换行为。如下：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NjgyYWMxYmQ4ZmY0Y2VlOTJhNzYxMTk3ODNjMGRhYjlfYmd5aEhYMnFwYW45TWhVRVFmR1FUTXVkc21zRG5xbGpfVG9rZW46Ym94azRRNzc1NXk1RGxjUUVUSEZMS0c3UjB5XzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>我们使用成员初始化列表（member initialization list）来初始化 SmartPtr<T> 中的 T* 成员变量，并以类型为 U* 的指针（由 SmartPtr<U>持有）作为初值。这个行为只有当“存在某个隐式转换可将一个 U* 指针转为一个 T* 指针”时才能通过编译，而那正是我们想要的。</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=OGU1ODJhZjkxZGYyNDYzMjY5OGY2NjViZTY2YjRiOTFfRnhnRm9KcEdWbld5dkVET2JpRlNaUVJ5bTlqUnIzUU1fVG9rZW46Ym94azRXaTBqRGQ0andDME9QTDgxY01yNEllXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>现在 SmartPtr<T> 有了一个 泛化 copy 构造函数，这个构造函数只在其所获得的实参隶属适当类型时才能通过编译。</p><p>member function templates（成员函数模板）的作用不限于构造函数，它也能去实现赋值操作。</p><p>std::shared_ptr 的前身 tr1::shared_ptr 的一份摘录如下：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=N2Y5ZTgwYzE1N2ZlN2U0Y2U2MDFkMjNkODA0ZmQ2ZjhfbFg4UlhzWll3YnZZQVFNSGUxRzlsSFpYTjJ6czM4MmhfVG9rZW46Ym94azR5NHVWU0Z1MVFnenA0MThVTWE0b3FnXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ZWUyYTc0ZjM0NTZjNWJhZjYzZTgzMGRiYzU0MTgyYTFfZ3ZOeTdvRFo5eHlBVWQ5djFWc2o5MXZ5WEZ4azBZOEpfVG9rZW46Ym94azRIMG9EcjNWUmdsV1ROdUZ5czhKTGJnXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>上述所有构造函数都是 explicit，“泛化 copy 构造函数除外”，意味着从某个 shared_ptr 类型隐式转换至另一个 shared_ptr 类型是被允许的。</p><p>成员函数模板并不改变语言的基本规则，如果程序需要一个 copy 构造函数，但我们没有声明它，那编译器会暗自生成一个。在 class 内声明泛化 copy 构造函数并不会阻止编译器生成它们自己的 copy 构造函数。对于构造函数，如果有需要，我们可以即声明一个普通构造函数（non-template），和一个泛化 copy 构造函数。下面是 tr1::shared_ptr 的一份定义摘要：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=MTczNzZiYzIyYjUyMGQxNDdlOTE0MTVhZWFkYzJhZGRfMjNRZVNpYXpUd1huWjFZUG9GeDhzQkdtb2NERzNkdTJfVG9rZW46Ym94azRrdnV2YUpCUVZuM0J6OVRXRWhBV1VnXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><h4 id="总结-14">总结</h4><ul><li>使用成员模板函数（member function templates） 生成“可接受所有兼容类型”的函数。</li><li>如果我们声明 member template 用于“泛化 copy 构造”或“泛化 assigment 操作”，我们还是需要声明正常的 copy 构造函数 和 copy assignment 操作符。</li></ul><h3 id="条款-46：需要类型转换时请为模板定义非成员函数">条款 46：需要类型转换时请为模板定义非成员函数</h3><p>条款 24 讨论了只有 non-member 函数才有能力“在所有实参身上实施隐式类型转换”，该条款以 Rational class 的 operator* 函数为例，本条款首先以看似无害的改动扩充 条款 24 的讨论：本条款将 Rational 和 operator* 模板化了：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NWVkZDY2YWIzNjQ2YThlMDM3YTY5ZDRlYmE2MTY0MmFfT0VKVVVldGtic2RPZm9SSnlua3BEUndQSmFwNUVudmFfVG9rZW46Ym94azR2Nm5MVjlXcm52RXUzNGpaZ1NIY1doXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>就像条款 24 一样，我们希望它支持混合式算术运算，所以我们希望以下代码顺利通过编译：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=MGVlNTRjZDA5M2JhYTQxNmY1YTI2NjNiNDc1N2Y2MDZfdEpGdUh6Zk5wSUVKZGhCdmFUWTRESURPa055bVRuYUNfVG9rZW46Ym94azRWV0xobDgyQ05OdWNDSDR4b1RVT2tlXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>上述代码给我们的启示是，模板化的 Rational 内的某些东西似乎和其 non-template 版本不同。因为在这里编译器不知道我们想调用哪个函数。</p><p>取而代之的是，它们试图想出什么函数被命名为 operator* 的 template 具现化出来。它们知道它们应该可以具现化某个“名为 operator* 并接受两个 Rational<T>参数”的函数，但为完成这个一具现化行动，必须知道 T 是什么。问题是它们没有这个能耐。（它们代指编译器）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Rational&lt;int&gt; result = oneHalf * 2;</span><br></pre></td></tr></table></figure><p>为了推导 T，编译器看了看 operator* 调用动作的实参类型，本例子中那些类型分别是：Rational<int>（oneHalf的类型） 和 int (2 的类型)。</p><p>对于 oneHalf 来说并不困难，从它的定义式可知它的 T 类型为 int。那对于第二实参 int，编译器如何根据这个推算出 T。我们可能会期盼编译器使用 Rational<int> 的 non-explicit 构造函数将 2 转换为 Rational<int>，进而将 T 推导为 int。但编译器不这么做，因为 template 实参推导过程从不将隐式类型转换函数纳入考虑。这样的转换在函数调用过程中的确被使用，但在调用一个函数之前，首先必须知道那个函数存在。而为了知道它，必须先为相关的 function template 推导出参数类型。然而在 template 实参推导过程中并不考虑采纳“通过构造函数而发生的”隐式类型转换。</p><p>现在我们处于 template part of C++ 领域内，template 实参推导是我们的重大议题。</p><p>只要利用一个事实，我们可以缓和编译器在 template 实参推导方面受到的挑战：template class  内的 friend 声明式可以表示某个特定函数。意味着 class Rational<T> 可以声明 operator* 是它的一个 friend 函数。class template 并不依赖 template 实参推导（后者只施行于 function templates 身上），所以编译器总是能够在 class Rational<T> 具现化时得知 T。</p><p>因此，令 Rational<T> class 声明适当的 operator* 为其 friend 函数，可简化整个问题。</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NDA4ZWYxYjdkZGI5OWI5NTdkYjQ5Y2UyY2MwODU3MzNfVUhNWjZ5N0N3WmN0a2xNcjRSQ2hTS0dJd2dSZXpxQzJfVG9rZW46Ym94azRhOGpLQnlVVjJwZTlqcENxTUNaUjRkXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=MjMzOTU4OGQxZjRjNjU0MThiNGRjM2I0YTEyMWJhNWRfOG1VVWpQU1ZBdTlqamN3ejE4YW1JeXlMYWZIczFSSUtfVG9rZW46Ym94azR2dE1WTnVQaWJoelZmMnBnTnJUWjNjXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>这样，friend 函数 operator*（接受 Rational<int>参数）也就被声明出来，它现在是一个函数，而非函数模板，因此编译器可以在调用它时使用隐式类型转换（例如 Rational 的 non-explicit 构造函数），而这便是混合式调用（ <code>oneHalf * 2</code>） 之所以成功的原因。</p><p>本例中的 operator* 被声明为接受并返回 Rational（而非 Rational<T>&amp;），它其实等价于以下形式：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ZmVhOWE2ZmRlMTZkODljZmM2MWMyOTFlNDE5MDMyOTNfbzZra3d0WlJuTEI2VEhmSU8yaEp0QXV2R2FxaWVKS2lfVG9rZW46Ym94azRIRkhVYWVwVzRVMG44aUhRZ1gxNGw2XzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>上述代码虽然能通过编译，但无法运行，会出现连接错误。因为意图让此 class 外部的 operator* template 为 class 内声明的 operator* 提供定义式。这是行不通的，如果我们自己声明了一个函数，就有责任定义那个函数。如果没有提供定义式，连接器当然找不到它。</p><p>最简单可行的方法是将 operator* 函数本体合并至其声明式内：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NzcxYWQzZGQ1N2FkNzI3MGNiYTQ0MDAwOTZjY2NhZDVfd3kyOTduZ0I1WTdnNXBqdEE2ZWJiWEJ3anl0eHoxbzdfVG9rZW46Ym94azRrVkVhblh4blhzRHBWSFpsUGpnNUxlXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>这项技术有趣的一点是，我们虽然使用 friend，却与 friend 的传统用途“访问 class 的 non-public 成分”毫不相关。为了让类型转换可能发生于所有实参身上，我们需要一个 non-member 函数（条款 24），为了令这个函数被自动具现化，我们需要将它声明在 class 内部。</p><p>而在 class 内部声明 non-member 函数的唯一办法就是：令他成为一个 friend。</p><p>条款30 说过，定义于 class 内部的函数都暗自成为 inline，包括像 operator* 这样的 friend 函数。为了将这样的 inline 声明所带来的冲击最小化，做法是令 operator* 不做任何事，只调用一个定义于 class 外部的辅助函数。</p><p>对于本例而言，这样做并没有太大意义。</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=OWY4ZjNkMmQzYWY3YWMxMjFmNjNjZTU1MWRhMDEwOGZfRlNuUmswNEx4UnJiRENldWdzTzJ4RlFDZEJpamQ4R0hfVG9rZW46Ym94azR3T0s1VnNYcDdFTVNNUTZQSGx3c3FxXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NzVkN2ExZWRmZWNiZTdiNDg4NzQyMTdlZDFiZTc0ZjZfVkdNYnN0c0VrenhiZ2FKdGJtVGRhYmsyNFVreEU2aEFfVG9rZW46Ym94azRrUEY0OVRUVzJrN3ZobGR4a3Zib2NmXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>作为一个 template，doMultiply 当然不支持混合式乘法，但它其实也不需要，它只被 operator* 调用，而 operator* 支持了混合式操作。本质上 operator* 支持了类型转换所需的任何东西。</p><h4 id="总结-15">总结</h4><p>当我们编写一个 class template，而它所提供的“与此 template 相关的” 函数支持“所有参数的隐式类型转换”时，请将那些函数定义为“class template 内部的friend 函数”。</p><h3 id="条款47：请使用-traits-classes-表现类型信息">条款47：请使用 traits classes 表现类型信息</h3><h4 id="47-1-迭代器的分类">47.1 迭代器的分类</h4><p>STL 中共有 5 种迭代器，对应于它们支持的操作：</p><ol><li>input 迭代器：只能向前移动，一次一步，客户只可读它们所指的东西，而且只能读取一次。它们模仿指向输入文件的阅读指针（read pointer）。例如 C++ 标准库中的：istream_iterator</li><li>output 迭代器：只能向前移动，一次一步，客户只可写它们所指的东西，而且只可写一次。它们模仿指向输入文件的写指针（write pointer）。例如 C++ 标准库的：ostream_iterator</li><li>forward 迭代器：可以做前述两种分类的每一件事，而且可以读或写所指物一次以上。</li><li>Bidirectional 迭代器比上一个分类更强大，它除了可以向前移动，还可以向后移动。例如：STL 的 list，set，multiset，map 和 multimap 的迭代器。</li><li>random access 迭代器：最强大的迭代器，除了具有上一个分类的所有功能，它还可以进行“迭代器算术”，即它可以在常量时间向前或向后跳跃任意距离。它类似于指针。例如：vector, deque 和 string 提供的迭代器属于这一分类。</li></ol><p>对于这 5 种迭代器，C++ 标准程序库分别提供专属的 tag struct 加以表示：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=MWY2NzU2NDU3YzZjOTk5MGI0ZTQ0MDQyMDllMmI2YjNfbTltWHRCRXZGcjFIbnZ3YTU3a29LNVNnS05tdnpPczlfVG9rZW46Ym94azR5Y01uakZES0x6cjJZQUx2NGlmbHExXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>这些 struct 之间的继承关系是有效的 is-a 关系。所有的 forward 迭代器都是 input 迭代器。</p><h4 id="47-2-std-advance-的实现">47.2 std::advance 的实现</h4><p>STL 中有若干工具性质的 template，其中一个名为 advance，用来将某个迭代器移动某个给定举例：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=Zjg0MTI2NDUzNTE4MmJlMzVkZjkwOGJhMGM4MTI1N2JfVUlOWjNwaWlvdWpWMko2YThWRDV1dmhIc2lEVnJSQ0pfVG9rZW46Ym94azRiakcxMDZBOHp4WHAwTFZaRmlEVFFjXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>表面上看 advance 只是做 iter+=d 动作，但其实只有 random access 迭代器才支持 += 操作，对于其他迭代器，advance 必须反复施行 ++ 或 – 共 d 次。</p><p>为了充分利用各种迭代器的优势，我们这样设计 advance：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ODJiZTc4ZjU2Y2Q1NWRmMTk1ZDhjMGJiNGI1Y2VkOTNfcDlHUVNaektkTWdwT3lmejdZN2RpWjlpUlBuWnp5ODJfVG9rZW46Ym94azRZMFJKeWpHMndQUTVmMDlPUWFNcmpnXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>这种做法必须判断 iter 是否为 random access 迭代器，即我们需要取得类型的某些信息，这就用到了 trait：它允许我们在编译期间取得某些类型信息。</p><p>Trait 并不是 C++ 关键字或某个预定义的构件：它们是一种技术，也是一个 C++ 程序员共同遵守的协议。它的要求之一是：它对内置类型和用户自定义类型的表现必须一样好。</p><p>Trait 必须能够用于内置类型，意味着“类型内的嵌套信息”这种东西出局了，因为我们无法将信息嵌套于原始指针内，因此类型的 trait 信息必须位于类型自身之外。标准技术把它放进一个 template 即其一或多个特化版本种。这样的 template 在标准程序库种有多个，其中针对迭代器的被命名为 iterator_traits：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=MTdiYzY3Y2E5YzEyOTM3MWUzZmZiZGVhOTMyYTkzZThfNTN2NVhBcVc3Z2JsdUlneWJhVXRBNVF1ZkNZYmVTcmtfVG9rZW46Ym94azRVMUp0SFpTMnlaZ1JXUVptdHFxd0llXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>iterator_traits 的运作方式，针对每一个类型 IterT ，在 struct iterator_traits<IterT>内一定声明某个 typedef 名为 iterator_category。这个 typedef 用来确认 IerT 的迭代器分类：</p><h4 id="47-3-iterator-traits的两种实现">47.3 iterator_traits的两种实现</h4><h5 id="针对自定义类型">针对自定义类型</h5><p>首先它要求每一个“用户自定义的迭代器类型”必须嵌套一个 typedef，名为 iterator_category。例如：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=MWMzOTcyNWM0Nzc1ZDdiNjJjNmNhMTZkMThkYzRjOWVfWHB4NjFEZnJmSjYyVzE5VzN5eWNEbWhPWHd1cmFGQUhfVG9rZW46Ym94azRhbmlueGNvaXRWWDc0ZzdJU2pwam5nXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>这对用户自定义类型行得通，但对指针行不通，因为指针不可能嵌套 typedef。iterator_traits 的第二部分如下，用来对付指针:</p><h5 id="针对内置类型">针对内置类型</h5><p>为了支持指针迭代器， iterator_traits 特别针对指针类型提供了一个偏特化版本。例如：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ZmQ4ZGI1YTA0YThhOTAyZWJmY2NlZDljMGJhN2Y0YWFfeUNTSk1hRHRSTmVSbm5aVXNRaGRjYk1QVHpkcUoyTm9fVG9rZW46Ym94azRDVDV5QVZpaTZwa2tCMnJuUnFoT1JpXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>现在我们知道怎么设计一个 traits class 了：</p><ul><li>确认可取得的类型相关信息，例如对迭代器而言，希望将来可取得其分类。</li><li>为该信息选择一个名称（例如 iterator_category）</li><li>提供一个 template 和一组特化版本（上述的 iterator_traits），内含你希望支持的类型相关信息。</li></ul><p>现在有了 iterator_traits，我们可以对 advance 实践先前的伪代码：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NDVkM2EwOGVkMzc0YWZkNDhmNTEyNGYxY2VlMDFhZjZfVzZHbFVSVEd5RUdzdnowcGd6VVFIWU9VV0pIbWRoM2FfVG9rZW46Ym94azRiUlllYWY2ZGx4YU51cE5FeHNjcGFmXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>其实上述代码会导致编译问题，IterT 类型可以在编译器知道，但 if 语句却是在运行期才确定。</p><p>我们真正想要的是一个条件式，也就是 if…else 语句，判断“编译器确定的类型”。利用 C++ 的重载可以实现它。</p><p>当我们重载某个函数 f，必须详细叙述各个重载件的参数类型。当我们调用 f，编译器便根据传来的实参选择最适当的重载件。这正是一个针对类型而发生的“编译器条件式”。为了实现这个设想，我们定义一个函数 doAdvance 来作为被重载函数：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NzAwNTM2Njk4ZjFmYmNiNjc2Y2NkODdjMjc5MjdmMjRfZXRvM01BVGgyMWlLMEJUeEhwWHlNYVVEN09vQTc4anNfVG9rZW46Ym94azRjOXJwaXQ2bVhVWUpUd2ExUW42NjlmXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>有了这些 doAdvance 重载版本，advance 需要做的就是调用它们并额外传递一个对象，后者必须带有适当的迭代器分类。于是编译器运用重载解析机制调用适当的实现代码：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NGY4OGE5NDc2NmYzNzIyNDViZjY4NDU3ODI1ZjUxMzVfc0JtM1FsQ2hXMGNiTTdqcHQwY2ozbEp1akpmUXFna2dfVG9rZW46Ym94azQ4OWFMcnBoSVNnT0xOTzBlcTRlNm9jXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><h4 id="47-4-如何使用一个-traits-class">47.4 如何使用一个 traits class</h4><ul><li>建立一组重载函数或函数模板（例如 doAdvance）,彼此间的差异只在各自的 traits 参数</li><li>建立一个控制函数或函数模板（例如 advance），它调用上述那些函数（doAdvance）并传递 traits class 所提供的信息。</li></ul><p>Traits 广泛运用于标准库，其中包括 iterator_traits，它除了提供 iterator_category ，还提供另四份迭代器相关信息（比如 value_type，见条款 42）。</p><p>除此之外，还有 char_traits 用来保存字符类型的相关信息，以及 numeric_limits 用来保存数值类型的相关信息，例如某数值类型可表现的最小值和最大值。</p><p>std 还包括许多 traits classes 用以提供类型相关信息，包括 is_fundamental<T> （判断 T 是否为内置类型），is_array<T>（判断 T 是否为数组类型），以及 is_base_of&lt;T1, T2&gt;（T1 和 T2相同，或者 T1 是 T2 的 base class）</p><h4 id="47-5-总结">47.5 总结</h4><p>Traits class 使得“类型相关信息”在编译器可用。它们以 templates 和 “templates 特化”完成实现。</p><p>整合重载技术后， traits classes 有可能在编译器对类型执行 if…else 测试</p><h3 id="条款-48：认识-template-元编程">条款 48：认识 template 元编程</h3><p>Template metaprogramming（TMP，模板元编程）是编写 template-based C++ 程序并执行于编译期的过程。</p><p>所谓 template 元程序，就是 C++ 写成，执行于 C++ 编译器内的程序。</p><p>TMP 是于 1990s 初期被发现，后被证明十分有用。</p><p>TMP 有以下优点:</p><ol><li>它让某些事情更容易，如果没有它，那些事情将是困难的，甚至不可能的。</li><li>template metaprogram 执行于 C++ 编译期，因此可以将工作从运行期转移到编译期。</li><li>使用 TMP 的 C++ 程序可能在每一方面都更高效：较小的可执行文件，较短的运行时间，较少的内存需要。</li></ol><p>缺点是：编译时间变长了。</p><p>考虑 条款 47 的 STL advance 伪代码：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=MmNlYWVmZTNhYTk2NDljMWVkYjI3MTU2Y2IwNWQ4Y2VfWjlOYmVEVVdhYWdHZUdtOUJIeDk4bHBRSVdDSUY3RGlfVG9rZW46Ym94azQwWllvaG9GcnNVc2VmUDBsSEdQTVJoXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>我们可以使用 typeid 来实现上述伪代码。</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=MDNhODU0NGE4MDZhNTE2Mjg0YmNiZmMxZWQyM2QwYjBfa3JBQk1xR1hScjFrQnIxMmRxMkd6RjdNSHFScHFmY3pfVG9rZW46Ym94azRRQWl5NEJ3V09RNnFwU1E0aElRTVpiXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>在此方案种：</p><ol><li>类型测试发生于运行期而非编译期。</li><li>“运行期类型测试”代码会出现在可执行文件中。</li></ol><p>为了支持下述调用：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=MzcyYzdjOTM4ODgwYWNjYjIyY2ZmNmNlMjBiZjU4MDhfbEhQTm44UGJ6VjlvZFlWVDVkanU4SFZqVTM5RjI0cUJfVG9rZW46Ym94azRiQXpoV1hFTjRjTmU2UWVFUWV0NVJjXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>我们这样写 advance：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=YjYxMGY1ZjRmNTgwNmYyMjExMGM0ZTQ3NjljNmYyNjZfUXZsV3lROUJmaHdGTFFCSjNoYVNwSnFmWEFMOTg3UUVfVG9rZW46Ym94azRzOUNSMTV5OXBwZUkzb3BwdzdSSjZiXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>上述代码存在的缺陷：list<int>::iterator 并不是 random access 迭代器，它并不支持 +=，所以代码中的 if 语句从不会被执行，但编译器必须确保所有代码都有效，纵使是不会执行起来的代码。与此对比的是 traits-base TMP 解法，其针对不同类型而进行的代码，被拆分为不同的函数，每个函数所使用的操作都可以用于该函数所对付的类型。</p><p>TMP 已被证明是个“图灵完全”机器，意思是它的威力大到可以计算任何事物。使用 TMP 可以声明变量，执行循环，编写及调用函数。</p><p>条款 47 所展示的 TMP is…else 条件句由 template 和其特化表现出来，不过那是汇编语言层级的 TMP，针对 TMP 而设计的程序库（例如 Boost’s MPL）提供了更高层级的语法。</p><p>TMP 中的循环由递归实现，它并不涉及递归函数调用，而是涉及“递归模板具现化”。</p><p>编译期计算阶乘可以算是 TMP 的 Hello world 程序，该程序示范如何通过“递归模板具现化”实现循环，以及如何在 TMP 中创建和使用变量：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=YzIyOTNkNjFlZmUzNmJlYmIxNmYxNzlhOGU3ZGRjYzNfaVQxek9GNkptRTUyVVFzWTNIYkJUamNqZ1VLOXhyQTZfVG9rZW46Ym94azRvRFhGaXdMVDRQNHZmN2czRG5iOWljXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>调用 Factorial<n>::value 就可以得到 n 阶乘值，但 n 必须是编译期常量。</p><p>循环发生在 template 具现体 Factorial<n> 内部使用另一个 template 具现体 factorial<n-1>时。和所有递归调用一样，我们需要一个特殊情况来结束递归，这个便是 template 特化体 Factorial&lt;0&gt;。</p><p>每个 Factorial template 具现体都是一个 struct，每个 struct 都使用 enum hack 声明一个名为 value 的 TMP 变量，value 用来保存当前计算所得的阶乘值。由于 TMP 以“递归模板具现化”取代循环，每个具现体有自己的一份 value，而每个 value 有其循环内的适当值。</p><p>TMP 可以达成什么目标：</p><ol><li>确保量度单位正确。使用 TMP 可以确保在编译期程序中所有度量单位的组合都正确，不论其计算多么复杂。</li><li>优化矩阵运行：条款 21 提到过的 operator* 函数必须返回新对象，条款 44 又导入了一个 SquareMatrix class。例如以下代码：</li></ol><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ZTZiNjRmZGRjNzI1YjJjNDU5MjNjNDFhNDc1ZGNmY2FfczU4aFRqcHQwZnpVNlBPbXVvdTBoc0pIc09YVmRnZE1fVG9rZW46Ym94azRDV0duWGJuWE9VYkNveUo4ekFDRm03XzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>以“正常的”函数调用动作计算 result，会创建 4 个暂时性矩阵，每一个用来存储 operator* 的调用结果。如果使用高级的 TMP 相关的 template 技术，即所谓的 expression templates ，就有可能消除那些灵时对象并合并循环。于是 TMP 软件使用较少的内存，执行速度更快。</p><ol><li>可以生成客户定制的涉及模式实现品，设计模式如 Strategy，Observer，Visitor 等等都可以多种方式实现出来。</li></ol><h4 id="总结-16">总结</h4><p>TMP 将工作由运行期移往编译期，可以实现早期错误侦测和更高的执行效率。</p><p>TMP 可被用来生成“基于政策选择组合”的客户定制代码。</p><p>我的理解如下：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ZTcwNmEyZGZjOTJiMmY5NmIyMTBiMGY2M2Q4NDY3NDFfbEpBcjkxOXN3ek9lZWdhZmNTRnNGaW9nMG81V2VVY3lfVG9rZW46Ym94azRoQ2lEN1ZZbWV5RlZ2NDNqMmFWZXdVXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><h2 id="八、定制-new-和-delete">八、定制 new 和 delete</h2><p>本章的重点在于：operator new 和 operator delete，配角是 new-handler，当 operator new 无法满足客户的内存需求时所调用的函数。</p><h3 id="条款-49：了解-new-handler-的行为">条款 49：了解 new-handler 的行为</h3><p>当 operator new 无法分配足够内存时，它会抛出异常，在以前它会返回一个 null 指针。当 operator new  抛出异常之前，它会先调用一个客户指定的错误处理函数，名叫 new_handler 的全局函数，为了指定该函数，客户必须调用 set_new_handler，该函数是声明于 <new> 的一个标准库程序。</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ZWZlNTU3YzAzMTBlNzc0MzJlMDlmMWU4Mjk2YTI4YzJfeTNkTG8xTEJaQTVEWjFMV2Y1dWk3ZVJIMVpUTWlmUk5fVG9rZW46Ym94azRVRm56MGROVFZZMlBpNXlTWDloVXZoXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>new_handler 是个函数指针，set_new_handler 则是“获得一个new_handler 并返回一个 new_handler”，获得的 new_handler 用于设置当前的 new_handler 函数，返回之前的 new_handler 函数。</p><p>我们可以这样使用它们：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=YzUzOTMxNmZkMWQ2M2Q5NzE4MzkxNGUxNGMxNjFmMTNfTFlmY3dvNTFFTEZYTVVJb1ZaNTI2NUgxTEt5YTdmOVRfVG9rZW46Ym94azRjYXNCdXZhN0YxNERaMUNaMnY5TUdmXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ZTY1Njk0ZjY4NjliMjk0Mjg4YzA3NzAwNjA3ODgwODJfenVWYUd6VG4xQzZkRVFMUXVGd3dQaU90Rmc3RUozVHZfVG9rZW46Ym94azRRVVJjc0J2bzA3ckpPQXhydmtLbUhnXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>当 operator new 无法分配足够的空间时， outOfMem 会被调用。</p><p>一个设计良好的 new-handler 函数必须做以下事情：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=YWUyYmM5MWQyOTEzYTA5MDUzYzUzNWRjMGJlZjY3NDNfZWI1Q2hCM0ttR1FNb1BKNFhUYWZSQVE2ZkJqMVpwc1JfVG9rZW46Ym94azRmRlM3d1k0MjVCT0NWc2d1cGp1eTZiXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><h4 id="模拟-class-专属-new-handler">模拟 class 专属 new_handler</h4><p>如下图所示：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ZjI5YjE2OGFkNzhjM2Y3YTk0OWQwZDVlMTUyNWJkZGVfQ0h6WVVrb2RIdTBuR0ppd3BWTWhYeUhhbXBMbmlnYmJfVG9rZW46Ym94azRwbDc5UU1UNkVrQ3RyWFlrU09IWmRkXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>C++ 并不支持 class 专属的 new-handler，但可以自己实现这种行为。</p><p>例如：我们打算处理 Widget class 的内存分配失败的情况，如下所示：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ODY4YzE0Njk0ZWI2YTA3ZDg2MjU2ODczNzlmOGZjODhfOHVBck5sa1R6eVQ1VXZmdnVZekxhcEdqSGpBWFpFZmlfVG9rZW46Ym94azRqNVlsWk5lckZwUTRmVWE0cmt0OHhmXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>关于上述代码有一点需要注意，一般情况下 static 成员必须在 class 的定义式之外被定义。</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NWVmNDk2MGI3M2E1MjgyNDA4Yjk4ZTcyNmIxOGY0MDhfbjg0Q21iWVVKM2dWTzdCUGo4Y0JHS3NJcnNJc2RWRmxfVG9rZW46Ym94azRGTW5OcExubU1HdnVQZERneXZEZzZiXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>Widget 内的 set_new_handler 函数将它获得的指针存储起来，然后返回先前存储的指针。这也正是 std::set_new_handler 的做法：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ODljMjIyM2U5NjI3Y2RmYTk2NWM1ZmM2YzQzOGJhYWJfaXJsNUJMZGFCR1g0WGFFZzdNRTMwOVhVaHNvNWtDcjRfVG9rZW46Ym94azRaTTNaeTBMMHY1RG1wQnhheFpaaEhkXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>此处的 new_handler 指针需要作为资源处理，即在调用特定对象的 new 时设置 new_handler 指针，使用完之后需要恢复以前的 new_handler 指针。为此我们使用 RAII 来管理 new_handler 。如下所示：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=Mzg1ODg4NGVjODhmZGVlYmE0MzM2MDZjZGY2NGJlNmFfWlZPUFVDRnA1WjlsU0dnMWRTeWFEbE5MbzlHYjh2UUFfVG9rZW46Ym94azQxUFRnbmZkekdDeEtpa2s0ZzNBM21nXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>现在 Widget::operator new 的实现就比较简单了：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=OGExZjU1YmFiZDgyYTE3YWM0ZmQ0MTRlZjYxOTExMWFfcEIySVlPYWpWZGxucWxhdXNtSnBkbnhXSWdJVlV5Q1JfVG9rZW46Ym94azQ5VnByMm02UlRFcXdrMXZ0RTQ0NlZiXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>Widget 的客户可以如下调用：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NWJlM2RlYTVlMDhhYjViYzAzN2ExMGNmNzEyMjc0ZWZfY3hRZTJPU3hkdFZVVVpManRKa01Xd2NHb0RYYWNFZ1lfVG9rZW46Ym94azRhcVBZSkRnaVJxaFNWRjdjQThBM2hnXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><h4 id="模板化">模板化</h4><p>以上代码只对 Widget 有效，我们可以将上述代码模板化，这样就可以用相同的代码支持不同的自定义类型。这里暂略，请参考《Effective C++ 第三版》245页。</p><h4 id="总结-17">总结</h4><ul><li>set_new_handler 允许客户指定一个函数，在内存分配无法满足时被调用。</li></ul><h3 id="条款-50：了解-new-和-delete-的合理替换时机">条款 50：了解 new 和 delete 的合理替换时机</h3><p>什么时候我们可以替换编译器提供的 operator new 或 operator delete 呢？下面给出三个最常见理由：</p><ol><li>用来检测运用上的错误：例如，一个很常见的错误是 “overruns”（写入点在分配区块尾端之后）或 “underruns”（写入点在分配区块值之前），我们可以分配额外的空间，例如在所分配内存的前后各放置一个签名，然后在 operator delete 中检查两个签名是否被改写，就可以判断是哪个指针犯了上述错误。</li><li>强化效能。编译器所提供的 operator new 和 operator delete 是为了各种场合而生，所以它不会在任何场景下都百分百高效，我们可以针对特定的场合替换 operator new 和 operator delete 会提高代码运行效率。</li><li>收集使用上的统计数据。为了定制 new 和 delete，我们需要确定分配区块的大小，以及分配策略（先进先出，后进后出等等）。为了收集上述信息，我们可以用定制型的 new 和 delete 收集这些信息。</li></ol><p>例如，下面的代码可以检测 “overruns”（写入点在分配区块尾端之后）或 “underruns”（写入点在分配区块值之前）错误，该实现还不完善，稍后指出：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=OWI5MTg1MDJiNjNjMDcyODg5MmRiMTA3MDE5ZDY2NzNfdHFUSkx5NGpzdGpBSnJ0elhHTjUyOEd4ZWdxT09ZZWFfVG9rZW46Ym94azQ4RUNxY2N2UGx1ZkZSMEM3RjBXWEpoXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>上述代码存在的问题：</p><ul><li>并未考虑内存对齐问题：许多计算机体系结构要求特定类型必须放在特定的地址上。例如：32 位系统可能要求指针的地址必须是 4 的倍数（four-byte aligned）。如果没有奉行这个约定，可能会导致硬件异常，或降低内存寻址效率（X86 架构）。malloc 就是以这种要求工作的，返回一个来自 malloc 的指针是安全的，但上述代码返回的是来自 malloc 且偏移一个 int 大小的指针，没人能保证它的安全。</li><li>条款 51 会说明，operator new 应该内含一个循环，反复调用某个 new-handling 函数，这里没有。</li></ul><h4 id="总结-18">总结</h4><p>替换缺省的 new 和 delete 有以下优点：</p><ol><li>检测运用错误。</li><li>收集动态分配内存的使用信息，</li><li>增加分配和归还的速度。</li><li>降低缺省内存管理器带来的空间额外开销。（针对小型对象而开发的分配器，例如 Boost 的 Pool 程序库）本质上消除了这样的额外开销。</li><li>弥补缺省分配器中的非最佳齐位。例如：x86 体系，double 的访问速度最快是 8-byte 对齐。但编译器自带的 operator new 并不保证对动态分配而得的 double 采用 8-byte 对齐。</li><li>将相关对象集中管理：如果某个数据结构往往被一起使用，如果为此数据结构创建另一个 heap，可以降低“内存页错误（page faults）”的频率。</li><li>获得非传统的行为：例如将归还的内存初始化为 0，增加应用程序的安全性。</li></ol><h4 id="-2"></h4><h3 id="条款-51：编写-new-和-delete-时需要固守常规">条款 51：编写 new 和 delete 时需要固守常规</h3><p>自定义 operator new 需要遵守以下规则：</p><ol><li>返回正确的值，内存不足时必须调用 new-handling 函数</li><li>必须对付零内存需要。</li></ol><p>operator new 返回一个指针指向那个内存，内存不足时抛出一个 bad_alloc 异常。不过，在分配失败时，它会反复调用 new-handling 函数，只有当指向 new-handlig 函数的指针是 null，operator new 才会抛出异常。</p><p>C++ 规定，即使客户要求 0 bytes，operator new 也得返回一个合法的指针，如下列代码所示：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ZmNmNzgzZWZjOTZlZmJhNDYwZTJjZDlmMTgzNWFkMjhfUDF5RHJLNjZZbXlYclpHeTdBakJMYUNmTXJjTTM1SGRfVG9rZW46Ym94azR3VXRCVldkTXMySVBadGVxUU1FSlNjXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NjFjMDIyMzAyNGYxZTlkZmE3NDY4MzJkYzhkMzg0MDVfSzJocm42MnlQeXFoTlI1enNtdGJPMHhsUXlHQXRrc1hfVG9rZW46Ym94azR2dWxrVHFhaTc1R3N3Mk52akRYSW9lXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><h4 id="当涉及到继承时">当涉及到继承时</h4><h5 id="new">new</h5><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NDFjNGUyOTgzZmQ0MmFhNDAzYTk0OGY5ODA4Mzg3ZTNfaFZhZVBHQUpJZ0hKV0JTbUk2djh4VHZ1NXlVaUZmb2dfVG9rZW46Ym94azREbkRpWThSRUdaM0kyOGkzek1KSm5oXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>派生类指针，却调用 Base::operator new处理此问题的最佳做法如下：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=M2NmN2U3ODg0OTI1Nzc2Mjk0NzI1YzdiOTkzMGFkYjFfQXBObzZaa1ZCVlZZSzRuRzJzOWJDcXhOWjU2ZDlxdU9fVG9rZW46Ym94azRMYlZWdzZuM2hJRWlQVmVaNGdkeVZqXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><h5 id="delete">delete</h5><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ZGE5MjcyZjhhMzYxYTBiMDMwYzZjMDZlMWVkMWM3MWNfRzBzQ3NEbDZEa0x4NktQNGU0Ymo2cnMxTjBLNU1UdUhfVG9rZW46Ym94azQ4ZjBOejBPRmdPRzZhWWd5eVo1cWFkXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>如果被删除的是 null 指针，则不做任何事情：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=Zjc4M2U1NGQ3NDk1MjI0YzE4Y2YyMGFmODYyNTNkNzdfdWo0Q1k1MUNBNElmSWdTT0ltNDAxMldHNHVMaEQzYXpfVG9rZW46Ym94azR3eDBCblpycExmZVZTZ3I1ZFpzS2toXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><h4 id="总结-19">总结</h4><ul><li>operator new 应该内含一个无限循环，并在其中尝试分配内存，如果它无法满足需求，就该调用 new-handler。它也应该能处理 0 bytes 申请。class 专属版本则还应该处理“比正确大小更大的（错误）申请”</li><li>operator delete 应该在收到 null 指针时不做任何事。class 专属版本还应该处理“比正确大小更大的（错误申请）”。</li></ul><h3 id="条款-52：写了-placement-new-也要写-placemen-delete">条款 52：写了 placement new 也要写 placemen delete</h3><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ODMyNTY1ZTVlMGIzYjEyY2E4YjJhNDcxOGVjYWI1ZTZfVTdzelhiQmljNnA0VElXSjlJZnpnbVJjQkh5NGI1dXZfVG9rZW46Ym94azRFY1pSemxMMHhJN2F0RTlCV2pld2lnXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>上述代码有两个步骤，一个是用于分配内存的 operator new，一个是 Widget 的 default 构造函数。假设第一个调用成功，第二个抛出异常，步骤一分配的内存必须被释放，否则会造成内存泄漏。</p><p>完成上述任务的责任落在 C++ 运行期系统上。运行期系统会高高兴兴地调用步骤一所调用的 operator new 所对应的 operator delete 版本，前提是目期拥有正常签名式的 new 和 delete ：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NjE3YzRiOWE4ODAzMmZiMTVkZjE0N2NhNWRmNmVhYmZfZHBRcFBxQXNwTlV3VVJweXB0TjJBZzBReDBLQ09xcHNfVG9rZW46Ym94azRaY2lOd3lPWndSdGtSTEl2SHpCdnVoXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ODdlMTAyMDhjMThlZGY1MDA2NzEwYmU5YjY1OTQ2ODdfZkQxZFNPYVBwcEJkdm9icDU1emEySE5UYzFqRkY5V1ZfVG9rZW46Ym94azRCSnl0UEJWTkVEd09HTGFTcHlBejJmXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><p>命名遮盖问题</p><p>凡是想以自定形式扩充标准形式的客户，可利用继承机制及 using 声明式取得标准形式：</p><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=ZGUzMTE4M2EwY2YyMmM5MGFhYjRlNjBkOWRjZTc5NTlfdUZ3NUJTZ2NRWnVlRWlRTHVMMURQTEN6REhxbFJob21fVG9rZW46Ym94azRPNG1TMkFVMHRMeWpuOUdKdFBZNUFkXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p><h4 id="总结-20">总结</h4><p><img src="https://xiaomi.f.mioffice.cn/space/api/box/stream/download/asynccode/?code=NDk0ZjM1MmUzOTMxMjM1ZWFhNzFlNWI0MjgxODYyYjNfaks5eWMzV1hUbVB1dHZjZGZLd01FUHRtUlJLRVhmN1ZfVG9rZW46Ym94azRVMXpzSDVSWkYxVURaamE4azRLbXZoXzE2NzM1MTg5NTA6MTY3MzUyMjU1MF9WNA" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> Effective cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ARM 移位指令</title>
      <link href="/2022/01/20/arm-yi-wei-zhi-ling/"/>
      <url>/2022/01/20/arm-yi-wei-zhi-ling/</url>
      
        <content type="html"><![CDATA[<p>移位指令是一组经常使用的指令，它包括移位指令（含算术移位指令，逻辑移位指令），循环移位指令（含带进位循环移位指令），其作用就是将目的操作数的所有位按操作符规定的方式移动指定的位数。</p><p>ARM 中的移位指令如下：ASR, LSR, LSL, ROR和 RRX，直接写入目标寄存器中。</p><span id="more"></span><p><code>S</code>是一个可选的后缀，如果指定了 S 则根据操作会更新条件标志位。会被更新的标志位如下：</p><p>N：为 1 表示运算的结果为负数，为 0 表示运算的结果为正数。</p><p>Z：为 1 表示运算的结果为零，为 0 表示运算的结果不为零。</p><p>C：表示被移出的最后一位。</p><h2 id="ASR">ASR</h2><p>叫做算术右移指令（Arithmetic shift right），从最左边开始依次往右移动，左端用第 31 位值填充，右端移动之后超出寄存器范围的位放入状态寄存器的 Carry Flag 位中。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wangjunstf/pics//images/image-20220120150422054.png" alt="image-20220120150422054"></p><h2 id="LSR">LSR</h2><p>叫做逻辑右移指令（Logical shift right），从最左边开始依次往右移动，左端用 0 填充，右端移动之后超出寄存器范围的位放入状态寄存器的 Carry Flag 位中。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wangjunstf/pics//images/image-20220120151139635.png" alt="image-20220120151139635"></p><p>常用于除于 2 的 n 次幂，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV R0,R1,LSR #4                ; R0 = R1/(2**4)        </span><br></pre></td></tr></table></figure><h2 id="LSL">LSL</h2><p>叫做逻辑左移指令（Logical shift left），从右边开始依次向左移动，右边用 0 填充，左边超出寄存器范围的位放入状态寄存器的 Carry Flag 位中。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wangjunstf/pics//images/image-20220120152429454.png" alt="image-20220120152429454"></p><p>常用于乘于 2 的 n 次幂，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MOV R0,R1,LSL #4               ; R0 = R1*(2**4)</span><br></pre></td></tr></table></figure><h2 id="ROR">ROR</h2><p>叫做循环右移指令（Rotate right），从左往右依次循环移动，左端用右端移出的位来填充，移入最左边的位同时也进入状态寄存器的 Carry Flag 位中。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wangjunstf/pics//images/image-20220120153234827.png" alt="image-20220120153234827"></p><h2 id="RRX">RRX</h2><p>叫做扩展的循环右移指令（Rotate right with extend），从左往右循环右移，最右边的位进入状态寄存器的 Carry Flag 位中，Carry Flag 位进入最左边的位中。如下图所示：</p><p><img src="https://cdn.jsdelivr.net/gh/wangjunstf/pics//images/image-20220120155205572.png" alt="image-20220120155205572"></p><h2 id="参考">参考</h2><p><a href="https://developer.arm.com/documentation/dui0489/h/arm-and-thumb-instructions/shift-operations">https://developer.arm.com/documentation/dui0489/h/arm-and-thumb-instructions/shift-operations</a></p>]]></content>
      
      
      <categories>
          
          <category> ARM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ARM </tag>
            
            <tag> 移位指令 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用 Lisp 实现一个简单的数据库</title>
      <link href="/2021/11/16/yong-lisp-shi-xian-yi-ge-jian-dan-de-shu-ju-ku/"/>
      <url>/2021/11/16/yong-lisp-shi-xian-yi-ge-jian-dan-de-shu-ju-ku/</url>
      
        <content type="html"><![CDATA[<p>第一次认识 Lisp 是通过《黑客与画家》这本书，书中对 Lisp 赞不绝口，声称现在编程语言的发展也只是赶上了 1958 年的 Lisp 语言的水平。很多人就有疑问了，一个诞生于 1958 年的语言，计算机技术不是日新月异吗，为什么 Lisp 还没有过时？书中是这样说的，Lisp 是数学，数学是不会过时的。在书的作者 Paul Graham 的力荐下，对 Lisp 充满了浓厚的兴趣，就开始了 Lisp 的学习之旅。由于之前学习的繁忙，加上 Lisp 在&quot;主流编程界&quot; 好像并不受待见，我也没有一直持续学习，而是学习更加受欢迎的 C，Python 等语言，毕竟以后是要吃饭的嘛。在大学生涯的最后一段时间里，计算机基础知识学的越多，越发觉得编程语言的有趣之处，也明白了所有编程语言其实都是图灵等价的，即一个功能可以用任何编程语言实现，只不过是实现方式不一样。编程语言学的越多，越来越感受到 Lisp 本身设计的优雅，怀着一份好奇心，我又重新走进了 Lisp 的世界。</p><span id="more"></span><p>今天用一个例子来介绍 Lisp 的优雅之处。很多人可能有这样的想法，在用编程语言构建真实的软件之前，你必须先学会这门语言。现在，我们用 Lisp 中极少量的元素，来实现一个简单的数据库，用来存储 MP3 歌曲信息。</p><h2 id="CD-和记录">CD 和记录</h2><p>数据库包括多条 CD 记录，每条 CD 记录包括以下四个信息：CD 标题，艺术家信息，评价信息(满分 10分)，是否别烧录(布尔值)。</p><p>先介绍下等下需要用到的两种数据结构：</p><h3 id="列表">列表</h3><p>称为 list，称为列表，类似于 Python 中的列表，例如：</p><p>以下环境类似于 Python 的交互模式：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (<span class="name">list</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br><span class="line">(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure><h3 id="属性表-property-list">属性表(property list)</h3><p>称为 plist</p><p>类似于 Python 中的字典，或 C++ 中的 map，由键值对组成，例如：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (<span class="name">list</span> <span class="symbol">:a</span> <span class="number">1</span> <span class="symbol">:b</span> <span class="number">2</span> <span class="symbol">:c</span> <span class="number">3</span>)</span><br><span class="line">(<span class="symbol">:A</span> <span class="number">1</span> <span class="symbol">:B</span> <span class="number">2</span> <span class="symbol">:C</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>a，b，c 分别是是键，1，2，3 分别是值</p><p>关于 Lisp 函数相关的介绍，不明白的小伙伴请参考之前的：<a href="https://wangjunstf.github.io/2021/04/26/common-lisp-han-shu/">Common Lisp函数</a></p><h3 id="属性表查询">属性表查询</h3><p>使用 getf 函数，例如：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (<span class="name">getf</span> (<span class="name">list</span> <span class="symbol">:a</span> <span class="number">1</span> <span class="symbol">:b</span> <span class="number">2</span> <span class="symbol">:c</span> <span class="number">3</span>) <span class="symbol">:a</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line">CL-USER&gt; (<span class="name">getf</span> (<span class="name">list</span> <span class="symbol">:a</span> <span class="number">1</span> <span class="symbol">:b</span> <span class="number">2</span> <span class="symbol">:c</span> <span class="number">3</span>) <span class="symbol">:b</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>有了上述消息，就可以写出一个 make-cd 函数，它以参数的形式接受 4 个字段然后返回一个 plist</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> make-cd (<span class="name">title</span> artist rating ripped)</span><br><span class="line">  (<span class="name">list</span> <span class="symbol">:title</span> title <span class="symbol">:artist</span> artist <span class="symbol">:rating</span> rating <span class="symbol">:ripped</span> ripped))</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (<span class="name">make-cd</span> <span class="string">&quot;Roses&quot;</span> <span class="string">&quot;Kathy Mattea&quot;</span> <span class="number">7</span> <span class="literal">t</span>)</span><br><span class="line">(<span class="symbol">:TITLE</span> <span class="string">&quot;Roses&quot;</span> <span class="symbol">:ARTIST</span> <span class="string">&quot;Kathy Mattea&quot;</span> <span class="symbol">:RATING</span> <span class="number">7</span> <span class="symbol">:RIPPED</span> T)</span><br></pre></td></tr></table></figure><h2 id="录入-CD">录入 CD</h2><p>上述只算一个单一记录，还不算一个数据库，我们还需要一个更大的结构来保存记录。出于简化目的，以下使用一个全局变量 *db* ，名字中的星号是 Lisp 的全局变量名的命名约定。全局变量可以用 DEFVAR 宏来定义，不明白什么是宏也没关系，先暂时将它理解为函数。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defvar</span> *db* <span class="literal">nil</span>)</span><br></pre></td></tr></table></figure><p>使用 PUSH 宏为 *db*添加新的项，定义一个函数来给数据库增加一条记录：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> add-record (<span class="name">cd</span>) (<span class="name">push</span> cd *db*))</span><br></pre></td></tr></table></figure><p>现在可以将 add-record 和 make-cd 一起使用来为数据库添加新的 CD 记录。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (<span class="name">add-record</span> (<span class="name">make-cd</span> <span class="string">&quot;Roses&quot;</span> <span class="string">&quot;Kathy Mattea&quot;</span> <span class="number">7</span> <span class="literal">t</span>))</span><br><span class="line"></span><br><span class="line">((<span class="symbol">:TITLE</span> <span class="string">&quot;Roses&quot;</span> <span class="symbol">:ARTIST</span> <span class="string">&quot;Kathy Mattea&quot;</span> <span class="symbol">:RATING</span> <span class="number">7</span> <span class="symbol">:RIPPED</span> T) <span class="number">3</span> <span class="number">13</span> <span class="number">123</span>)</span><br><span class="line">CL-USER&gt; (<span class="name">add-record</span> (<span class="name">make-cd</span> <span class="string">&quot;Pork Face&quot;</span> <span class="string">&quot;Laddy&quot;</span> <span class="number">9</span> <span class="literal">t</span>))</span><br><span class="line">((<span class="symbol">:TITLE</span> <span class="string">&quot;Pork Face&quot;</span> <span class="symbol">:ARTIST</span> <span class="string">&quot;Laddy&quot;</span> <span class="symbol">:RATING</span> <span class="number">9</span> <span class="symbol">:RIPPED</span> T)</span><br><span class="line"> (<span class="symbol">:TITLE</span> <span class="string">&quot;Roses&quot;</span> <span class="symbol">:ARTIST</span> <span class="string">&quot;Kathy Mattea&quot;</span> <span class="symbol">:RATING</span> <span class="number">7</span> <span class="symbol">:RIPPED</span> T) <span class="number">3</span> <span class="number">13</span> <span class="number">123</span>)</span><br></pre></td></tr></table></figure><p>查看数据库的内容：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; *db*</span><br><span class="line">((<span class="symbol">:TITLE</span> <span class="string">&quot;Pork Face&quot;</span> <span class="symbol">:ARTIST</span> <span class="string">&quot;Laddy&quot;</span> <span class="symbol">:RATING</span> <span class="number">9</span> <span class="symbol">:RIPPED</span> T)</span><br><span class="line"> (<span class="symbol">:TITLE</span> <span class="string">&quot;Roses&quot;</span> <span class="symbol">:ARTIST</span> <span class="string">&quot;Kathy Mattea&quot;</span> <span class="symbol">:RATING</span> <span class="number">7</span> <span class="symbol">:RIPPED</span> T) <span class="number">3</span> <span class="number">13</span> <span class="number">123</span>)</span><br></pre></td></tr></table></figure><p>这种输出方式可读性并不好，我们可以定义一个函数来格式化输出数据库信息：</p><p>lisp 中使用 format 函数来格式化输出字符串，它类似于 C 语言中的 printf</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> dump-db ()</span><br><span class="line">  (<span class="name">dolist</span> (<span class="name">cd</span> *db*)</span><br><span class="line">    (<span class="name">format</span> <span class="literal">t</span> <span class="string">&quot;~&#123;~a:~10t~a~%~&#125;~%&quot;</span> cd)))</span><br></pre></td></tr></table></figure><p>dump-db 使用如下：注意不要使用 PUSH 往 *db*里存入其它不相干信息，不然调用 dump-db 会产生异常，因为它是按照add-record 返回的 plist 来解析的。如果存入了其它信息，就将  *db* 置空：<code>(set1 *db* nil)</code></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (<span class="name">dump-db</span>)</span><br><span class="line">TITLE:    Pork Face</span><br><span class="line">ARTIST:   Laddy</span><br><span class="line">RATING:   <span class="number">9</span></span><br><span class="line">RIPPED:   T</span><br><span class="line"></span><br><span class="line">TITLE:    Roses</span><br><span class="line">ARTIST:   Kathy Mattea</span><br><span class="line">RATING:   <span class="number">7</span></span><br><span class="line">RIPPED:   T</span><br><span class="line"></span><br><span class="line">NIL</span><br></pre></td></tr></table></figure><h3 id="DOLIST宏">DOLIST宏</h3><p>类似于 C++ 中的 for-each 语法，用于遍历一个列表中的所有元素。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">dolist</span> (<span class="name">cd</span> *db*)</span><br><span class="line">    (<span class="name">format</span> <span class="literal">t</span> <span class="string">&quot;~&#123;~a:~10t~a~%~&#125;~%&quot;</span> cd))</span><br></pre></td></tr></table></figure><p>依次将 *db* 中的每个元素绑定到 db 上，对于每个 cd 值，使用 format 函数打印它。</p><h3 id="FORMAT">FORMAT</h3><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">format</span> <span class="literal">t</span> <span class="string">&quot;~&#123;~a:~10t~a~%~&#125;~%&quot;</span> cd)</span><br></pre></td></tr></table></figure><p>虽然看起来有些晦涩，但其实非常简单和灵活。<code>~a</code> 表示一个占位符，类似于 C语言中的 <code>%d</code>，<code>~%</code> 表示换行，类似于 C语言中的 <code>\n</code>，<code>~10t</code>类似制表符，产生足够的空格，以确保在处理下一个<code>~a</code> 之前将光标移动 10 列。当 format 看到<code> ~&#123;</code>，下一个被消耗的参数必须是一个列表，format 在列表上循环操作，处理位于 <code>~&#123;</code>于<code>~&#125;</code>之间的指令，同时在每次需要从列表上消耗掉尽可能多的元素。</p><p>从技术上讲，可以使用 format 在整个数据库本身上循环，从而将 dump-db 函数变为只有一行：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> dump-db2 ()</span><br><span class="line">    (<span class="name">format</span> <span class="literal">t</span> <span class="string">&quot;~&#123;~&#123;~a:~10t~a~%~&#125;~%~&#125;&quot;</span> *db*))</span><br></pre></td></tr></table></figure><p>这究竟是可怕还是酷，完全取决于你的看法。</p><h2 id="改进用户交互">改进用户交互</h2><p>使用 add-record 来添加 CD 记录显得太 Lisp 化了，如果想添加大量的记录，操作并不是很方便，可以写一个函数来提示提示用户录入任意条 CD 信息。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> prompt-read (<span class="name">prompt</span>)</span><br><span class="line">  (<span class="name">format</span> *query-io* <span class="string">&quot;~a: &quot;</span> prompt)</span><br><span class="line">  (<span class="name">force-output</span> *query-io*)</span><br><span class="line">  (<span class="name">read-line</span> *query-io*))</span><br></pre></td></tr></table></figure><p>format 输出一个提示信息。</p><p>force-output 刷新缓冲区，有时提示信息没有及时输出，使用该 force-output 可以强制输出提示信息。</p><p>read-line 从标准输入读取一行内容。运行结果如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (<span class="name">prompt-read</span> <span class="string">&quot;name&quot;</span>)</span><br><span class="line">name: stf</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;stf&quot;</span></span><br><span class="line">NIL</span><br></pre></td></tr></table></figure><p>现在可以将 prompt-read 和 make-cd 组合起来，从而构造一个可以根据提示输入每个值得到的数据中建立新的 CD 记录的函数。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> prompt-for-cd ()</span><br><span class="line">  (<span class="name">make-cd</span></span><br><span class="line">   (<span class="name">prompt-read</span> <span class="string">&quot;Title&quot;</span>)</span><br><span class="line">   (<span class="name">prompt-read</span> <span class="string">&quot;Artist&quot;</span>)</span><br><span class="line">   (<span class="name">prompt-read</span> <span class="string">&quot;Rating&quot;</span>)</span><br><span class="line">   (<span class="name">prompt-read</span> <span class="string">&quot;Ripped [y/n]&quot;</span>)))</span><br></pre></td></tr></table></figure><p>上面的代码基本正确，但是 prompt-read 总是返回字符串，对于Title 和 Artist 来说可以，但对于 Rating 和 Ripped 就不太好了，它们应该是一个数字和一个布尔值。取决于你想要一个多专业的用户接口，花在验证用户输入的数据上的努力可以是无止境的。现在采取一个简单但不安全的方法，将 Rating 对应的 prompt-read 包装在一个 Lisp 的 PARSE-INEGER 函数里，就像这样：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">parse-integer</span> (<span class="name">prompt-read</span> <span class="string">&quot;Rating&quot;</span>))</span><br></pre></td></tr></table></figure><p>这里存在的问题就是 parse-integer 的默认行为是当它无法从字符串中正确解析出整数或者字符串里含有任何非数字的垃圾值时直接报错。不过，它接受一个可选的关键字参数 :junk-allowed，可以让它适当地容忍一些，解析不出数字也不报错。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">parse-integer</span> (<span class="name">prompt-read</span> <span class="string">&quot;Rating&quot;</span>) <span class="symbol">:junk-allowed</span> <span class="literal">t</span>)</span><br></pre></td></tr></table></figure><p>上面的代码的一个问题就是，当不能从垃圾中解析出数字时，parse-integer 返回 NIL，为了让这个思路更加完善，可以将 NIL 当作 0 来看待。这时可以使用 OR 宏，它与 C 中的逻辑运算符 <code>||</code>很类似，具有短路特性，OR 宏接受一系列表达式，依次求值它们，然后返回第一个非空值，如果全部是空值，就返回空值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(OR (parse-integer (prompt-read &quot;Rating&quot;) :junk-allowed t) 0)</span><br></pre></td></tr></table></figure><p>修复 Ripped 的代码比较简单，只需使用 Common Lisp 的 Y-OR-N-P 函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(y-or-n-p &quot;Ripped [y/n]: &quot;)</span><br></pre></td></tr></table></figure><p>Y-OR-N-P 是相当健壮的，因为在没有得到 y,Y, n, N 时会提示重新输入。</p><p>综上所述，就能得到一个相当健壮的 prompt-for-cd 函数了。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> prompt-for-cd ()</span><br><span class="line">  (<span class="name">make-cd</span></span><br><span class="line">   (<span class="name">prompt-read</span> <span class="string">&quot;Title&quot;</span>)</span><br><span class="line">   (<span class="name">prompt-read</span> <span class="string">&quot;Artist&quot;</span>)</span><br><span class="line">   (<span class="name">OR</span> (<span class="name">parse-integer</span> (<span class="name">prompt-read</span> <span class="string">&quot;Rating&quot;</span>) <span class="symbol">:junk-allowed</span> <span class="literal">t</span>) <span class="number">0</span>)</span><br><span class="line">   (<span class="name">y-or-n-p</span> <span class="string">&quot;Ripped [y/n]: &quot;</span>)))</span><br></pre></td></tr></table></figure><p>可以添加一个循环来一次性输入多个 CD 记录。</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> add-cds ()</span><br><span class="line">  (<span class="name">loop</span> (<span class="name">add-record</span> (<span class="name">prompt-for-cd</span>))</span><br><span class="line">(<span class="name">if</span> (<span class="name">not</span> (<span class="name">y-or-n-p</span> <span class="string">&quot;Another?[y/n]: &quot;</span>)) (<span class="name">return</span>))))</span><br></pre></td></tr></table></figure><p>使用如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (<span class="name">add-cds</span>)</span><br><span class="line">Title: tom like rice</span><br><span class="line">Artist: larry</span><br><span class="line">Rating: <span class="number">6</span></span><br><span class="line"></span><br><span class="line">Ripped [y/n]:  (<span class="name">y</span> or n) n</span><br><span class="line"></span><br><span class="line">Another?[y/n]:  (<span class="name">y</span> or n) y</span><br><span class="line">Title: My sky</span><br><span class="line">Artist: ck</span><br><span class="line">Rating: <span class="number">7</span></span><br><span class="line"></span><br><span class="line">Ripped [y/n]:  (<span class="name">y</span> or n) y</span><br><span class="line"></span><br><span class="line">Another?[y/n]:  (<span class="name">y</span> or n) n</span><br><span class="line"></span><br><span class="line">NIL</span><br><span class="line">CL-USER&gt; *db*</span><br><span class="line">((<span class="symbol">:TITLE</span> <span class="string">&quot;My sky&quot;</span> <span class="symbol">:ARTIST</span> <span class="string">&quot;ck&quot;</span> <span class="symbol">:RATING</span> <span class="number">7</span> <span class="symbol">:RIPPED</span> T)</span><br><span class="line"> (<span class="symbol">:TITLE</span> <span class="string">&quot;tom like rice&quot;</span> <span class="symbol">:ARTIST</span> <span class="string">&quot;larry&quot;</span> <span class="symbol">:RATING</span> <span class="number">6</span> <span class="symbol">:RIPPED</span> NIL)</span><br><span class="line"> (<span class="symbol">:TITLE</span> <span class="string">&quot;Pork Face&quot;</span> <span class="symbol">:ARTIST</span> <span class="string">&quot;Laddy&quot;</span> <span class="symbol">:RATING</span> <span class="number">9</span> <span class="symbol">:RIPPED</span> T)</span><br><span class="line"> (<span class="symbol">:TITLE</span> <span class="string">&quot;Roses&quot;</span> <span class="symbol">:ARTIST</span> <span class="string">&quot;Kathy Mattea&quot;</span> <span class="symbol">:RATING</span> <span class="number">7</span> <span class="symbol">:RIPPED</span> T))</span><br><span class="line">CL-USER&gt; </span><br></pre></td></tr></table></figure><h2 id="保存和加载数据库">保存和加载数据库</h2><p>以上代码可以方便地给数据库添加新记录，但是最大的缺陷就是重启 Lisp 后数据就消失了。幸运的是，借助我们用来表示数据的数据结构，可以相当容易地将数据保存在文件里以后重新加载。下面是一个 sava-db 函数，其接受一个文件名作为参数并且保存当前数据库的状态：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> save-db (<span class="name">filename</span>)</span><br><span class="line">  (<span class="name">with-open-file</span> (<span class="name">out</span> filename</span><br><span class="line">       <span class="symbol">:direction</span> <span class="symbol">:output</span></span><br><span class="line">       <span class="symbol">:if-exists</span> <span class="symbol">:supersede</span>)</span><br><span class="line">    (<span class="name">with-standard-io-syntax</span></span><br><span class="line">      (<span class="name">print</span> *db* out))))</span><br></pre></td></tr></table></figure><p>with-open-file 宏会打开一个文件，并将其绑定到一个变量，然后执行一组表达式，然后再关闭这个文件，它还可以保证即便在求值表达式出了错也可以正确关闭文件，紧跟着 with-open-file 的列表并非函数调用而是 with-open-file 的一部分，它包括用来在 with-open-file 主体中写入的文件流的变量名，一个必须是文件名的值，以及一些控制文件如何打开的选项，<code>:direction :output</code> 表示 打开一个用于写入的文件，<code>:if-exists :supersede</code>表示如果存在同名文件就覆盖原来的文件。</p><p>一旦已经打开了文件，所需要做的就是使用 <code>(print *db* out)</code> 将数据库的内容打印出来。跟 FORMAT 不同的是，PRINT 将 Lisp 对象打印成一种可以被 Lisp 读取器读回来的形式。宏 with-standard-io-syntax 可以确保影响 PRINT 行为的特定一些变量可以被设置为它们的标准值。当把数据读回来时，我们将使用同样的宏来确保 Lisp 读取器和打印器的操作彼此兼容。</p><p>save-db 的参数应该是一个含有用户打算用来保存数据库的文件名地址的字符串，字符串确切形式将取决于它们正在使用的操作系统，例如在 Unix 系统下可能会这样调用 save-db</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (<span class="name">save-db</span> <span class="string">&quot;/Users/wangjun/Desktop/java/my-cds.db&quot;</span>)</span><br><span class="line">((<span class="symbol">:TITLE</span> <span class="string">&quot;My sky&quot;</span> <span class="symbol">:ARTIST</span> <span class="string">&quot;ck&quot;</span> <span class="symbol">:RATING</span> <span class="number">7</span> <span class="symbol">:RIPPED</span> T)</span><br><span class="line"> (<span class="symbol">:TITLE</span> <span class="string">&quot;tom like rice&quot;</span> <span class="symbol">:ARTIST</span> <span class="string">&quot;larry&quot;</span> <span class="symbol">:RATING</span> <span class="number">6</span> <span class="symbol">:RIPPED</span> NIL)</span><br><span class="line"> (<span class="symbol">:TITLE</span> <span class="string">&quot;Pork Face&quot;</span> <span class="symbol">:ARTIST</span> <span class="string">&quot;Laddy&quot;</span> <span class="symbol">:RATING</span> <span class="number">9</span> <span class="symbol">:RIPPED</span> T)</span><br><span class="line"> (<span class="symbol">:TITLE</span> <span class="string">&quot;Roses&quot;</span> <span class="symbol">:ARTIST</span> <span class="string">&quot;Kathy Mattea&quot;</span> <span class="symbol">:RATING</span> <span class="number">7</span> <span class="symbol">:RIPPED</span> T))</span><br></pre></td></tr></table></figure><p>将数据加载回数据库的函数如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> load-db (<span class="name">filename</span>)</span><br><span class="line">  (<span class="name">with-open-file</span> (<span class="name">in</span> filename)</span><br><span class="line">    (<span class="name">with-standard-io-syntax</span></span><br><span class="line">      (<span class="name">setf</span> *db* (<span class="name">read</span> in)))))</span><br></pre></td></tr></table></figure><p>这次不要在 with-open-file 指定 <code>:direction</code> 了，应该这次使用的是默认的 <code>:input</code>，并且与打印相反，使用 READ 来从流中读入，这是与 REPL 所使用的相同的读取器，可以读取任何可以在 REPL 提示里输入的 Lisp 表达式。尽管如此，在这种情况下，它将只是读取和保存表达式，并不会对它求值。再一次，with-standard-io-syntax是为了 save-db 和 load-db 在 print 数据时相同的基本语法。</p><p><code>setf</code> 宏是 Common Lisp 最主要的赋值操作符，它将其第一个参数设置成其第二个参数的求值结果，因此在 load-db 里 *db*变量将含有从文件中读取的对象，也就是由 save-db 所写入的那些列表的列表。值得注意的是：load-db 将改变  *db* 的值，如果已经往里添加了数据，但还没有调用 save-db 而直接调用 load-db 将丢失新添加的数据。</p><h2 id="查询数据库">查询数据库</h2><p>现在有了保存和重载数据的方法，以及一个便利的用户接口来添加新的记录，这样很快我们就会有足够多的记录以至于我们不想为了查看它有什么而每次都把整个数据库导出来。我们需要的是一种查询数据的方式，例如：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">select</span> <span class="symbol">:artist</span> <span class="string">&quot;Kathy Mattea&quot;</span>)</span><br></pre></td></tr></table></figure><p>然后就可以得到所有艺术家为 Kathy Mattea 的记录的列表。</p><p>函数 REMOVE-IF-NOT 接受一个谓词和一个列表，然后返回一个仅包含原来列表中匹配该谓词的所有元素所组成的新列表。谓词参数可以是任何接受单一参数并且返回布尔值的函数，除了 NIL 表示假以外，其余的都表示真。</p><p>例如，需要从一个数字组成的列表中解析出所有偶数，可以使用以下方法：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (<span class="name">remove-if-not</span> #&#x27;evenp &#x27;(<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span> <span class="number">6</span> <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> <span class="number">10</span>))</span><br><span class="line">(<span class="number">2</span> <span class="number">4</span> <span class="number">6</span> <span class="number">8</span> <span class="number">10</span>)</span><br></pre></td></tr></table></figure><p>这里的谓词是函数 evenp，当其参数是偶数时返回真，那个有趣的 <code>#'</code>记号是<strong>得到接下来的名字所对应的函数</strong>的简称。如果没有 <code>#'</code>的话，Lisp 把 evenp 当作一个变量的名字来对待并查找该变量的值，而不是函数。<code>'(1 2 3 4 5 6 7 8 9 10)</code>中的 `符号表示不对列表进行求值。</p><p>也可以给 REMOVE-IF-NOT 传递一个匿名函数。如果 EVENP 不存在，我们可以像下面这样来写前面的表达式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (remove-if-not #&#x27;(lambda (x) (= 0 (mod x 2))) &#x27;(1 2 3 4 5 6 7 8 9 10))</span><br><span class="line">(2 4 6 8 10)</span><br></pre></td></tr></table></figure><p>在这种情况下，谓词是这样一个匿名函数：<code>(lambda (x) (= 0 (mod x 2)))</code> ，它会检查其参数模 2 等于 0(偶数)。如果想用匿名函数来解析出所有的奇数，可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (remove-if-not #&#x27;(lambda (x) (= 1 (mod x 2)) ) &#x27;(1 2 3 4 5 6 7 8 9 10))</span><br><span class="line">(1 3 5 7 9)</span><br></pre></td></tr></table></figure><p>lambda 并不是函数名，它只是表面当前正在定义匿名函数。一个 lambda 表达式看起来很像一个 DEFUN ，单词 lambda 后面紧跟着形参列表，然后再是函数体。</p><p>为了用 remove-if-not 从数据库中挑选出所有 Kathy Mattea 的专辑，我们将需要一个可以在一条记录的艺术家字段是 “Kathy Mattea” 时返回真的函数。我们选择用 plist 来表达数据库里的记录，因为它可以使用 GETF 从 plist 解出给定名称的字段来，假设 cd 是数据库的一条记录，可以使用表达式：<code>(getf cd :artist)</code>解出艺术家的名字来。函数 EQUAL 当用于字符串参数时可以逐个字符地比较它们。因此 <code>(equal (getf cd :artist) &quot;Kathy Mattea&quot;)</code> 用于测试一个给定 CD 的艺术家字段是否等于 “Kathy Mattea”。现在需要将这个表达式包装在一个 LAMBDA 形式里从而得到一个匿名函数传递给 REMOVE-IF-NOT，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(remove-if-not</span><br><span class="line">#&#x27;(lambda (cd) (equal (getf cd :artist) &quot;Kathy Mattea&quot;)) *db*)</span><br></pre></td></tr></table></figure><p>也可以将其包装为一个函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(defun select-by-artist (artist)</span><br><span class="line">  (remove-if-not</span><br><span class="line"> #&#x27;(lambda (cd) (equal (getf cd :artist) artist)) *db*))</span><br></pre></td></tr></table></figure><p>除了根据 ARTIST 查询，我们还想根据 TITLE，RATING，RIPPED查询。我们可以写出一个更加通用的 select 函数，它接受一个函数作为其参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(defun select (selector-fn)</span><br><span class="line">  (remove-if-not selector-fn *db*))</span><br></pre></td></tr></table></figure><p><code>#'</code>去哪了，这种情况下我们并不希望 remove-if-not 去使用一个名为 selector-fn 的函数，我们想要它使用的是一个作为 select 的参数传递到变量 select-fn 里的匿名函数。不过 #’ 在调用 select 的时候需要。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (select #&#x27;(lambda (cd) (equal (getf cd :artist) &quot;ck&quot;)))</span><br><span class="line">((:TITLE &quot;My sky&quot; :ARTIST &quot;ck&quot; :RATING 7 :RIPPED T))</span><br></pre></td></tr></table></figure><p>这样显得对 select 的调用比较丑陋，幸运的是我们可以把匿名函数的创建过程包装起来：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(defun artist-selector (artist)</span><br><span class="line">  #&#x27;(lambda (cd) (equal (getf cd :artist) artist)))</span><br></pre></td></tr></table></figure><p>这是一个可以返回函数的函数，并且返回的函数里引用了一个在 artist-selector 返回以后将不会存在的变量——至少看起来是这样。使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (select (artist-selector &quot;ck&quot;))</span><br><span class="line">((:TITLE &quot;My sky&quot; :ARTIST &quot;ck&quot; :RATING 7 :RIPPED T))</span><br></pre></td></tr></table></figure><p>现在只需要更多的函数来生成选择器了，但是我们现在不想写 title-selector，rating-selector，ripped-selector。因为它们都具有相似的结构。为什么不写一个通用的选择器函数呢，一个根据传递给它的参数可以生成用于不同字段甚至其组合的选择器函数。现在先简要介绍一种称为关键字形参(keyword parameter)的语言特性。</p><p>以下是一个简单的形参列表：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(defun foo (a b c) (list a b c))</span><br></pre></td></tr></table></figure><p>一个使用关键字形参的 foo 版本如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(defun foo (&amp;key a b c) (list a b c))</span><br></pre></td></tr></table></figure><p>调用方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (foo :a 1 :b 2 :c 3)</span><br><span class="line">(1 2 3)</span><br><span class="line">CL-USER&gt; (foo :c 1 :b 2 :a 3)</span><br><span class="line">(3 2 1)</span><br><span class="line">CL-USER&gt; (foo :c 1 :a 3)</span><br><span class="line">(3 NIL 1)</span><br><span class="line">CL-USER&gt; </span><br></pre></td></tr></table></figure><p>正如示例所显示那样，变量 a、b和 c 的值被绑定到了跟在相应的关键字后面的值上，如果一个特定的关键字在调用时没有指定，那么对应的变量被设置为 NIL。有时可能需要区分作为参数显式传递给关键字形参的 NIL 和作为缺省值的 NIL。为了实现这一点，当指定一个关键字形参时，将那个简单的名称替换成一个包括参数名，缺省值和另一个称为 supplied-p 参数的列表。这个 supplied-p 被设置成真或假，具体取决于一个参数在特定的函数调用里是否真的作为关键字被传递了。下面是使用了该特性的 foo 版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(defun foo (&amp;key a (b 20) (c 30 c-p)) (list a b c c-p))</span><br></pre></td></tr></table></figure><p>使用方法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (foo :a 1 :b 2 :c 3)</span><br><span class="line">(1 2 3 T)</span><br><span class="line">CL-USER&gt; (foo :c 3 :b 2 :a 1)</span><br><span class="line">(1 2 3 T)</span><br><span class="line">CL-USER&gt; (foo :a 1 :c 3)</span><br><span class="line">(1 20 3 T)</span><br><span class="line">CL-USER&gt; (foo)</span><br><span class="line">(NIL 20 30 NIL)</span><br></pre></td></tr></table></figure><p>熟悉 SQL 就知道，我们使用 where 来进行查询，我们可以使用 where 来生成选择器函数。例如，像下面这样调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(select (where :artist &quot;Kathy Mattea&quot;))</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(select (where :rating 10 :ripped nil))</span><br></pre></td></tr></table></figure><p>该函数看起来像这样：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> where (<span class="name">&amp;key</span> title artist rating (<span class="name">ripped</span> <span class="literal">nil</span> ripped-p))</span><br><span class="line">  #&#x27;(lambda (cd)</span><br><span class="line">      (and</span><br><span class="line">       (if title (equal (getf cd :title) title) <span class="literal">t</span>)</span><br><span class="line">       (if artist (equal (getf cd :artist) artist) <span class="literal">t</span>)</span><br><span class="line">       (if rating (equal (getf cd :rating) rating) <span class="literal">t</span>)</span><br><span class="line">       (if ripped-p (equal (getf cd :ripped) ripped) <span class="literal">t</span>))))</span><br></pre></td></tr></table></figure><p>这个函数返回一个匿名函数，后者返回一个逻辑 AND，其中每个子句来自于我们 CD 记录中的一个字段，每个子句会检查相应的参数是否被传递进来要么在参数，然后要么将其根 CD 记录中对应字段的值相比较，要么在参数值没有传进来时返回 t，也就是 Lisp 版本的逻辑真。<strong>选择器函数将只在 CD 记录匹配所有传递给 where 的参数时才返回真</strong>。注意使用 三元素列表来指定关键字形参 ripped，因为我们需要知道调用者是否实际传递了 <code>ripped nil</code>。</p><h2 id="更新已有的记录——WHERE-的再次使用">更新已有的记录——WHERE 的再次使用</h2><p>现在已经有了完美通用化的 select 和 where 函数，是时候编写一个数据修改函数了，类似于 SQL 中的 update。我们现在已经有了 where 子句生成器。update 函数只是一些已经用过的思路的再次应用：使用一个通过参数传递的选择器函数来选取需要更新的记录，再使用关键字形参来指定需要改变的值。主要的新东西是对 MAPCAR 函数的使用，其映射在一个列表上——这里是 *db*，然后返回一个新的列表，其中包含在原来列表的每个元素上调用一个函数所得的结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(defun update (selector-fn &amp;key title artist rating (ripped nil ripped-p))</span><br><span class="line">  (setf *db*</span><br><span class="line">(mapcar</span><br><span class="line"> #&#x27;(lambda (row)</span><br><span class="line">     (when (funcall selector-fn row)</span><br><span class="line">       (if title (setf (getf row :title) title))</span><br><span class="line">       (if artist (setf (getf row :artist) artist))</span><br><span class="line">       (if rating (setf (getf row :rating) rating))</span><br><span class="line">       (if ripped-p (setf (getf row :ripped) ripped)))</span><br><span class="line">     row) *db*)))</span><br></pre></td></tr></table></figure><p>使用方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (update (where :artist &quot;ck&quot;) :rating 5)</span><br><span class="line">((:TITLE &quot;My sky&quot; :ARTIST &quot;ck&quot; :RATING 5 :RIPPED T)</span><br><span class="line"> (:TITLE &quot;tom like rice&quot; :ARTIST &quot;larry&quot; :RATING 6 :RIPPED NIL)</span><br><span class="line"> (:TITLE &quot;Pork Face&quot; :ARTIST &quot;Laddy&quot; :RATING 9 :RIPPED T)</span><br><span class="line"> (:TITLE &quot;Roses&quot; :ARTIST &quot;Kathy Mattea&quot; :RATING 7 :RIPPED T))</span><br></pre></td></tr></table></figure><p>或者可以很容易地写一个函数来从数据库里删除记录：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(defun delete-rows (selector-fn)</span><br><span class="line">  (setf *db* (remove-if selector-fn *db*)))</span><br></pre></td></tr></table></figure><p>remove-if 和 remove-if-not 正相反，前者返回所有匹配元素都删除的列表。delete-rows 事实上改变了数据库的内容，只有 50多行代码，总共就这些。</p><p>所有代码如下：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">(<span class="name">defun</span> make-cd (<span class="name">title</span> artist rating ripped)</span><br><span class="line">  (<span class="name">list</span> <span class="symbol">:title</span> title <span class="symbol">:artist</span> artist <span class="symbol">:rating</span> rating <span class="symbol">:ripped</span> ripped))</span><br><span class="line"></span><br><span class="line">(<span class="name">defvar</span> *db* <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> add-record (<span class="name">cd</span>) (<span class="name">push</span> cd *db*))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> dump-db ()</span><br><span class="line">  (<span class="name">dolist</span> (<span class="name">cd</span> *db*)</span><br><span class="line">    (<span class="name">format</span> <span class="literal">t</span> <span class="string">&quot;~&#123;~a:~10t~a~%~&#125;~%&quot;</span> cd)))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> prompt-read (<span class="name">prompt</span>)</span><br><span class="line">  (<span class="name">format</span> *query-io* <span class="string">&quot;~a: &quot;</span> prompt)</span><br><span class="line">  (<span class="name">force-output</span> *query-io*)</span><br><span class="line">  (<span class="name">read-line</span> *query-io*))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> prompt-for-cd ()</span><br><span class="line">  (<span class="name">make-cd</span></span><br><span class="line">   (<span class="name">prompt-read</span> <span class="string">&quot;Title&quot;</span>)</span><br><span class="line">   (<span class="name">prompt-read</span> <span class="string">&quot;Artist&quot;</span>)</span><br><span class="line">   (<span class="name">OR</span> (<span class="name">parse-integer</span> (<span class="name">prompt-read</span> <span class="string">&quot;Rating&quot;</span>) <span class="symbol">:junk-allowed</span> <span class="literal">t</span>) <span class="number">0</span>)</span><br><span class="line">   (<span class="name">y-or-n-p</span> <span class="string">&quot;Ripped [y/n]: &quot;</span>)))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> add-cds ()</span><br><span class="line">  (<span class="name">loop</span> (<span class="name">add-record</span> (<span class="name">prompt-for-cd</span>))</span><br><span class="line">(<span class="name">if</span> (<span class="name">not</span> (<span class="name">y-or-n-p</span> <span class="string">&quot;Another?[y/n]: &quot;</span>)) (<span class="name">return</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> save-db (<span class="name">filename</span>)</span><br><span class="line">  (<span class="name">with-open-file</span> (<span class="name">out</span> filename</span><br><span class="line">       <span class="symbol">:direction</span> <span class="symbol">:output</span></span><br><span class="line">       <span class="symbol">:if-exists</span> <span class="symbol">:supersede</span>)</span><br><span class="line">    (<span class="name">with-standard-io-syntax</span></span><br><span class="line">      (<span class="name">print</span> *db* out))))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> load-db (<span class="name">filename</span>)</span><br><span class="line">  (<span class="name">with-open-file</span> (<span class="name">in</span> filename)</span><br><span class="line">    (<span class="name">with-standard-io-syntax</span></span><br><span class="line">      (<span class="name">setf</span> *db* (<span class="name">read</span> in)))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> select (<span class="name">selector-fn</span>)</span><br><span class="line">  (<span class="name">remove-if-not</span> selector-fn *db*))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> where (<span class="name">&amp;key</span> title artist rating (<span class="name">ripped</span> <span class="literal">nil</span> ripped-p))</span><br><span class="line">  #&#x27;(lambda (cd)</span><br><span class="line">      (and</span><br><span class="line">       (if title (equal (getf cd :title) title) <span class="literal">t</span>)</span><br><span class="line">       (if artist (equal (getf cd :artist) artist) <span class="literal">t</span>)</span><br><span class="line">       (if rating (equal (getf cd :rating) rating) <span class="literal">t</span>)</span><br><span class="line">       (if ripped-p (equal (getf cd :ripped) ripped) <span class="literal">t</span>))))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> update (<span class="name">selector-fn</span> <span class="symbol">&amp;key</span> title artist rating (<span class="name">ripped</span> <span class="literal">nil</span> ripped-p))</span><br><span class="line">  (<span class="name">setf</span> *db*</span><br><span class="line">(<span class="name">mapcar</span></span><br><span class="line"> #&#x27;(lambda (row)</span><br><span class="line">     (when (funcall selector-fn row)</span><br><span class="line">       (if title (setf (getf row :title) title))</span><br><span class="line">       (if artist (setf (getf row :artist) artist))</span><br><span class="line">       (if rating (setf (getf row :rating) rating))</span><br><span class="line">       (if ripped-p (setf (getf row :ripped) ripped)))</span><br><span class="line">     row) *db*)))</span><br><span class="line"></span><br><span class="line">(<span class="name">defun</span> delete-rows (<span class="name">selector-fn</span>)</span><br><span class="line">  (<span class="name">setf</span> *db* (<span class="name">remove-if</span> selector-fn *db*)))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Lisp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lisp </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用两个栈模拟一个队列</title>
      <link href="/2021/11/11/yong-liang-ge-zhan-mo-ni-yi-ge-dui-lie/"/>
      <url>/2021/11/11/yong-liang-ge-zhan-mo-ni-yi-ge-dui-lie/</url>
      
        <content type="html"><![CDATA[<h2 id="思路">思路</h2><p>本题是考察栈和队列的常见问题。要解答本题必须知道栈的队列的基本原理。</p><p>栈：一种后进先出的数据结构，想象一个单车道，汽车一辆接一辆往里开，最先进入的在最里面，最后进入的在最外面，当需要出去的时候，最后进入的先出，最先进入的最后出去。符合类似进出原则的数据结构就叫做栈。 往栈中存入数据也叫压栈，取出数据也叫弹栈。</p><p>队列：先进先出的数据结构。顾名思义，就像排队一样，最先进入在队头，后进入在队尾，队头先出队，队尾后出队。往队列中存入数据叫入队，往队列中取数据叫出队。</p><span id="more"></span><p>说完了栈和队列的基本概念，那怎么用两个栈来模拟一个队列呢？ 假设两个栈分别为 stack1，stack2</p><p>举个例子，现有一个入队顺序如下：1 2 3 4 5 6 7</p><p>它的合法出队顺序应该如下：1 2 3 4 5 6 7</p><p>我们先用一个栈，例如 stack1 入队信息依次压栈：1 2 3 4 5 6 7，那么弹栈顺序为：7 6 5 4 3 2 1，很明显和入队顺序刚好相反，那该怎么办呢？这就需要借助第二个栈了。</p><p>我们将 stack1 弹栈，然后按弹栈顺序入栈 stack2 中（方法一），这样 stack2 中的数据为：7 6 5 4 3 2 1，这样 stack2 的输出就符合队列的输出要求了，也就是：1 2 3 4 5 6 7</p><p>现在还有一个问题，后续的入队和出队问题，也很简单。每次入队，都将其存入 stack1 中，出队时，首先判断 stack2 是否为空，如果为空就使用采取<strong>方法一</strong>，如果不为空，就从 stack2 中弹出一个数据，就是正确的出队顺序。<strong>关键：只有当 stack2 为空时，才将 stack1 中的数据按出栈顺序压入 stack2 中。</strong></p><h2 id="代码">代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;stack1;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt;stack2;</span><br><span class="line">    <span class="built_in">CQueue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">appendTail</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        stack<span class="number">1.</span><span class="built_in">push</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(stack<span class="number">2.</span><span class="built_in">empty</span>())&#123;                     <span class="comment">// stack2 为空才执行方法一</span></span><br><span class="line">            <span class="keyword">while</span>(!stack<span class="number">1.</span><span class="built_in">empty</span>())&#123;</span><br><span class="line">                stack<span class="number">2.</span><span class="built_in">push</span>(stack<span class="number">1.</span><span class="built_in">top</span>());</span><br><span class="line">                stack<span class="number">1.</span><span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(stack<span class="number">2.</span><span class="built_in">empty</span>())                     <span class="comment">// 不存在数据的情况</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> ret = stack<span class="number">2.</span><span class="built_in">top</span>();</span><br><span class="line">        stack<span class="number">2.</span><span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="时间复杂度分析">时间复杂度分析</h2><p>时间复杂度 O(1)，上述方法一虽然是需要消耗时间 O(n)，但是均摊下来，每个元素的入队和出队，都是 O(1)</p><p>空间复杂度 O(n)</p><p><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">题目链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 栈 </tag>
            
            <tag> 队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速幂算法</title>
      <link href="/2021/11/11/kuai-su-mi-suan-fa/"/>
      <url>/2021/11/11/kuai-su-mi-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1>快速幂算法</h1><p>看了不少题解，都讲的太复杂，而本人一直崇尚大道至简，于是萌生出写该题解的想法。</p><p>快速幂算法可以在 O(lgn) 内完一个数的 n 次幂计算，即实现C语言库函数 <code>double pow(double x, double y)</code></p><span id="more"></span><h2 id="递归">递归</h2><p>快速幂算法来源于二分法思想，每次丢掉一半的数据(我自己的理解)，这样在 O(lgn) 得出问题答案。</p><p>例如：计算 3<sup>73</sup></p><p>3<sup>73</sup> =  3<sup>36</sup>* 3<sup>36</sup>*3</p><p>3<sup>36</sup> = 3<sup>6</sup>*3<sup>6</sup></p><p>3<sup>6</sup> =  3<sup>3</sup>*3<sup>3</sup></p><p>3<sup>3</sup> = 3<sup>1</sup>*3<sup>1</sup>*3</p><p>3<sup>1</sup> = 3</p><p>可以看出非常符合递归的思想，当 n 为基数时，只需多乘一个 x。使用代码描述如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">double</span> y = <span class="built_in">pow</span>(x, n / <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> (n % <span class="number">2</span> == <span class="number">0</span>) ? y * y : y * y * x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(lg(n))</p><p>空间复杂度：O(lg(n))，即最大递归深度。</p><h2 id="迭代">迭代</h2><p>使用迭代就可以将空间复杂度降为 O(1)</p><p>每次迭代令 x = x*x，就可以让 n 减半，直至 n 为 0。</p><p>累乘所有 n 为奇数的项，就能得到答案。如下例所示：</p><p>2<sup>7</sup></p><table><thead><tr><th>7</th><th>3</th><th>1</th></tr></thead><tbody><tr><td>2<sup>1</sup></td><td>2<sup>2</sup></td><td>2<sup>4</sup></td></tr></tbody></table><p>只需把奇数对应的数累乘即可： 2<sup>1</sup> * 2<sup>2</sup> *2<sup>4</sup> = 2<sup>7</sup></p><p>3<sup>73</sup></p><table><thead><tr><th>73</th><th>36</th><th>18</th><th>9</th><th>4</th><th>2</th><th>1</th><th></th></tr></thead><tbody><tr><td>3<sup>1</sup></td><td>3<sup>2</sup></td><td>3<sup>4</sup></td><td>3<sup>8</sup></td><td>3<sup>16</sup></td><td>3<sup>32</sup></td><td>3<sup>64</sup></td><td></td></tr></tbody></table><p>只需把奇数对应的数累乘即可：3<sup>1</sup> * 3<sup>8</sup> * 3<sup>64</sup> = 3<sup>73</sup></p><p>代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> N = n;</span><br><span class="line">    <span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span> / x;</span><br><span class="line">        N *= <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (N)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (N &amp; <span class="number">1</span>) <span class="comment">// 判断二进制最地位是否为1，或者判断是否为偶数，等价于 N%2</span></span><br><span class="line">            res *= x;</span><br><span class="line"></span><br><span class="line">        x *= x;</span><br><span class="line">        N &gt;&gt;= <span class="number">1</span>; <span class="comment">// 等于 N/=2;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可提交的代码">可提交的代码</h2><h3 id="题目链接"><a href="https://leetcode-cn.com/problems/powx-n/">题目链接</a></h3><h3 id="递归-2">递归</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">quickMul</span><span class="params">(<span class="type">double</span> x, <span class="type">long</span> <span class="type">long</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">double</span> y = <span class="built_in">pow</span>(x, n / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> (n % <span class="number">2</span> == <span class="number">0</span>) ? y * y : y * y * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">long</span> N = n;</span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x = <span class="number">1.0</span> / x;</span><br><span class="line">            N *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickMul</span>(x, N);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="迭代-2">迭代</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">long</span> N = n;</span><br><span class="line">        <span class="type">double</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (N &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            N *= <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (N)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (N &amp; <span class="number">1</span>) <span class="comment">// 判断二进制最地位是否为1，或者判断是否为偶数，等价于 N%2</span></span><br><span class="line">                res *= x;</span><br><span class="line"></span><br><span class="line">            x *= x;</span><br><span class="line">            N &gt;&gt;= <span class="number">1</span>; <span class="comment">// 等于 N/=2;</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速幂 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ 实现一个堆内存分配器(malloc/free)</title>
      <link href="/2021/11/09/c-yu-yan-shi-xian-yi-ge-dui-nei-cun-fen-pei-qi-malloc-free/"/>
      <url>/2021/11/09/c-yu-yan-shi-xian-yi-ge-dui-nei-cun-fen-pei-qi-malloc-free/</url>
      
        <content type="html"><![CDATA[<p>C 语言使用 malloc 分配内存，使用 free 释放内存。那么它们是怎么实现的呢？</p><p>堆内存位于数据段(data) 和内存映射区之间，它有一个堆顶指针 brk，malloc 将堆内存分为空闲块和已分配块，使用链表来管理空闲块和已分配块。当堆内存用完时，使用系统调用 sbrk 增大 brk 来增大堆内存的大小。当要求分配的内存大小大于空闲块时，就将空闲块分成两份，一份分配给用户，剩下的内存作为一个空闲块。</p><span id="more"></span><p>随着系统的运行，将会产生大量小的空闲块，这些空闲块组合起来可以满足用户要求，但没有一块空闲块可以满足用户要求，这些大量的小的空闲块称为外部碎片。与外部碎片相对的就是内部碎片，内部碎片往往是由于内存对齐的需要，而分配大于要求分配的大小，这些多余的部分称为内部碎片。</p><p>下面将使用 C 语言实现一个类似于 malloc 的堆内存分配器，以及类似于 free 的内存释放功能。基于隐式空闲链表，首次适配搜索。<a href="https://wangjunstf.github.io/2021/11/09/linux-xu-ni-nei-cun-xi-tong-nei-cun-ying-she-fork-execve-malloc-free-dong-tai-nei-cun-fen-pei-yu-shi-fang/">关于隐式空闲链表的详细介绍</a>。</p><p>头文件 mm.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *mem_heap;     <span class="comment">// 指向堆的第一个字节</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *mem_brk;      <span class="comment">// 指向堆最后一个字节的后面一个字节</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *mem_max_addr; <span class="comment">// 指向堆的最大合法地址的后一个地址</span></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *heap_listp;   <span class="comment">// 总是指向序言块</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WSIZE 4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DSIZE 8</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CHUNKSIZE (1&lt;&lt;12)    <span class="comment">// 4KB </span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_HEAP CHUNKSIZE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX(x,y) ((x) &gt; (y) ? (x) : (y))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将大小和状态位打包进一个字(4字节)里</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PACK(size,alloc) ((size)|(alloc))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个地址里读取或写入一个字的数据</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET(p) (*(unsigned int *)(p))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PUT(p, val) (*(unsigned int *)(p)=(val))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从一个地址获得块的大小和状态</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_SIZE(p) (GET(p) &amp; ~0x7)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GET_ALLOC(p) (GET(p) &amp; 0x1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定一个块的地址，计算出它的头部和脚部的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HDRP(bp) ((char*)(bp) - WSIZE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FTRP(bp) ((char*)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 给定一个块的地址，计算出它的下一块和上一块的地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NEXT_BLKP(bp) ((char*)(bp) + GET_SIZE((char*)(bp) - WSIZE))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PREV_BLKP(bp) ((char*)(bp) - GET_SIZE((char*)(bp) - DSIZE))</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mem_init</span><span class="params">()</span>;           <span class="comment">// 初始化堆</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;  <span class="comment">// 分配内存</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *bp)</span>; <span class="comment">// 回收内存</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">()</span>;     <span class="comment">// 初始化空闲链表</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span>;     <span class="comment">// 扩展堆的大小</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span>;<span class="comment">// 合并空闲块</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span>* <span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> asize)</span>;<span class="comment">// 首次适配搜索</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">void</span>* bp, <span class="type">size_t</span> asize)</span>;<span class="comment">// 分割空闲块</span></span><br></pre></td></tr></table></figure><p>mm.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mem_init</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 为堆分配内存</span></span><br><span class="line">    mem_heap = (<span class="type">char</span>*)<span class="built_in">malloc</span>(MAX_HEAP);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化堆顶指针</span></span><br><span class="line">    mem_brk = (<span class="type">char</span>*)mem_heap;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化最大合法地址</span></span><br><span class="line">    mem_max_addr = (<span class="type">char</span>*)(mem_heap+MAX_HEAP);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展堆顶指针</span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mem_sbrk</span><span class="params">(<span class="type">int</span> incr)</span>&#123;</span><br><span class="line">    <span class="type">char</span>* old_brk = mem_brk;</span><br><span class="line">    <span class="keyword">if</span>( (incr&lt;<span class="number">0</span>) || (mem_brk+incr&gt;mem_max_addr))&#123;</span><br><span class="line">        errno = ENOMEM;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;ERROR: mem_sbrk failed. Ran out of memory...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">void</span>*)<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mem_brk+=incr;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span>*)old_brk;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">mm_init</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 将堆扩大 16 字节，存放起始块(4字节) 序言块(8字节) 结尾块(4字节) </span></span><br><span class="line">    <span class="keyword">if</span>((heap_listp=mem_sbrk(<span class="number">4</span>*WSIZE)) == (<span class="type">void</span>*)<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    PUT(heap_listp,<span class="number">0</span>);</span><br><span class="line">    PUT(heap_listp + (<span class="number">1</span>*WSIZE), PACK(DSIZE,<span class="number">1</span>));</span><br><span class="line">    PUT(heap_listp + (<span class="number">2</span> * WSIZE), PACK(DSIZE, <span class="number">1</span>));  <span class="comment">// 序言块：(8字节：一个头部，一个尾部)</span></span><br><span class="line">    PUT(heap_listp + (<span class="number">3</span>*WSIZE), PACK(<span class="number">0</span>,<span class="number">1</span>));         <span class="comment">// 结尾块</span></span><br><span class="line">    heap_listp+=(<span class="number">2</span>*WSIZE);                          <span class="comment">// heap_listp 总是指向序言块</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(extend_heap(CHUNKSIZE/WSIZE)==<span class="literal">NULL</span>)          <span class="comment">// 扩展堆 1KB 大小</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">extend_heap</span><span class="params">(<span class="type">size_t</span> words)</span>&#123;</span><br><span class="line">    <span class="type">char</span>* bp;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了保持对齐，将请求大小向上舍入为最接近2字(8字节)的倍数</span></span><br><span class="line">    size = (words%<span class="number">2</span>) ? (words+<span class="number">1</span>) :words;</span><br><span class="line">    <span class="keyword">if</span>((<span class="type">long</span>)(bp = mem_sbrk(size))==<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化空闲块的头部和脚部</span></span><br><span class="line">    PUT(HDRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="number">0</span>,<span class="number">1</span>));  <span class="comment">// 每次扩展堆都要重新设置结尾块</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">mm_free</span><span class="params">(<span class="type">void</span> *bp)</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line">    PUT(HDRP(bp), PACK(size,<span class="number">0</span>));</span><br><span class="line">    PUT(FTRP(bp), PACK(size,<span class="number">0</span>));</span><br><span class="line">    coalesce(bp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">coalesce</span><span class="params">(<span class="type">void</span> *bp)</span>&#123;</span><br><span class="line">  </span><br><span class="line">    <span class="type">size_t</span> prev_alloc = GET_ALLOC(FTRP(PREV_BLKP(bp)));</span><br><span class="line">    <span class="type">size_t</span> next_alloc = GET_ALLOC(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">    <span class="type">size_t</span> size = GET_SIZE(HDRP(bp));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(prev_alloc &amp;&amp; next_alloc )&#123;  <span class="comment">// 情况1 上下都不空闲</span></span><br><span class="line">        <span class="comment">// printf(&quot;case1\n&quot;);</span></span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)&#123;</span><br><span class="line">        <span class="comment">// printf(&quot;case2\n&quot;);</span></span><br><span class="line">        size += GET_SIZE(HDRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">0</span>)); </span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!prev_alloc &amp;&amp; next_alloc)&#123;</span><br><span class="line">        <span class="comment">// printf(&quot;case3\n&quot;);</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)));</span><br><span class="line">        PUT(FTRP(bp),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// printf(&quot;case4\n&quot;);</span></span><br><span class="line">        size += GET_SIZE(HDRP(PREV_BLKP(bp)))+GET_SIZE(FTRP(NEXT_BLKP(bp)));</span><br><span class="line">        PUT(HDRP(PREV_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(NEXT_BLKP(bp)),PACK(size,<span class="number">0</span>));</span><br><span class="line">        bp = PREV_BLKP(bp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">find_fit</span><span class="params">(<span class="type">size_t</span> asize)</span>&#123;</span><br><span class="line">    <span class="type">void</span> *first = heap_listp;</span><br><span class="line">    <span class="keyword">while</span>(GET_SIZE(HDRP(first))!=<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// printf(&quot;find_fit %d\n&quot;, GET_SIZE(HDRP(first)));</span></span><br><span class="line">        <span class="keyword">if</span> (GET_SIZE(HDRP(first)) &gt;= asize &amp;&amp; !GET_ALLOC(HDRP(first)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// printf(&quot;返回大小：%d\n&quot;,GET_SIZE(HDRP(first)));</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            first = NEXT_BLKP(first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">place</span><span class="params">(<span class="type">void</span> *bp, <span class="type">size_t</span> asize)</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> rest = GET_SIZE(HDRP(bp))-asize;</span><br><span class="line">    <span class="keyword">if</span>(rest&lt;<span class="number">2</span>*DSIZE)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        PUT(HDRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(asize,<span class="number">1</span>));</span><br><span class="line">        bp = NEXT_BLKP(bp);</span><br><span class="line">        PUT(HDRP(bp),PACK(rest,<span class="number">0</span>));</span><br><span class="line">        PUT(FTRP(bp),PACK(rest,<span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mm_malloc</span><span class="params">(<span class="type">size_t</span> size)</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> asize;</span><br><span class="line">    <span class="type">size_t</span> extendsize;</span><br><span class="line">    <span class="type">char</span>* bp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(size &lt;= DSIZE)&#123;</span><br><span class="line">        asize = <span class="number">2</span>*DSIZE;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        asize = DSIZE*( (size+DSIZE + DSIZE<span class="number">-1</span>)/DSIZE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((bp = find_fit(asize)) != <span class="literal">NULL</span>)&#123;           <span class="comment">// 找到合适的块</span></span><br><span class="line">        place(bp,asize);   </span><br><span class="line">        <span class="keyword">return</span> bp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    extendsize = MAX(asize,CHUNKSIZE);</span><br><span class="line">    <span class="keyword">if</span>((bp=extend_heap(extendsize/WSIZE))==<span class="literal">NULL</span>) <span class="comment">// 没找到合适的块</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    place(bp,asize);</span><br><span class="line">    <span class="keyword">return</span> bp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;mm.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    mem_init();</span><br><span class="line">    mm_init();</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> *p = mm_malloc(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="type">char</span> *s = mm_malloc(<span class="number">50</span>);</span><br><span class="line">    <span class="type">double</span> *num = mm_malloc(<span class="keyword">sizeof</span>(<span class="type">double</span>));</span><br><span class="line"></span><br><span class="line">    *p = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">strncpy</span>(s, <span class="string">&quot;Hello world&quot;</span>, <span class="number">50</span>);</span><br><span class="line">    *num = <span class="number">0.00012</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d ---&gt; %p\n&quot;</span>,*p,p);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lf ---&gt; %p\n&quot;</span>, *num, num);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s ---&gt; %p\n&quot;</span>, s, s);</span><br><span class="line"></span><br><span class="line">    mm_free(p);</span><br><span class="line">    p = mm_malloc(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    *p = <span class="number">1024</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d ---&gt; %p\n&quot;</span>, *p, p);</span><br><span class="line"></span><br><span class="line">    mm_free(s);</span><br><span class="line">    mm_free(num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">12 ---&gt; 0x55c888a7b270</span><br><span class="line">0.000120 ---&gt; 0x55c888a7b2c0</span><br><span class="line">Hello world ---&gt; 0x55c888a7b280</span><br><span class="line">1024 ---&gt; 0x55c888a7b270</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 堆内存 </tag>
            
            <tag> 内存分配器 </tag>
            
            <tag> malloc </tag>
            
            <tag> free </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++ 常见的内存错误</title>
      <link href="/2021/11/09/c-chang-jian-de-nei-cun-cuo-wu/"/>
      <url>/2021/11/09/c-chang-jian-de-nei-cun-cuo-wu/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h3 id="间接引用坏指针">间接引用坏指针</h3><p>使用以下代码向 val 变量写入数据</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;val);</span><br></pre></td></tr></table></figure><span id="more"></span><p>如果写错成下面这样：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,val);</span><br></pre></td></tr></table></figure><p>我们传递的是 val 而不是 val 的地址，scanf 将 val 解释为一个地址，最好的情况下程序立即终止，最糟糕情况下，val 的内容对应于虚拟内存的某个合法的读/写区域，于是覆盖了这段内存，这通常会在相当长的一段时间后造成灾难性的，令人困惑的后果。</p><h3 id="读未初始化的内存">读未初始化的内存</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">matvec</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>i 是一个随机值。</p><h3 id="允许栈缓冲区溢出">允许栈缓冲区溢出</h3><p>如果一个程序不检查输入串的大小就写入栈中的目标缓冲区，那么这个程序就有缓冲区溢出错误(buffer overflow bug)。如下列代码所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bufoverflow</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">  gets(buf);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更安全的版本：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">bufoverflow</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">char</span> buf[<span class="number">64</span>];</span><br><span class="line">  fgets(buf, <span class="number">64</span>, <span class="built_in">stdin</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="假设指针和它们指向的对象是相同大小的">假设指针和它们指向的对象是相同大小的</h3><p>如下列代码所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> **<span class="title function_">makeArray</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span>&#123;</span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> **A = (<span class="type">int</span> **)<span class="built_in">malloc</span>(n*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; ++i)&#123;</span><br><span class="line">A[i] = (<span class="type">int</span>*)<span class="built_in">malloc</span>(m*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码的目的是创建一个由 n 个指针组成的数组，每一个指针都指向一个包含 m 个 int 的数组。但是代码<code>int **A = (int **)malloc(n*sizeof(int*));</code>被写成了 <code>int **A = (int **)malloc(n*sizeof(int));</code>。实际创建的是包含 n 个 int 类型的数组。</p><p>这段代码只有在 int 和 int* 大小相同的机器行运转良好，如果在像 Core i7 这样的机器上运行代码，其中int* 大于 int，后续 <code>A[i] = (int*)malloc(m*sizeof(int));</code>将写到超出 A 数组结尾的地方。这样的错误只有可能在代码运行很久之后发生，且错误很令人困惑。</p><h3 id="造成错位错误">造成错位错误</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">fill</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> num[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=<span class="number">10</span>; ++i)&#123;</span><br><span class="line">num[i] = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的主要错误就是数组越界访问了，num 的数组下标范围[0,9]，总共 10 个元素。for 循环填充了11个元素，覆盖了 num[9] 之后的内存位置。</p><h3 id="引用指针，而不是它所指向的对象">引用指针，而不是它所指向的对象</h3><p>如果忽略了 C 操作符的优先级，就有可能错误地操作指针，而不是指针所指向的对象。例如下面代码，用于用于删除一个 有 *size 项的二叉堆里的第一项，然后对剩下的 *size -1 项重新建堆。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">binheapDelete</span><span class="params">(<span class="type">int</span> **binheap, <span class="type">int</span> *size)</span>&#123;</span><br><span class="line"><span class="type">int</span> *packet = binheap[<span class="number">0</span>];</span><br><span class="line">binheap[<span class="number">0</span>] = binheap[*size - <span class="number">1</span>];</span><br><span class="line">*size--;</span><br><span class="line">heapify(binheap,*size,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> packet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 4 行目的减少二叉堆元素的数目，因为一元运算符 ‘*’ 和 ‘–’ 优先级相同，从右向左结合。所以第 6 行实际减少的是指针自己的值，而不是原本指针指向的整数的值。最幸运的话程序立即崩溃，不幸的是程序运行很久之后才出现一个不正确的结果，会令开发人员很困惑。第 6 行正确写法：<code>(*size)--</code></p><h3 id="误解指针运算">误解指针运算</h3><p>如下列代码所示，扫描一个 int 数组，并返回一个指针，指向 val 的首次出现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">search</span><span class="params">(<span class="type">int</span> *p, <span class="type">int</span> val)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(*p &amp;&amp; *p!=val)</span><br><span class="line">p += <span class="keyword">sizeof</span>(<span class="type">int</span>);</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次循环时，第 3 行都把指针加了 4，函数就不正确地扫描了数组中的每 4 个整数。</p><h3 id="引用不存在的变量">引用不存在的变量</h3><p>局部变量存在在栈里，函数返回时局部变量就回收了，不能再引用它的地址。如下列代码所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int *stackref()&#123;</span><br><span class="line">int val;</span><br><span class="line">return &amp;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果函数返回之后的某一个时间，修改了 val 的值，很可能修改了另一个函数栈帧的条目，引发令人困惑的问题。</p><h3 id="引用空闲堆块中的数据">引用空闲堆块中的数据</h3><p>堆内存被释放时，就不能再次引用该堆块的地址。如果试图修改它，将破坏其它变量的值。如下列代码所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *<span class="title function_">heapref</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">*p = <span class="number">1024</span>;</span><br><span class="line"><span class="built_in">free</span>(p);</span><br><span class="line">*p = <span class="number">1000</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 5 行修改了已释放的堆内存，有可能会在程序运行很久之后才会发现这个问题，同样会令人很困惑。</p><h3 id="引起内存泄漏">引起内存泄漏</h3><p>内存泄漏发生于忘记释放堆内存，这是一个缓慢的，隐性的杀手。如下列代码所示：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">leak</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="type">int</span> *x = (<span class="type">int</span>*)<span class="built_in">malloc</span>(n * size(<span class="type">int</span>));</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果经常调用 leak，那么渐渐地，堆里就会充满垃圾，最糟糕情况下，会占用整个虚拟地址空间。对于像守护进程和服务器这样需要长久运行的服务，内存泄漏是特别严重的。</p><h3 id="小节">小节</h3><p>虚拟内存是对内存的抽象。虚拟内存的实现需要硬件和软件共同完成，操作系统提供页表，硬件根据页表将一个虚拟地址翻译为物理地址。</p><p>虚拟内存提供以下功能：</p><ul><li>在主存中自动缓冲最近使用的存放在磁盘上的虚拟地址空间的内存。</li><li>虚拟内存简化了内存管理，进而又简化了链接，在进程间共享数据，进程的内存分配及程序加载。</li><li>虚拟内存通过在每条页表条目中加入保护位，从而简化了内存保护。</li></ul><p>现代系统通过将虚拟内存和磁盘文件关联起来，来初始化虚拟内存片，这个过程称为内存映射。内存映射为共享数据，创建新的进程以及加载程序提供了一种高效的地址。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见内存错误 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收的基本原理</title>
      <link href="/2021/11/09/la-ji-hui-shou-de-ji-ben-yuan-li/"/>
      <url>/2021/11/09/la-ji-hui-shou-de-ji-ben-yuan-li/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>对于像 maclloc 这样的显式分配器，应用通过调用 malloc 和 free 来分配和释放堆块，应用要负责释放所有不再需要的已分配块。</p><p>不能及时释放内存堆块可能造成严重的内存错误，例如：内存泄漏，如下列代码所示：</p><span id="more"></span><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">garbage</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> *p = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="number">1024</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 garbage 返回之前应该释放 p，不幸的是，程序员忘了释放这个块，它在程序的生命周期内都保持已分配状态。</p><p>垃圾收集器(garbage collector)是一种动态内存分配器，它自动释放不再需要的已分配块。这些块被称为垃圾(garbage)。</p><p>垃圾收集可以追溯到 John McCarthy 在 20世纪 60 年代早期在 MIT 开发的 Lisp 系统，它是诸如 Java，Perl 等现代语言系统的一个重要部分。接下来讨论 McCarthy 独创的 Mark&amp;Sweep(标记 &amp; 清除)算法。这个算法可以建立在已存在的 malloc 包的基础之上，为 C 和 C++ 程序提供垃圾收集。</p><h3 id="垃圾收集器基本知识">垃圾收集器基本知识</h3><p>垃圾收集器将内存视为一张有向可达图(reachability graph)，如下图所示：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_AA00E2AD75D9-1.jpeg" alt="IMG_AA00E2AD75D9-1" style="zoom: 67%;" /><p>该图被分为一组根节点(root node)和一组堆节点(heap node)。每个堆节点对应于堆中的一个已分配块。有向边 p -&gt; q意味着块 p 中的某个位置指向块 q 中的某个位置。根节点对应于这样一种不在堆中的位置，它们包含指向堆中的指针。</p><p>当存在任意根节点出发到达 p 的有向路径时，称节点 p 是可达的(reachable)。在任何时刻，不可达节点称为垃圾。<strong>垃圾收集器的作用就是维护可达图的某种表示，并通过释放不可达节点且将它们返回给空闲链表，来定期回收它们。</strong></p><p>像 Java 这种语言，对应用如何创建和使用指针有很严格的控制，能够维护可达图的一种精确表示，因此能回收所有垃圾。</p><p>对于 C 和 C++ 这样的语言的收集器通常不能维持可达图的精确表示，这样的收集器叫做保守的收集器，即每个可达块都被正确地标记为可达了，而一些不可达节点确可能被错误的标记为可达。</p><p>收集器可以按需提供它们的服务，也可以和应用并行的独立线程，不断地更新可达图和回收垃圾。例如下图：考虑如何将一个 C 程序的保守的收集器加入到已存在的 malloc 包中。</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_8064FB70CB76-1.jpeg" alt="IMG_8064FB70CB76-1"></p><p>无论何时需要堆空间，应用都会调用 malloc ，当空闲块不够用时，就启动垃圾收集器，回收不使用的堆块。如果回收空闲块之后还是不够用，就向操作系统要求额外的内存。执行成功返回指向请求块的指针，失败返回空指针。</p><h3 id="Mark-Sweep-垃圾收集器">Mark &amp; Sweep 垃圾收集器</h3><p>Mark &amp; Sweep 垃圾收集器由标记阶段和清除阶段组成，标记阶段标记根节点的所有可达的和已分配的后继，清除阶段释放每个未被标记的已分配块。块头部中空闲的低位中的一位通常用来表示这个块是否被标记了。</p><p>Mark &amp; Sweep 使用以下函数：ptr 定义为 typedef  void* ptr</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ptr <span class="title function_">isPtr</span><span class="params">(ptr p)</span>；          <span class="comment">// 如果 p 指向已分配块中的某个字，返回指向这个块的起始位置的指针 b，否则返回 NULLL</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">blockMarked</span><span class="params">(ptr b)</span>;     <span class="comment">// 如果块 b 是已标记的，就返回 true</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">blockAllocated</span><span class="params">(ptr b)</span>   <span class="comment">// 如果块 b 是已分配的，就返回 true</span></span><br><span class="line"><span class="type">void</span> markBlock（ptr b）      <span class="comment">// 标记块 b</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">length</span><span class="params">(b)</span>               <span class="comment">// 返回块 b 的以字(4 字节)为单位的长度，不包括头部</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">unmarkBlock</span><span class="params">(ptr b)</span>     <span class="comment">// 将 b 的状态由已标记的改为未标记的</span></span><br><span class="line">ptr <span class="title function_">nextBlock</span><span class="params">(ptr b)</span>        <span class="comment">// 返回堆中块 b 的后继</span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">mark</span><span class="params">(ptr p)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>((b=isPtr(p))== <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span>(blockMarked(b))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  len = length(b);</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; ++i)&#123;</span><br><span class="line">      mark(b[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">sweep</span><span class="params">(ptr b, ptr end)</span>&#123;</span><br><span class="line"><span class="keyword">while</span>(b&lt;end)&#123;</span><br><span class="line"><span class="keyword">if</span>(blockMarked(b))&#123;</span><br><span class="line">          unmarkBlock(b);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(blockAllocated(b))&#123;</span><br><span class="line">          <span class="built_in">free</span>(b);</span><br><span class="line">        &#125;</span><br><span class="line">      b = nextBlock(b);</span><br><span class="line">&#125;</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标记阶段为每个根节点调用 mark 函数，如果 p 不指向一个已分配并且未被标记的堆块，mark 函数就立即返回，否则就标记这个块，并对块中每个字递归调用自己。每次调用 mark 函数都标记某个根节点的所有未标记并且可达的后继节点。在清除节点，任何未被标记的节点都被认为是不可达的，应当被清除。</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_20E282EC8C41-1.jpeg" alt="IMG_20E282EC8C41-1"></p><h3 id="C-程序的保守-Mark-Sweep">C 程序的保守 Mark &amp; Sweep</h3><p>Mark &amp; Sweep 对 C程序的垃圾收集是一种合适的方法，它可以就地工作，而不需要移动任何块，然而C 语言中 isPtr 函数的实现具有一定的挑战：</p><ul><li>C 不会用任何类型信息来标记内存位置，因此对于 isPtr 没有一种明显的方式来判断它的输入参数 p 是不是一个指针。</li><li>即使我们知道 p 是一个指针，对 isPtr 也没有明显的方式来判断 p 是否指向一个已分配块的有效载荷中的某个位置。</li></ul><p>对于第二个问题，解决方案就是将已分配块集合维护成一棵平衡二叉树，这棵树保持以下属性：左子树的所有块都放在较小的地址处，而右子树的所有块都放在较大的地址处。这就要求每个已分配块的头部里有两个附加字段(left 和 right)，每个字段指向某个已分配块的头部。**isPtr (ptr p) 用树来执行对已分配块的二分查找，它依赖于块头部中的大小字段来判断 p 是否落在这个块的范围之内。**如下图所示：</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_A93B7D3E642F-1.jpeg" alt="IMG_A93B7D3E642F-1"></p><p>这种方式从某种意义讲是保守的，因为它可能不正确地标记实际上不可达的块，因此它可能不正确地标记实际上不可达的块，因此它可能不会释放某些垃圾。比如： C语言不会用类型信息来标记内存位置。因此，像 int 或者 float 这样的标量可以伪装成指针，例如，某个可达的已分配块在它的有效载荷中包含一个 int，其值碰巧对应于某个已分配块 b 的有效载荷中的一个地址。<strong>对收集器而言，没有办法判断这个数据实际上是 int 而不是指针。因此，分配器必须保守地将块 b 标记为可达，尽管事实上它可能不可达。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 垃圾回收 </tag>
            
            <tag> 标记清除法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 虚拟内存系统, 内存映射, fork, execve, malloc, free 动态内存分配与释放</title>
      <link href="/2021/11/09/linux-xu-ni-nei-cun-xi-tong-nei-cun-ying-she-fork-execve-malloc-free-dong-tai-nei-cun-fen-pei-yu-shi-fang/"/>
      <url>/2021/11/09/linux-xu-ni-nei-cun-xi-tong-nei-cun-ying-she-fork-execve-malloc-free-dong-tai-nei-cun-fen-pei-yu-shi-fang/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><p>Linux 为每个进程维护一个单独的虚拟地址空间，如下图所示。</p><ul><li>内核虚拟内存包含内核中的代码和数据结构。</li><li>内核虚拟内存的某些区域被映射到所有进程共享的物理页面，例如每个进程都共享内核的代码和全局数据结构。</li><li>Linux 也将一组连续的虚拟页面(大小等于系统中 DRAM 的总量)映射到相应的一组连续的物理页面。例如：访问页表，或对设备执行IO操作，这些设备被映射到特定物理内存位置时。</li><li>内核虚拟内存的其它区域包含每个进程的独有数据，例如页表，内核在进程的上下文中执行代码时使用的栈，以及记录虚拟地址空间当前组织的各种数据结构。</li></ul><span id="more"></span><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_9B55F7CD7A60-1.jpeg" alt="一个Linux进程的虚拟内存" style="zoom:50%;" /><h2 id="内存区域">内存区域</h2><p>Linux 将虚拟内存组织成一些段(或区域)的集合，一个段就是已经分配的虚拟内存的连续片，这些页是以某种方式相关联的。例如，代码段，数据段，堆，共享库段，以及用户栈都是不同的段。每个存在的虚拟页都保存在某个段中，而不属于某个段的虚拟页是不存在的，并且不能被进程引用。Linux 段的概念很重要，因为它允许虚拟地址空间有间隙。</p><p>下图所示记录了一个进程中虚拟内存区域的内核数据结构。内核为每个进程维护一个单独的任务结构(task_struct) 。任务结构包含内核运行该进程所需要的所有信息(PID，用户栈指针，可执行目标文件的名字，以及程序计数器)。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_4C16CF80BC09-1.jpeg" alt="Linux 是如何组织虚拟内存的" style="zoom:50%;" /><p>任务结构的一个属性 mm 指向 mm_struct，它描述虚拟内存的当前状态。其中的两个字段，pgd 指向第一级页表的基址，mmap 指向 vm_area_structs(区域结构/段结构)的链表，其中每个  vm_area_structs 都描述了当前虚拟地址空间的一个段。当内核运行这个进程时，将 pgd 存放在 CR3 控制寄存器中。</p><p>每个 vm_area_structs 都包含以下属性：</p><ul><li>vm_start 段的开始地址</li><li>vm_end 段的结束地址</li><li>vm_prot 这个段内所包含的所有页的读写权限</li><li>vm_flags 描述这个段内的页是否与其它进程共享，和其它一些信息。</li><li>vm_next 指向链表中的下一个段结构</li></ul><h2 id="缺页异常处理">缺页异常处理</h2><p>假设 MMU 在试图翻译某个虚拟地址 A 时，触发一个缺页，这个异常导致控制转移到内核的缺页处理程序，该缺页处理程序执行下面的步骤：</p><ol><li><p>虚拟地址 A 是合法的吗？</p><p>地址 A 和每个段结构中的 vm_start 和 vm_end，如果地址 A 不在任何一个段中，就触发了段错误，随后终止这个进程。</p><p>一个进程可以创建任意数量的新虚拟内存区域，顺序搜索区域结构的链表花销可能很大，Linux 通常在链表中构建一棵树，在树中进行查找。</p></li><li><p>试图进行的内存访问是否合法？</p><p>换句话说，进程是否有读，写或执行这个区域内页面的权限。当一个进程对一个只读页面进行写操作，或一个运行在用户模式中的进程试图从内核虚拟内存中读取字。这时就会触发一个保护异常，从而终止这个进程。</p></li><li><p>到这一步，内核知道这个缺页是合法的虚拟地址进行合法的操作造成的。随后，它选择一个牺牲页，如果这个牺牲页面被修改过，那么就将它交换出去，换入新的页面并更新页表。当缺页程序返回时，CPU 重新启动引起缺页的指令。</p></li></ol><p>具体过程如下图所示：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_BA3C666101AD-1.jpeg" alt="Linux 缺页处理" style="zoom:50%;" /><h2 id="内存映射">内存映射</h2><p>Linux 通过将一个虚拟内存区域与一个磁盘上的对象(object)关联起来，以初始化这个虚拟内存区域的内容，这个过程称之为内存映射(memory mapping)。虚拟内存区域可以映射到两种类型的对象之一：</p><ol><li><p>Linux 文件系统中的普通文件</p><p>一个区域可以映射到一个普通磁盘文件的连续部分，例如一个可执行目标文件。文件区(section)被分成页大小的片，每一片包含一个虚拟页面的初始内容。虚拟页面采用按需调度，如果区域比文件区要大，则用零填充。</p></li><li><p>匿名文件</p><p>一个区域也可以映射到一个匿名文件，匿名文件是由内核创建，包含全是二进制零。CPU 第一次引用这样一个区域内的虚拟页面时，内核就在物理内存中找到一个合适的牺牲页，如果该页面被修改过，就将这个页面换出来，用二进制零覆盖牺牲页面并更新页表，将这个页面标记为驻留在内存中的。映射到匿名文件的区域中的页面有时也叫做请求二进制零的页。</p></li></ol><p>一旦一个虚拟页面被初始化了，它就在一个由内核维护的专门的交换文件(swap file)之间换来换去。交换文件也叫做交换空间(swap space)或者交换区域(swap area)。在任何时刻，交换空间都限制着当前运行着的进程能够分配的虚拟页面总数。</p><h3 id="再看共享对象">再看共享对象</h3><p>如果虚拟内存可以集成到传统的文件系统中，那么就能提供一种简单而高效的把程序和数据加载到内存中方法。</p><p>每个进程都有独立的虚拟地址空间，不过许多代码有同样的只读代码区域，例如每个 C 程序都需要来自标准 C 库的诸如 printf 这样的函数，每个进程都包含这些函数会造成大量的内存浪费，内存映射提供了一种清晰的机制，用来控制多个进程如何共享对象。</p><p>一个对象可以被映射到虚拟内存的一个区域，要么作为共享对象，用么作为私有对象。如果一个进程将一个共享对象映射到它的虚拟地址空间的一个区域内，那么这个进程对这个区域的任何写操作，对于那些也把这个共享对象映射到它们虚拟内存的其它进程也是可见的。而且，这些变化也会反映在原始对象中。</p><p>对于一个映射到私有对象的区域做的改变，对于其它进程来说是不可见的，并且<strong>进程对这个区域所做的任何写操作都不会反映在磁盘的原始对象中</strong>。一个映射到共享对象的虚拟内存区域叫做共享区域。类似地，也有私有区域。</p><p>如下图所示，进程1 将一个共享对象映射到它的虚拟内存的一个区域中。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_CF52C57D94FE-1.jpeg" alt="IMG_CF52C57D94FE-1" style="zoom:50%;" /><p>每个对象都有一个唯一的文件名，内核可以迅速地判定进程1已经映射了这个对象。即使对象被映射到多个共享区域，物理内存中也只需要存放对象的一个副本。</p><p>私有对象使用一种写时复制(copy-on-write)的巧妙技术被映射到虚拟内存中。一个私有对象开始生命周期的方式基本上与共享对象的一样，在物理内存中保存私有对象的一个副本。对于每个映射私有对象的进程，相应私有区域的页表条目都被标记为只读，并且区域结构被标记为私有的写时复制技术。只要有一个进程试图写私有区域内的某个页面，那么这个写操作就会触发一个保护故障。</p><p>当故障处理程序注意到保护异常是由于进程试图写私有的写时复制区域中的一个页面而引起的，它就会在物理内存中创建这个页面的一个新副本，更新页表条目指向这个新的副本，然后恢复这个页面的可写权限。当故障程序返回时，CPU 重新执行这个写操作，之后就可以正常进行写了。如下图所示：</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_250648794461-1.jpeg" alt="IMG_250648794461-1"></p><p>通过延迟私有对象中的副本直到最后可能的时刻，写时复制最充分地使用了稀有的物理内存。</p><h3 id="再看-fork-函数">再看 fork 函数</h3><p>当 fork 函数被当前进程调用，内核为新进程创建各种数据结构，并分配给它一个唯一的 PID。为了给这个新进程创建虚拟内存，它创建了当前进程的 mm_struct，区域结构和页表的原样副本。它将两个进程中的每个页面都标记为只读，并将两个进程中的每个区域结构都标记为私有的写时复制。</p><p>当 fork 函数结束时，新进程现在的虚拟内存刚好和调用 fork 时存在的虚拟内存相同。当两个进程中的任一个后来进行写操作时，写时复制机制就会创建新页面，因此，每个进程都保持了私有地址空间的抽象概念。</p><h3 id="再看-execve-函数">再看 execve 函数</h3><p>假设在当前进程中进行如下调用：execve(“a.out”,NULL,NULL);</p><p>execve 函数在当前进程中加载并运行包含在可执行目标文件 a.out 中的程序，用 a.out 程序有效地替代了当前程序。加载并运行 a.out 需要以下几个步骤：</p><ul><li>删除已存在的用户区域：删除当前进程虚拟地址的用户部分中的已存在的区域结构。</li><li>映射私有区域。为程序的代码，数据，bss 和 栈区域创建新的区域结构。所有这些新的区域都是私有的，写时复制的。代码和数据区域被映射为 a.out 文件中的 .text 和 .data区。bss 区域是请求二进制零的，映射到匿名文件。</li><li>映射共享区域：如果 a.out 程序与共享对象(或目标)链接，比如标准 C 库 <a href="http://libc.so">libc.so</a>，那么这些对象都是动态链接到这个程序的，然后再映射到用户虚拟地址空间中的共享区域。</li><li>设置程序计数器(PC)。execve 做的最后一件事情就是设置当前进程上下文中的程序计数器，使之指向代码区域的入口点。</li></ul><p>下一次调度这个程序时，它将从这个入口点开始执行。Linux 将根据需要换入代码和数据页面。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_010A1CCB5875-1.jpeg" alt="IMG_010A1CCB5875-1" style="zoom:50%;" /><h3 id="使用-mmap-函数的用户级内存映射">使用 mmap 函数的用户级内存映射</h3><p>Linux 可以使用 mmap 函数来创建新的虚拟内存区域，并将对象映射到这些区域中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">mmap</span><span class="params">(<span class="type">void</span> *start, <span class="type">size_t</span> length, <span class="type">int</span> prot,<span class="type">int</span> flags, <span class="type">int</span> fd ,<span class="type">off_t</span> offset)</span>;</span><br><span class="line"><span class="comment">// 返回值：执行成功则返回指向映射区域的指针，若出错则为 MAP_FAILED(-1)</span></span><br></pre></td></tr></table></figure><p>mmap 函数要求内核创建一个新的虚拟内存区域，最好是从 start 开始的一个区域，并将文件描述符 fd 指定的对象的一个连续的片(chunk)映射到这个新的区域，连续的对象片大小为 length 字节，从距文件开始处偏移量为 offset 字节的地方开始。start 地址仅仅是一个暗示，通常被定义为 NULL。以下，我们假定起始地址总是 NULL。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_B909BA8CBBF5-1.jpeg" alt="IMG_B909BA8CBBF5-1" style="zoom:50%;" /><p>参数 prot 包含描述新映射的虚拟内存区域的访问权限(即在相应区域结构中 vm_prot 位)。</p><ul><li>PROT_EXEC：这个区域内的页面由可以被 CPU 执行的指令组成。</li><li>PROT_READ：这个区域内的页面可读。</li><li>PROT_WRITE：这个区域内的页面可写。</li><li>PROT_WRITE：这个区域内的页面不可访问。</li></ul><p>参数 flag 描述被映射对象类型的位组成。如果设置了 MAP_ANON 标记位，那么被映射的对象就是一个匿名函数，而相应的虚拟页面是请求二进制零的。MAP_PRIVATE 表示被映射的对象是一个私有的，写时复制的对象，而 MAP_SHARED 表示一个共享对象。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bufp = mmap(<span class="literal">NULL</span>,size,PROT_READ,MAP_PRIVATE|MAP_ANON,<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>以上代码让内核创建一个新的包含 size 字节的只读，私有，请求二进制零的虚拟内存区域。如果调用成功，那么 bufp 包含新区域的地址。</p><p>munmap 函数删除虚拟内存的区域：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">munmap</span><span class="params">(<span class="type">void</span> *start,<span class="type">size_t</span> length)</span>;</span><br></pre></td></tr></table></figure><p>munmap 函数删除从虚拟地址 start 开始，接下来 length 字节组成的区域。如果之后对已经删除区域的引用会导致段错误。</p><p>习题：编写一个 C 程序 mmapcopy.c，使用 mmap 将一个任意大小的磁盘文件复制到 stdout。输入文件名字必须作为一个命令行参数来传递。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span>* argv[])</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(argc!=<span class="number">2</span>)&#123;</span><br><span class="line">        <span class="type">char</span> s[<span class="number">30</span>];</span><br><span class="line">        <span class="built_in">sprintf</span>(s,<span class="string">&quot;使用方法: %s 文件名\n&quot;</span>,argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">fputs</span>(s,<span class="built_in">stderr</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">statbuf</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> fd = open(argv[<span class="number">1</span>],O_RDONLY);</span><br><span class="line">    stat(argv[<span class="number">1</span>],&amp;statbuf);</span><br><span class="line">    <span class="type">int</span> length = statbuf.st_size;</span><br><span class="line"></span><br><span class="line">    <span class="type">void</span>* bufp = mmap(<span class="literal">NULL</span>,length,PROT_READ,MAP_SHARED,fd,<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> len = write(<span class="number">1</span>,bufp,length);</span><br><span class="line"></span><br><span class="line">    close(fd);</span><br><span class="line">    munmap(bufp,length);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态分配内存">动态分配内存</h2><p>虽然可以使用低级的 mmap 和 munmap 函数创建和删除虚拟内存区域，但是 C程序员还是会觉得使用动态内存分配器(dynamic memory allocator)更方便，也有更好的可移植性。</p><p>动态内存分配器维护着一个进程的虚拟内存区域，称为堆(head)。假设堆是一个请求二进制零的区域，它紧挨着未初始化的数据区域后开始，并向更高地址生长。对于每个进程，内核维护者一个变量 brk(break)，它指向堆的顶部。如下图所示：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_239E7761CD51-1.jpeg" alt="IMG_239E7761CD51-1" style="zoom:50%;" /><p>分配器将堆视为一组不同大小的块(block)的集合来维护，每个块就是一个连续的虚拟内存片(chunk)，要么是已经分配的，要么是空闲的。一个已分配的块保持已分配状态，直到它被释放，这种释放要么是应用程序显示执行的，要么是内存分配器自身隐式执行的。</p><p>分配器有两种风格，它们的区别在于哪个实体来负责释放已经分配的块：</p><ul><li>显式分配器(explicit allocator)，要求应用显式地释放任何已分配的块。例如，C 标准库提供一种叫做 malloc 程序包的显式分配器。C 程序通过调用 malloc 函数来分配一个块，并通过调用 free 函数来释放一个块。C++ 中的 new 和 delete 操作符与 C 中的 malloc 和 free 相当。</li><li>隐式分配器(implicit allocator)，另一方面，要求分配器检测到一个已分配块何时不被程序使用，就释放这个块。隐式分配器也叫垃圾收集(garbage collection)。例如 Lisp，ML 以及 Java 之类的高级语言就依赖垃圾收集来释放已分配的块。</li></ul><h3 id="malloc-和-free-函数">malloc 和 free 函数</h3><p>C 标准库提供了称为 malloc 程序包的显式分配器。程序通过调用 malloc 函数来从堆中分配块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">malloc</span><span class="params">(<span class="type">size_t</span> size)</span>;</span><br><span class="line"><span class="comment">// 返回值 执行成功返回已分配块的指针，失败则返回 NULL</span></span><br></pre></td></tr></table></figure><p>malloc 返回大小至少为 size 字节的内存块，这个块会为可能包含在这个块内的任何数据对象类型做对齐。在 32 位模式下，malloc 返回的块的地址总是 8 的倍数，在 64 位模式中，该地址总是 16 的倍数。</p><blockquote><p>在本节中，我们假设字是 4 字节对象，双字是 8 字节对象。</p></blockquote><p>当申请的动态内存超过虚拟内存可提供的最大大小，就返回 NULL，并设置 errno。malloc 不初始化它返回的内存。malloc 并不初始化它返回的内存，可以使用 calloc 获得已经初始化的内存，它是一个基于 malloc 的瘦包装函数，它将初始化内存初始化为 0。想要改表一个已分配块的大小，可以使用 realloc 函数。</p><p>动态内存分配器，例如 malloc，可以通过使用 mmap 和 munmap 函数，显式地分配和释放堆内存，或者还可以使用 sbrk 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> *<span class="title function_">sbrk</span><span class="params">(<span class="type">intptr_t</span> incr)</span>;</span><br><span class="line"><span class="comment">// 返回值 若执行成功返回 旧的 brk 指针，出错返回 -1</span></span><br></pre></td></tr></table></figure><p>sbrk 函数通过将内核的 brk 指针增加 incr 来扩展和收缩堆。成功则返回 brk 的旧值，否则返回 -1，并将 errno 设置为 ENOMEM。如果 incr 为 0，那么 sbrk 就返回当前值。incr 为负也是合法的，因为返回值(brk 的旧值)指向距新堆顶向上 abs(incr)字节处。</p><p>程序通过调用 free 函数来释放已经分配的堆块</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">free</span><span class="params">(<span class="type">void</span> *ptr)</span>;</span><br><span class="line"><span class="comment">// 无返回值</span></span><br></pre></td></tr></table></figure><p>ptr 参数必须指向一个从 malloc, calloc, 或者 realloc 获得的已分配块的起始地址。如果不是，则 free 的行为是未定义的。更糟的是，它什么都不返回，free 就不会告诉应用程序出现了错误。</p><p>下图展示了 malloc 和 free 的实现如何管理一个 C 程序的 16字的(非常)小的堆。每个方框代表了一个 4 字节的字，有阴影表示已分配的块，无阴影表示空闲块。初始时，堆是由一个大小为 16个字的，双字对齐的，空闲块组成的。具体分配过程如下图所示：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_8CD3D184A04B-1.jpeg" alt="IMG_8CD3D184A04B-1" style="zoom:50%;" /><h3 id="为什么要使用动态内存">为什么要使用动态内存</h3><p>某些数据需要实际运行的时候才能确定大小，所以需要动态地分配内存。</p><h3 id="分配器的要求和目标">分配器的要求和目标</h3><p>分配器必须在以下严格约束条件下工作：</p><ul><li>处理任意请求序列：分配器不可以假设分配和释放请求的顺序。</li><li>立即响应请求：不能为了提供性能而重新排列或者缓冲请求。</li><li>只使用堆：为了使分配器是可扩展的，分配器使用的任何非标准数据结构都必须保存在堆里。</li><li>对齐块：分配器必须对齐块，使得它们可以保存任何数据类型。</li><li>不修改已经分配的块：只能操作或改变空闲块。</li></ul><p>在满足以上条件下：分配器应该尽可能实现吞吐率最大化，内存使用率最大化。往往这两方面是相互矛盾的。</p><p>目标1：最大吞吐率</p><p>吞吐率定义为每个单位时间里完成的请求数。合理性能为：一个分配请求的最糟运行时间与空闲块的数量成线性关系，而一个释放请求的运行时间是个常数。</p><p>目标2：最大内存利用率</p><p>最有用的标准是峰值利用率。</p><h3 id="碎片">碎片</h3><p>造成堆利用率低的主要原因就是内存碎片。分为内部碎片和外部碎片。</p><p>内部碎片：已分配块比有效载荷大的时候发生，比如有时为了使内存对齐，实际分配数量比请求分配数量大。</p><p>外部碎片：空闲内存块合计起来足够满足一个分配请求，但是没有一个单独的空闲块足够大可以处理这个请求时发生。外部碎片难以量化且不可预测，所以分配器通常采用启发式策略来试图维持少量的大空闲块，而不是维持大量的小空闲块。</p><h3 id="实现问题">实现问题</h3><p>很容易想到将堆作为一个很大的字节数组，还有一个指针 p，初始时指向这个数组第一个字节。这中分配方式每个 malloc 和 free 只执行很少量的指令，因而吞吐率极好。但这种方式从不重复使用任何块，内存利用率将极差。为了平衡吞吐率和内存利用率，必须考虑以下问题：</p><ul><li>空闲块组织。</li><li>放置：选择一个合适的空闲块。</li><li>分割：从一个大块分配完内存之后                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              ，如何处理它的剩余部分。</li><li>合并：如何处理一个刚刚被释放的块。</li></ul><p>在下面的部分，介绍一种称为 隐式空闲链表的简单空闲块组织结构。</p><h3 id="隐式空闲链表">隐式空闲链表</h3><p>任何实际的分配器都需要一些数据结构，允许它来区分块边界，以及已分配块和未分配块。大多数分配器将这些信息嵌入块本身，如下图所示：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-11-06%20%E4%B8%8A%E5%8D%8811.30.41.png" alt="截屏2021-11-06 上午11.30.41" style="zoom: 67%;" /><p>当考虑到字节对齐时，块的大小总是 8 的倍数，所以块大小的最低 3 位总是 0。我们可以利用最高的 29位保存块大小，剩余的 3 位保存其它信息，例如是否已分配等。</p><p>假设我们有一个已分配的块，大小为24 (0x18)字节，那么它的头部将是：<code>0x00000018 | 0x1 = 0x00000019</code></p><p>头部后面是应用调用 malloc 时请求的有效载荷(实际用于存放数据的大小)，有效载荷后是一片不使用的填充块，其大小是任意的，填充的原因：对付外部碎片，满足内存对齐要求。</p><p>如下图所示，将堆组织为一个连续的已分配块和空闲块的序列：</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_39CE7ADFE601-1.jpeg" alt="IMG_39CE7ADFE601-1"></p><p>我们称这种方式为隐式空闲链表，因为空闲块是通过头部中的大小字段隐含地连接着的，分配器可以便利链表中的所有块，从而间接地遍历整个空闲块的集合。</p><p>隐式空闲链表优点：简单。显著缺点：每次都需要遍历，时间复杂度高。</p><p>很重要的一点是系统对齐要求和分配器对块格式的选择会对分配器上的最小块大小有强制的要求。没有已分配块和空闲块可以比这个最小值还要小。</p><h4 id="放置已分配的块">放置已分配的块</h4><p>当请求分配 k 字节的内存块时，分配器会遍历空闲链表，查找一个足够大的可以放置所请求块的空闲块。分配器执行这种搜索的方式是由放置策略确定的：</p><ul><li><p>首次适配(first fit)</p><p>选择第一个合适的空闲块。</p><p>**优点：**趋向于将大的空闲块保留在链表的后面。</p><p>**缺点：**趋向于在靠近链表起始处留下空闲块的“碎片”，这就增大了对较大块的搜索时间。</p></li><li><p>下一次适配(next fit)</p><p>和首次适配类似，只不过是从上一次查询结束的地方开始。</p><p>**优点：**比首次适配运行的更快一些，尤其当链表的前面布满了许多小的碎片时。</p><p>**缺点：**内存利用率比首次适配要低很多。</p></li><li><p>最佳适配(best fit)</p><p>检查每个空闲块，选择适合所需请求大小的最小空闲块。</p><p>**优点：**内存利用率比首次适配和下一次适配都要高一些。</p><p>**缺点：**需要遍历整个隐式链表。</p></li></ul><h4 id="分割空闲块">分割空闲块</h4><p>一旦分配器找到一个匹配的空闲块，它就需要做出以下决定：</p><ul><li><p>使用整个空闲块</p><p>**缺点：**易造成内部碎片。</p><p>如果放置策略趋向于产生好的匹配，那么额外的内部碎片也是可以接受的。</p></li><li><p>分割空闲块，其中一部分变成已分配块，剩下的部分作为空闲块。</p></li></ul><p>下图展示了分割器如何分割图 9-36 中 8 个字的空闲块，来满足一个应用对堆内存 3 个字的请求。</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_AD6CC096A171-1.jpeg" alt="IMG_AD6CC096A171-1"></p><h4 id="获取额外的堆内存">获取额外的堆内存</h4><p>如果分配器不能为请求块找到合适的空闲块怎么办？</p><ul><li>合并多个连续的空闲块，组成一个更大的空闲块。</li><li>如果上一个方法也不能满足要求，空闲块已经最大限度地合并了，那么分配器就会通过 sbrk 函数，向内核请求额外的堆内存。分配器将额外的内存转化成一个大的空闲块，将这个空闲块插入到空闲链表中。</li></ul><h4 id="合并空闲块">合并空闲块</h4><p>当分配器释放一个已分配块时，可能有其它空闲块与这个新释放的空间块相临，这些邻接的空闲块可能引起一种现象，叫做假碎片(fault fragmentation)。如下图所示：</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_71D1416EFF98-1.jpeg" alt="IMG_71D1416EFF98-1"></p><p>为了解决假碎片问题，任何实际的分配器都必须合并相临的空闲块，这个过程称为合并。合并分为两种：</p><ul><li><p>立即合并：在每次一个块被释放时，就合并所有相邻块。</p><p>**优点：**简单明了，可以在常数时间内执行完成。</p><p>**缺点：**对于某些请求，这种方式会产生一种形式的抖动，块会马上合并，然后马上分割。</p></li><li><p>推迟合并：直到某个分配请求失败，然后扫描整个堆，合并所有空闲块。</p></li></ul><p>快速的分配器通常会选择某种形式的推迟合并。</p><h4 id="带边界标记的合并">带边界标记的合并</h4><p>当我们想释放当前块，想要合并下一块很简单和高效。当前块的头部指向下一块的头部，可以检查这个指针以判断下一块是否空闲，如果是，就将它的大小简单地加到当前块头部大小上，这样在常数时间下就将这两个块合并了。</p><p>那怎么和前面的块合并，这时候唯一的选择是搜索整个链表。Kunth 提出了一种聪明的技术，叫做边界标记(boundary tag)，允许在常数时间内进行对前面块的合并。这种思想是在每个块的结尾添加一个脚部(footer，边界标记)，其中脚步就是头部的一个副本，这样分配器就可以通过前一块的脚部判断前一块的起始位置和状态。这个脚步总是在距当前块开始位置一个字的距离。</p><p>分配器释放当前块时所有可能存在的情况：</p><ul><li>前面的块和后面的块都已分配的。</li><li>前面的块是已分配的，后面的块是空闲的。</li><li>前面的块是空闲的，后面的块是已分配的。</li><li>前面和后面的块都是空闲的。</li></ul><p>具体合并过程如下图所示：</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_CEA6A9AC4BA6-1.jpeg" alt="IMG_CEA6A9AC4BA6-1"></p><p>边界标记和概念是简单优雅的，但它确存在一个潜在的缺陷，它要求每个块都保持一个头部和一个脚部，在应用程序操作许多个小块时，会产生显著的内存开销。</p><p>幸运的是，有一种非常聪明的边界标记的优化方法，能够使得在已分配块中不再需要脚部。回想下，当我们试图在内存中将当前块与前面的块，后面的块合并时，只有在前面是空闲块时，才会需要用到它的脚部。<strong>如果我们把前面块的已分配/空闲位存放在当前块中多出来低位中，那么已分配的块就不需要脚部了。不过空闲块仍然需要脚部。</strong></p><h3 id="显式空闲链表">显式空闲链表</h3><p>对于隐式空闲链表来说，块的分配与堆块的总数呈线性关系，不适合作为通用的分配器。</p><p>一种更好的方式是将空闲块组织为某种形式的显式数据结构。例如，堆可以组织成一个双向空闲链表，在每个空闲块中，都包含一个 pred(前驱)和succ(后继)，如下图所示：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_C7AEF56C08B8-1.jpeg" alt="IMG_C7AEF56C08B8-1" style="zoom:67%;" /><p>使用双向链表而不是隐式链表，使首次适配的分配时间从块总数的线性时间减少到了空闲块数量的线性时间。释放一个块可以线性时间，也可以是常数时间：</p><ul><li>后进先出(FIFO)的顺序维护链表：将新释放的块放置在链表的开始处，采用首次适配策略，分配器会最先检查最近使用过的块。如果使用了边界标记，合并也可以在常数时间内完成。</li><li>按照地址顺序来维护链表：链表中每个块的地址都小于它后继的地址，释放一块需要线性时间的搜索来定位合适的前驱。平衡点在于，按照地址排序的首次适配LIFO排序的首次适配有更高的内存利用率，接近最佳适配的利用率。</li></ul><h4 id="分离的空闲链表">分离的空闲链表</h4><p>一种流行的减少分配时间的方法，称为分离存储，就是维护多个空闲链表，其中每个块有大致相等的大小。一般的思路是将所有可能的大小分成一些等价类，叫做大小类(size class)。有多种方式定义大小类，例如，可以根据 2 的幂来划分：</p><p>{1},{2},{3,4},{5~8},…,{1025~2048},{2049~4096},{4097 ~ 无限大}</p><p>分配器维护一个空闲链表数组，每个大小类一个空闲链表，按照大小升序排练，从小的开始搜索，如果不满足就搜索下一个链表。</p><h4 id="简单分离存储">简单分离存储</h4><p>如果某个大小类定义为{17 ~ 32}，那么这个类的空闲链表完全由大小为 32 的块组成。</p><p>为了分配一个给定大小的块，检查相应的空闲链表，如果非空，简单地分配其中第一块的全部，否则检查下一个链表。如果都不满足，分配器就向操作系统请求一个固定大小的内存页，将这个页分成大小相等的块，并将这些块链接起来形成新的空闲链表。</p><p>这种方式优点：分配和释放都是很快的常数时间。</p><p>缺点：容易产生内部和外部碎片。</p><h4 id="分离适配">分离适配</h4><p>分配维护一个空闲链表的数组，每个空闲链表是和一个大小相关联的，并且被组成某种类型的显式或隐式链表。链表包含潜在的大小不同的块，这些块是大小类的成员。为了分配一个块，首先确定请求的大小类，做首次适配，查找一个合适的块，找到了，就(可选)分割它，将剩余部分插入到适当的空闲链表中。找不到就搜索下一个更大的空闲链表。搜索完所有的大小类，都找不到就向操作系统申请额外的堆内容，从这个对内存中分配出一块，将剩余部分放置在合适的大小类中。要释放一个块，首先执行合并，并将结果放置到相应的空闲链表中。</p><p>C 标准库中提供的 GNU malloc 包就是采用的这种方法，优点：快速，内存利用率高。</p><h4 id="伙伴系统">伙伴系统</h4><p>每个大小类都是 2 的幂，假设一个堆的大小是 2<sup>m </sup>个字，我们为每个块大小 2<sup>k </sup>维护一个分离空闲链表，其中 0&lt;=k&lt;=m，请求块大小向上舍入到 2 的幂，最开始只有大小为 2<sup>m</sup> 个字的空闲块。</p><p>为了分配一个大小为 2<sup>k</sup> 的块，首先找到第一个可用的，大小为 2<sup>j</sup> 的块，其中 k&lt;=j&lt;=m，如果 j==k，那么搜索完成，否则递归地二分割这个块，知道 j==k。当我们进行这样的分割时，每个剩下的半块(也叫做伙伴)被放置在相应的空闲链表中。要释放一个大小为  2<sup>k</sup> 的块，就合并空闲的伙伴。当遇到一个已分配的伙伴时，就停止。</p><p>对于伙伴系统：给定地址和块的大小，很容易计算出它的伙伴的地址，一个块的地址和他的伙伴的地址只有一位不相同。</p><p>优点：快速搜索，快速合并。</p><p>缺点：2 的幂可能导致显著的内部碎片。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态内存 </tag>
            
            <tag> Linux </tag>
            
            <tag> 虚拟内存 </tag>
            
            <tag> 内存映射 </tag>
            
            <tag> fork </tag>
            
            <tag> execve </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟内存的作用，虚拟地址，页表，TLB，缓存原理</title>
      <link href="/2021/11/09/xu-ni-nei-cun-de-zuo-yong-xu-ni-di-zhi-ye-biao-tlb-huan-cun-yuan-li/"/>
      <url>/2021/11/09/xu-ni-nei-cun-de-zuo-yong-xu-ni-di-zhi-ye-biao-tlb-huan-cun-yuan-li/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="9-1-物理地址和虚拟地址">9.1 物理地址和虚拟地址</h2><p>计算机系统的主存是由 M 个连续的字节大小的单元组成的数组。每个字节都有一个唯一的物理地址，地址范围从 0 到 M-1。计算机使用内存最自然的方式是使用物理地址，我们将这种方式称为物理寻址。</p><p>CPU 向内存发送一个地址，内存将该地址开始的四个字节信息传送到 CPU 中的一个 4字节寄存器。</p><span id="more"></span><p>另一种方式是使用虚拟地址，CPU 通过生成一个虚拟地址(VA)来访问主存，这个虚拟地址在被送到内存之前先转换成适当的物理地址，负责地址转换的专门硬件叫内存管理单元(MMU)。</p><h2 id="9-2-地址空间">9.2 地址空间</h2><p><strong>地址空间定义</strong>：一个非负整数地址的有序集合：{0,1,2,…}</p><p>如果地址空间是连续的，被称为线性地址空间(linear address space)</p><p>在一个带有虚拟内存的系统，CPU 从一个有 N=2<sup>n</sup>个地址的地址空间中生成虚拟地址，这个地址称为<strong>虚拟地址空间</strong>(virtual address space)：{0,1,2,…,N-1}</p><p>一个<strong>地址空间的大小</strong>由表示最大地址所需的位数来描述，例如：一个包含 N=2<sup>n</sup>个地址的虚拟地址空间就叫做一个 n 位地址空间。现代系统通常支持 32位 或 64位 虚拟地址空间。</p><blockquote><p>理解地址空间的概念很重要，因为它清除地区分了数据对象(字节)和它们的属性(地址)。</p></blockquote><h2 id="9-3-虚拟内存作为缓存的工具">9.3 虚拟内存作为缓存的工具</h2><p>虚拟内存系统(VM)通常将虚拟内存分割为称为虚拟页(Virtual Page，VP)的大小固定的块来处理这个问题。每个虚拟页的大小为P=2<sup>p</sup>字节，类似地，物理内存被分割成物理页(Physical Page，PP)，大小也为 P 字节，物理页也称为页帧。</p><p>任意时刻：虚拟页面的集合分为三个不相交的子集：</p><ul><li>未分配的</li><li>缓存的</li><li>未缓存的</li></ul><p>如下图所示：一个含有 8 个虚拟页的小虚拟内存，虚拟页 0 和 3 还没有被分配，虚拟页1，4和6被缓存在物理内存中。页 2，5，7 已经被分配了，但还未缓存在主存中。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-10-31%20%E4%B8%8B%E5%8D%885.23.30.png" alt="截屏2021-10-31 下午5.23.30" style="zoom:50%;" /><h3 id="9-3-1-DRAM-缓存的组织结构">9.3.1 DRAM 缓存的组织结构</h3><p>使用术语 SRAM 表示位于 CPU 和主存之间的 L1，L2 和 L3 高速缓存，使用术语 DRAM（称为主存） 缓存来表示虚拟内存系统的缓存，它在主存中缓存虚拟页。</p><p>通常情况下，DRAM 比 SRAM 满大约 10倍，而磁盘比 DRAM 满大约 100 000 多倍，因此 SRAM 缓存不命中比SRAM缓存不命中的代价要高昂的多。总的来说，DRAM 缓存的组织结构完全是由巨大的不命中开销驱动的。</p><p>为了减少不命中产生的开销，虚拟页往往很大，通常是 4KB 到 2MB，DRAM 缓存是全相联的，即任何虚拟页都可以放置在任何的物理页中。因为对磁盘的访问时间很长，DRAM 缓存总是使用写回(Write-Back)，而不是直写(Write-Through)。</p><blockquote><p>写回：将数据写入缓存页中，当缓冲页被替换时再写入磁盘。这样能明显提升系统运行效率，因为访问缓存和访问磁盘的速度不是一个量级的。</p><p>直写：不经过缓存，直接将数据写入磁盘，然后将缓存页的脏位置为1，当读取到该缓时再从磁盘读取该页。</p></blockquote><h3 id="9-3-2-页表">9.3.2 页表</h3><p>同任何缓存一样，虚拟内存必须有某种方法来判定一个虚拟页是否缓存在 DRAM 中的某个地方，如果缓存了的话，还必须确定这个虚拟页存放在哪个物理页中，如果不命中，系统必须判断这个虚拟页存放在磁盘的哪个位置，在物理内存中选择一个将其移出(如果物理内存已经满了的话)，然后将虚拟页从磁盘复制到 DRAM 中。</p><p>这些功能由软硬件联合提供，包括操作系统软件，MMU(内存管理单元)中的地址翻译硬件和一个存放在物理内存中叫做页表(Page table)的数据结构，页表将虚拟页映射到物理页。每次地址翻译硬件将一个虚拟地址转换为物理地址时，都会读取页表。操作系统负责维护页表的内容，以及在磁盘和DRAM 之间来回传送页。</p><p>下图所示一个页表的基本组织结构：页表就是一个页表条目的数组(Page Table Entry，PTE)的数组，虚拟地址空间中的每个页在页表中一个固定偏移量处都有一个 PTE。我们假设每个 PTE 都有一个有效位(valid bit)和一个 n 位地址字段组成的。有效位表明该虚拟页当前是否被缓存在 DRAM 中，如果设置了有效位，那么 PTE 的地址字段就表示 DRAM 中相应物理页的起始位置，这个物理页缓存了虚拟页。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-10-31%20%E4%B8%8B%E5%8D%885.55.08.png" alt="截屏2021-10-31 下午5.55.08" style="zoom: 50%;" /><p>如上图所示：展示了一个有 8 个虚拟页和 4 个物理页的系统的页表，4 个虚拟页(VP1，VP2，VP4，VP7)被缓存在 DRAM 中，2 个页(VP0 和 VP5) 还未被分配，剩下的(VP3 和 VP6)已经被分配了，但是当前还未被缓存。</p><h3 id="9-3-3-页命中">9.3.3 页命中</h3><p>当 CPU 访问的虚拟页已经被缓存在 DRAM 中时，称为命中，这时直接从 PTE 中取出物理地址，然后从 DRAM 中直接取出数据即可。</p><h3 id="9-3-4-缺页">9.3.4 缺页</h3><p>DRAM 中缓存不命中称为缺页(Page fault)，当发生缺页时，触发缺页中断，执行内核中的缺页异常处理程序，如果主存已经满了的话，该程序将主存中的一个物理页换回磁盘，然后将所缺的页调用主存。</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-10-31%20%E4%B8%8B%E5%8D%886.19.47.png" alt="截屏2021-10-31 下午6.19.47"></p><p>如下图所示：内核从磁盘复制 VP 3 到内存中的 PP 3，更新 PTE 3，随后返回。</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-10-31%20%E4%B8%8B%E5%8D%886.27.55.png" alt="截屏2021-10-31 下午6.27.55"></p><p>由上述两图展现的缺页过程，称为<strong>按需页面调度</strong>：一直等待，直到最后时刻，也就是不命中发生时，才换入页面的这种策略称为按需页面调度(demand paging)。也可以采用其它方式，例如 尝试预测不命中，在页面实际被引用前就换入页面。不过，几乎所有的现代系统都是用按需页面调度。</p><h3 id="9-3-5-分配页面">9.3.5 分配页面</h3><p>下图展示了分配一个新的虚拟内存页时对页表的影响，当调用 malloc 时便会发生这种过程。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-10-31%20%E4%B8%8B%E5%8D%886.36.03.png" alt="截屏2021-10-31 下午6.36.03" style="zoom:50%;" /><h3 id="9-3-6-又是局部性救了我们">9.3.6 又是局部性救了我们</h3><p>了解了虚拟内存的基本概念之后，它的不命中通常代价非常高昂，那么虚拟内存的效率是否非常低呢？实际上虚拟内存工作的相当好，这主要归功于局部性原理(locality)。尽管整个运行过程中程序引用的不同页面的总数可能超出物理内存的总大小，但是局部性原则保证了在任意时刻，程序将趋向于在一个较小的活动页面(active page)集合上工作，这个集合叫做工作集(working set)或者常驻集合(resident set)。</p><p>当然并不是所有程序都能展现良好的时间局部性。如果工作级的大小超出了物理内存的大小，那么程序将产生一种不幸的状态，叫做抖动(thrashing)，这时页面将不断地换入换出。</p><blockquote><p>可以利用 Linux 的 getrusage 函数监测缺页的数量。</p></blockquote><h2 id="9-4-虚拟内存作为内存管理的工具">9.4 虚拟内存作为内存管理的工具</h2><p>虚拟内存大大地简化了内存管理，并提供了一种自然的保护内存的方法。操作系统为每一个进程都提供了一个独立的虚拟地址空间，下图展示了其基本思想。多个页面可以映射到同一个共享物理页面。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-10-31%20%E4%B8%8B%E5%8D%888.50.53.png" alt="截屏2021-10-31 下午8.50.53" style="zoom:50%;" /><p>按需页面调度和独立的虚拟地址空间的结合，对系统内存的使用和管理造成了深远的影响。特别是，VM 简化了链接和加载，代码和数据共享，以及应用程序的内存分配。</p><ul><li><p>简化链接：独立的地址空间允许每个进程的内存映像使用相同的基本格式，而不管代码和数据实际存放在物理内存的何处。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-10-31%20%E4%B8%8B%E5%8D%888.56.15.png" alt="截屏2021-10-31 下午8.56.15" style="zoom:33%;" /></li><li><p>简化加载：虚拟内存还使得容易向内存中加载可执行文件和共享对象文件。对于程序需要使用的 .text 和 .data 还可实现按需加载，加载器首先为代码和数据段分配虚拟页，把它们标记为无效的(未被缓存)，当实际用的时候才去磁盘中加载。</p><blockquote><p>将一组连续的虚拟页映射到任意一个文件中的任意位置的表示法称为内存映射(memory mapping)。Linux 提供了一个称为 mmap 的系统调用，允许应用程序自己做内存映射。</p></blockquote></li><li><p>简化共享：独立地址空间为操作系统提供一个管理用户进程和操作系统自身之间共享的一种机制。一般而言，每个进程都有自己的代码，数据，堆以及栈区域，是不和其它进程共享的，在这种情况下，操作系统创建页表，将相应的虚拟页映射到不连续的物理页面。</p></li><li><p>简化内存分配：虚拟内存向用户进程提供了一个简单的分配额外内存的方式。当一个运行在用户进程中的程序要求额外的堆空间时(如调用 malloc 的结果)，操作系统分配一个适当数字(例如 k )个连续的虚拟内存页面，并且将它们映射到内存中任意位置的 k 个任意的物理页面。由于页表工作的方式，操作系统没有必要分配 k 个连续的物理内存页面。页面可以随机地分散在物理内存中。</p></li></ul><h2 id="9-5-虚拟内存作为内存保护的工具">9.5 虚拟内存作为内存保护的工具</h2><p>现在计算机系统必须为操作系统提供手段来控制对内存系统的访问。不应该允许一个用户进程修改它的只读代码段。而且也不允许它读或修改任何内核中的代码和数据结构。不允许它读或写其它进程的私有内存，不允许它修改任何与其它进程共享的虚拟页面，除非所有共享者都显示地允许它这么做(通过进程间通信)。</p><p>虚拟内存每次访问内存，都有一个地址翻译的过程，即每次 CPU 生成一个地址时，地址翻译硬件都会读一个 PTE，通过在 PTE 上添加一些额外的许可来控制一个虚拟页面内容的访问十分简单。如下图所示：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-10-31%20%E4%B8%8B%E5%8D%889.16.24.png" alt="截屏2021-10-31 下午9.16.24" style="zoom: 50%;" /><p>在上述实例中，每个 PTE 中已经添加了三个许可，SUB 位表示是否必须运行在内核模式下才能访问该页，READ位和WRITE位控制对页面的读写。如果一条指令违反了这些许可条件，CPU 就触发一个一般保护故障，将控制传递给内核中一个异常处理程序。Linux shell 将这种异常报告称为“段错误(segmentation fault)”</p><h2 id="9-6-地址翻译">9.6 地址翻译</h2><p>以下为讨论本节需要的符号：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_BBF2272209FF-1.jpeg" alt="IMG_BBF2272209FF-1" style="zoom: 67%;" /><p>地址翻译就是一个虚拟地址到一个物理地址的翻译过程。一个虚拟地址包含两部分，虚拟页号(VPN)，虚拟页内偏移(VPO)。通过虚拟页号(可以理解为数组下标)，在页表(可以理解为数组)中找到对应的条目，条目内容为物理页号，将物理页号和虚拟页内偏移结合起来，就可以组成一个物理地址。完整过程如下图所示：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_99886A9EF173-1.jpeg" alt="IMG_99886A9EF173-1" style="zoom: 67%;" /><p>当页面命中时，CPU 硬件执行步骤如下：</p><ol><li>处理器生成一个虚拟地址(VA)，并把它传送给MMU。</li><li>MMU 从虚拟地址(VA)取出虚拟页号(VPN) ，并从高速缓存/主存请求获得PTE条目</li><li>高速缓存/主存向 MMU 返回 PTE</li><li>MMU 根据返回的 PTE 获得物理页号(PPN)，和 VPO 组合形成物理地址，并将物理地址发送给高速缓存/主存</li><li>高速缓存/主存返回所请求的数据给 CPU</li></ol><p>具体过程如下：</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-11-01%20%E4%B8%8B%E5%8D%8810.54.23.png" alt="截屏2021-11-01 下午10.54.23"></p><p>当页面不命中时，CPU 硬件执行步骤如下：</p><p>1-3 步和上图命中时相同</p><ol start="4"><li>PTE 的有效位是 0，所以 MMU 触发了一次异常，将 CPU 控制权转移给操作系统内核中的缺页异常处理程序。</li><li>缺页处理程序确定物理内存中的牺牲页，如果这个页已经被修改，则把它换出到磁盘。</li><li>缺页处理程序掉入新的页面，并更新内存中的 PTE。</li><li>缺页处理程序返回到原来的进程，再次执行缺页异常的指令。之后的操作就是页面命中的操作。</li></ol><h3 id="9-6-1-结合高速缓存和虚拟内存">9.6.1 结合高速缓存和虚拟内存</h3><p>从 9.6 的分析可以看出，每次访问数据，都至少访问内存两次。为了加快数据的访问速度，现代计算机通常在 CPU 和主存之间加一个页表高速缓存(Cache)，Cache 存储页号和物理页号，这样只需访问一次高速缓存和一次内存即可取出内存中的数据。</p><p>带有高速缓存的内存访问过程如下：</p><p>高速缓存命中时：</p><ol><li>处理器生成一个虚拟地址(VA)，并把它传送给MMU。</li><li>MMU 从虚拟地址(VA)取出虚拟页号(VPN) ，并从高速缓存请求获得物理页号(PPN)。</li><li>MMU 将物理页号和虚拟页内偏移组合形成物理地址，并将该地址发送给主存。</li><li>主存返回数据给 CPU</li></ol><p>高速缓存未命中时：</p><ol><li>处理器生成一个虚拟地址(VA)，并把它传送给MMU。</li><li>MMU 从虚拟地址(VA)取出虚拟页号(VPN) ，并从高速缓存请求获得物理页号(PPN)。</li><li>该页不在高速缓存中，高速缓存使用 VPN 从内存请求获得 PTE。</li><li>若高速缓存已经满了，则剔除一个较旧的页，将新返回的 PTE 插入高速缓存中。</li><li>高速缓存将物理页号和虚拟页内偏移组成物理地址，并发送给内存。</li><li>内存返回数据给高速缓存。</li><li>高速缓存将数据发送给 CPU。</li></ol><p>具体过程如下：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_F0C51817CA3B-1.jpeg" alt="IMG_F0C51817CA3B-1" style="zoom: 67%;" /><h3 id="9-6-2-利用-TLB-加速地址翻译">9.6.2 利用 TLB 加速地址翻译</h3><p>每次 CPU 产生一个虚拟地址，MMU 就必须查阅一个 PTE，以便将虚拟地址翻译为物理地址。最糟糕的情况下，这会要求从内存多取一次数据，代价是几十到几百个周期，如果碰巧 PTE 缓存在 L1 中，那么开销就会降到 1 个或 2 个周期。</p><p>为了更快地从内存获取数据，许多系统在 MMU 中设计一个关于 PTE 的小的缓存，称为翻译后备缓冲器(Translation Lookaside Buffre, TLB)，也称之为快表。</p><p>TLB 是一个小的，虚拟寻址的缓存，其中的每一行都保存着一个由单个 PTE 组成的块，用于行匹配的索引和标记字段是从虚拟地址中的虚拟页号中提取出来的。如果 TLB 中有 T=2<sup>t</sup>个组，那么 TLB 索引由 VPN 的 t 个最低位组成，而 TLB 标记由 VPN 的剩余位组成。</p><p>下图展示了 TLB 命中时包括的步骤。这里的关键是，所有的地址翻译步骤都是在芯片上的 MMU 中执行的，因此非常快。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-11-01%20%E4%B8%8B%E5%8D%8811.43.11.png" alt="截屏2021-11-01 下午11.43.11" style="zoom:50%;" /><ol><li><p>CPU 产生一个虚拟地址。</p></li><li><ol start="3"><li>MMU 从TLB 中取出 PTE</li></ol></li><li><p>MMU 将这个虚拟地址翻译为一个物理地址，并且将它发送到高速缓存/主存。</p></li><li><p>高速缓存/主存将所请求的数据返回给 CPU。</p></li></ol><p>当 TLB 不命中时，MMU 必须从 L1 中取出相应的 PTE，新取出的 PTE 存放在 TLB 中，可能会覆盖一个已经存在的条目。具体过程如下图所示：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-11-01%20%E4%B8%8B%E5%8D%8811.47.19.png" alt="截屏2021-11-01 下午11.47.19" style="zoom:50%;" /><h3 id="9-6-3-多级页表">9.6.3 多级页表</h3><p>对于32位地址空间，4KB 的页面和一个 4 字节的 PTE，即便我们所引用的只是虚拟地址空间中很小的一部分，也总是需要一个 4MB 的页表驻留在内存中，对于地址空间为  64位的系统来说，问题将变得更复杂。</p><p>用来压缩页表的常用方法是使用层次结构的页表。假设 32位 虚拟地址空间被分为 4KB 的页，而每个页表条目都是 4 字节，假设在这一时刻，虚拟地址空间有如下形式：内存的前 2K 个页面分配给了代码和数据，接下来的 6K 个页面还未分配，再接下来的 2013 个页面也未分配，接下来的 1 个页面分配给了用户栈。下图展示了如何为这个虚拟地址空间构造一个2 级的页表层次结构。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_2F8D7239EB81-1.jpeg" alt="IMG_2F8D7239EB81-1" style="zoom: 67%;" /><p>一级页表中的每个 PTE负责映射虚拟地址空间中的一个 4MB 的片，这个的每个片都是由 1024 个连续的页面组成。假设地址空间是 4GB，1024 个PTE足以覆盖整个空间。从上图可以看出，一级页表中 PTE2 为空，这样就不用为它分配二级页表，只有在需要的时候才需要分配二级页表。</p><p><strong>多级页表好处</strong>：如果一级页表中一个 PTE 是空的，那么相应的二级页表就根本不会存在，这代表一种巨大的潜在的节约。</p><p>如下图所示，虚拟地址被划分为 k 个 VPN 和 1 个 VPO。每个 VPN<sub>i</sub> 都是一个到第 i 级页表的索引，其中 1&lt;= i &lt;=k。第 j 级页表中的每个 PTE，1&lt;=j&lt;=k-1，都指向第 j+1 级的某个页表的基址。第 k 级页表中的每个 PTE 包含某个物理页面的 PPN，或者一个磁盘块的地址。为了构造物理地址，在能够确定 PPN 之前，MMU 必须访问 k 个 PTE，对于只有一级的页表结构，PPO 和 VPO 是相同的。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_138FFAB7F9E9-1.jpeg" alt="IMG_138FFAB7F9E9-1" style="zoom:67%;" /><p>表面上看似乎多级页表的代价高昂，然而，这里 TLB 能够起作用，正是通过将不同层次上页表的 PTE 缓存起来。实际上，多级页表的地址翻译并不比单级页表慢很多。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟内存 </tag>
            
            <tag> 虚拟地址 </tag>
            
            <tag> 页表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 hexo 博客在 chrome 下无法正常显示图片的问题</title>
      <link href="/2021/11/05/jie-jue-hexo-bo-ke-zai-chrome-xia-wu-fa-zheng-chang-xian-shi-tu-pian-de-wen-ti/"/>
      <url>/2021/11/05/jie-jue-hexo-bo-ke-zai-chrome-xia-wu-fa-zheng-chang-xian-shi-tu-pian-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="出现的问题">出现的问题</h2><p>最近发现一个奇怪的问题， hexo 发的博客图片 在 Google Chrome 下无法正常显示，但在 Safari 和 FireFox 下确可以正常显示。</p><span id="more"></span><p>在 Chrome 下显示如下：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-11-05%20%E4%B8%8B%E5%8D%885.15.53.png" alt="截屏2021-11-05 下午5.15.53" style="zoom:50%;" /><h2 id="出现问题的原因">出现问题的原因</h2><p>我使用的腾讯云图床，并且开启了自定义域名的 CDN加速，但它并不支持 https 访问。</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-11-05%20%E4%B8%8B%E5%8D%886.01.54.png" alt="截屏2021-11-05 下午6.01.54"></p><p>查看下博客的网页源码，它的图片链接如下图所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://qqimage.wangjunblogs.com/uPic/%E6%88%AA%E5%B1%8F2021-11-05%20%E4%B8%8B%E5%8D%883.27.01.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;截屏2021-11-05 下午3.27.01&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到，它的链接是 http 开头的。</p><p>打开开发者选项：</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-11-05%20%E4%B8%8B%E5%8D%885.35.58.png" alt="截屏2021-11-05 下午5.35.58"></p><p>可以看到图片无法正常加载，看来原因就在这了。它的请求链接是 https 开头的，不对呀，它应该是 http 开头的呀。经过一段时间的摸索，终于知道原因了。</p><blockquote><p>自 Chrome83 版本开始，Chrome浏览器默认阻止混合内容<code>MixContent</code>的下载，加载等。既 HTTPS 网站 只能以 HTTPS 加载内容。这个问题导致很多未配置静态资源SSL证书的网站在加载图片等http内容时失败。</p></blockquote><h2 id="解决方法">解决方法</h2><p>一种方式是更换浏览器，很明显对于用户来说产生了很大的不便，还是需要从网站管理员的角度来解决问题。</p><p>最佳方法：</p><p>使用基于 HTTPS 的图床。</p><p>可以使用 github 图床，它默认支持 https。</p><p>或者使用腾讯云对象存储的默认上传地址：</p><p>打开文件基本信息，使用下图所示地址上传。</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-11-05%20%E4%B8%8B%E5%8D%886.08.53.png" alt="截屏2021-11-05 下午6.08.53"></p>]]></content>
      
      
      <categories>
          
          <category> 疑难杂症 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> chrome </tag>
            
            <tag> hexo </tag>
            
            <tag> next主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Parallels Desktop 最小安装 CentOS 7</title>
      <link href="/2021/11/05/parallels-desktop-zui-xiao-an-zhuang-centos-7/"/>
      <url>/2021/11/05/parallels-desktop-zui-xiao-an-zhuang-centos-7/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="镜像文件下载">镜像文件下载</h2><p>下载地址：<a href="http://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/">http://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/</a></p><p>BT种子：<a href="http://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/CentOS-7-x86_64-DVD-2009.torrent">http://mirrors.aliyun.com/centos/7.9.2009/isos/x86_64/CentOS-7-x86_64-DVD-2009.torrent</a></p><span id="more"></span><h2 id="完整性确认">完整性确认</h2><p>确认是否被篡改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">shasum -a 256 CentOS-7-x86_64-Minimal-2009.iso</span> </span><br><span class="line">07b94e6b1a0b0260b94c83d6bb76b26bf7a310dc78d7a9c7432809fb9bc6194a  CentOS-7-x86_64-Minimal-2009.iso</span><br></pre></td></tr></table></figure><p>sha256sum.txt</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">07b94e6b1a0b0260b94c83d6bb76b26bf7a310dc78d7a9c7432809fb9bc6194a  CentOS-7-x86_64-Minimal-2009.iso</span><br></pre></td></tr></table></figure><p>两者相同，说明未被篡改。</p><h2 id="安装">安装</h2><h3 id="新建虚拟机">新建虚拟机</h3><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-11-05%20%E4%B8%8A%E5%8D%8811.45.34.png" alt="截屏2021-11-05 下午4.26.34" style="zoom:33%;" /><h3 id="选择镜像文件">选择镜像文件</h3><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-11-05%20%E4%B8%8A%E5%8D%8811.46.08.png" alt="截屏2021-11-05 下午4.26.34" style="zoom:33%;" /><p>继续，选择快速安装</p><h3 id="设置密码，安装位置默认">设置密码，安装位置默认</h3><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-11-05%20%E4%B8%8B%E5%8D%882.40.11.png" alt="截屏2021-11-05 下午4.26.34" style="zoom:33%;" /><p>继续</p><h3 id="自动安装即可">自动安装即可</h3><p>输入账号密码即可进入系统</p><h2 id="安装-parallels-tools">安装 parallels tools</h2><p>操作菜单，选择安装 parallels tools</p><p>查看系统是否存在光驱</p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-11-05%20%E4%B8%8B%E5%8D%883.23.35.png" alt="截屏2021-11-05 下午3.23.35"  /><p>可见系统用 sr0 表示光驱，接下来挂载光驱，将其挂载到 /media 文件下。</p><blockquote><p>Linux 系统一切皆文件，包括设备。当我们要访问某个设备，就将它挂载到一个文件，然后通过这个文件来访问这个设备。</p></blockquote><p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-11-05%20%E4%B8%8B%E5%8D%883.27.01.png" alt="截屏2021-11-05 下午3.27.01"></p><p>提示：/dev/sr0 是写保护的，只读挂载，这里没有问题，因为我们只需读取它的安装文件。</p><p>接下来就可以安装 parallels tools  ，直接下一步开始安装。</p><p>出现以下页面表示，安装成功，直接回车即可。</p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-11-05%20%E4%B8%8B%E5%8D%883.38.16-20211105171504693.png" alt="截屏2021-11-05 下午4.26.34" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序的变种——快速选择算法</title>
      <link href="/2021/10/24/kuai-su-pai-xu-de-bian-chong-kuai-su-xuan-ze-suan-fa/"/>
      <url>/2021/10/24/kuai-su-pai-xu-de-bian-chong-kuai-su-xuan-ze-suan-fa/</url>
      
        <content type="html"><![CDATA[<h1>快速排序的变种——快速选择算法</h1><p>给出一个数组，例如[1,4,2,6,8,3]，现在要求出第 k 大的数字，即将数组从大到小排列，选择第k个数。用什么算法更快找到这个数？</p><p>最容易想到的就是先将数组排序，就可以很容易找到第 k 大的数字。就算用快速排序，时间复杂度为 O(nlgn)。有没有更快的算法？</p><span id="more"></span><p>快速排序每次将数组分成两部分，升序排列时，左半部分元素都大于右半部分元素，假设某次划分结果如下，中间元素下标为 mid，如果 k==mid，表示 mid 就是最终结果。如果 k&gt;mid，说明结果在右半部分中，如果  k&lt;mid，说明结果在左半部分。这就表明，我们划分完之后，只需再接着处理其中一半就可以，快速排序需要处理左右两部分。基于这个思想，我们将其称为快速选择算法。</p><p>快速选择算法 时间复杂度 O(n)  空间复杂度 (O(lgn))</p><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/">数组中的第K个最大元素</a></p><p><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/solution/shu-zu-zhong-de-di-kge-zui-da-yuan-su-by-leetcode-/">详细题解</a></p><p>我的 AC 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">quickSelect</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = <span class="built_in">partion</span>(nums,l,r);</span><br><span class="line">        <span class="keyword">if</span>(mid==k)</span><br><span class="line">            <span class="keyword">return</span> nums[mid];</span><br><span class="line">        <span class="keyword">if</span>(k&lt;mid)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums,l,mid<span class="number">-1</span>,k);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums,mid<span class="number">+1</span>,r,k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partion</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="built_in">random</span>(nums,l,r); </span><br><span class="line">        <span class="type">int</span> key = nums[l];</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[r]&lt;=key)&#123;</span><br><span class="line">                --r;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[l] = nums[r];</span><br><span class="line">            <span class="keyword">while</span>(l&lt;r &amp;&amp; nums[l]&gt;=key)&#123;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[r] = nums[l];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[l] = key;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">random</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">int</span> l,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> R = <span class="built_in">rand</span>() % (r-l<span class="number">+1</span>)+l;</span><br><span class="line">        <span class="built_in">swap</span>(nums[l],nums[R]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums,<span class="number">0</span>,len<span class="number">-1</span>,k<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>关于快速排序的详细分析：<a href="https://wangjunstf.github.io/2021/09/02/kuai-su-pai-xu-yuan-li-ji-shi-jian-fu-za-du/">快速排序分析及优化</a></p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 快速排序 </tag>
            
            <tag> 快速选择 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 智能指针需要注意的点</title>
      <link href="/2021/10/24/c-zhi-neng-zhi-zhen-xu-yao-zhu-yi-de-dian/"/>
      <url>/2021/10/24/c-zhi-neng-zhi-zhen-xu-yao-zhu-yi-de-dian/</url>
      
        <content type="html"><![CDATA[<p>C++11提供了三种智能指针：std::shared_ptr, std::unique_ptr, std::weak_ptr，使用时需添加头<code>&lt;memory&gt;</code>。</p><h2 id="智能指针与普通指针混用">智能指针与普通指针混用</h2><span id="more"></span><p>不能将一个原始指针直接赋值给智能指针。</p><p>错误示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = &amp;num;</span><br><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr = p; <span class="comment">// Error 当 ptr 引用计数变为 0 时，p 将变成空悬指针</span></span><br></pre></td></tr></table></figure><p>正确示例：尽量不要将 普通指针和智能指针<code>混用</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;<span class="type">int</span>&gt; ptr = std::<span class="built_in">make_shared</span>&lt;<span class="type">int</span>&gt;(<span class="number">123</span>);  </span><br><span class="line"><span class="function">std::shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">123</span>))</span></span>; </span><br></pre></td></tr></table></figure><p>std::make_shared 返回shared_ptr 智能指针，减少了一次内存分配操作，性能更好<br>std::make_shared 性能测试 <a href="http://tech-foo.blogspot.com/2012/04/experimenting-with-c-stdmakeshared.html">http://tech-foo.blogspot.com/2012/04/experimenting-with-c-stdmakeshared.html</a></p><h2 id="循环引用">循环引用</h2><p>循环引用将无法正常释放资源，应尽量避免。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;Node&gt; next;</span><br><span class="line">    <span class="built_in">Node</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Node construct&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Node</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Node destroy&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; A = std::<span class="built_in">make_shared</span>&lt;Node&gt;();  <span class="comment">// A 的引用计数为 1</span></span><br><span class="line">    std::shared_ptr&lt;Node&gt; B = std::<span class="built_in">make_shared</span>&lt;Node&gt;();  <span class="comment">// B 的引用计数为 1</span></span><br><span class="line"></span><br><span class="line">    A-&gt;next = B;   <span class="comment">// B 的引用计数为 2</span></span><br><span class="line">    B-&gt;next = A;   <span class="comment">// A 的引用计数为 2</span></span><br><span class="line">    <span class="comment">// 离开作用域后，A 的引用计数减 1，B 的引用计数减 1。都不为 0，A 和 B 都没有自动释放</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node construct</span><br><span class="line">Node construct</span><br></pre></td></tr></table></figure><h2 id="weak-ptr-不可直接使用对象">weak_ptr 不可直接使用对象</h2><p>要使用 weak_ptr 指向的对象，需要将 weak_ptr 提升为 shared_ptr</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::shared_ptr&lt;Node&gt; next;</span><br><span class="line">    <span class="built_in">Node</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout&lt;&lt;<span class="string">&quot;Node construct&quot;</span>&lt;&lt;std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Node</span>()&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Node destroy&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::shared_ptr&lt;Node&gt; A = std::<span class="built_in">make_shared</span>&lt;Node&gt;();  <span class="comment">// A 的引用计数为 1</span></span><br><span class="line">    std::weak_ptr&lt;Node&gt; wptr = A;        <span class="comment">// 定义 weak_ptr 不影响 A 的引用计数</span></span><br><span class="line">    </span><br><span class="line">    std::shared_ptr&lt;Node&gt; ptr= wptr.<span class="built_in">lock</span>();   <span class="comment">// 将 wptr 提升为 shared_ptr,A 的引用计数为 2</span></span><br><span class="line">    std::cout&lt;&lt;ptr.<span class="built_in">use_count</span>()&lt;&lt;std::endl;    <span class="comment">// 输出 2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 指针指针 </tag>
            
            <tag> weak_ptr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓扑排序</title>
      <link href="/2021/10/23/tuo-bu-pai-xu/"/>
      <url>/2021/10/23/tuo-bu-pai-xu/</url>
      
        <content type="html"><![CDATA[<p>什么是拓扑排序？</p><p>拓扑排序就是对<code>有向无环图</code>的顶点进行线性排列，使得从顶点 u 到顶点 v 的每个有向边，u 在排序中都在 v 的前面。一个有向无环图的拓扑排序可能有多种。</p><span id="more"></span><blockquote><p>当前仅当图中不存在环时，才有可能进行拓扑排序。</p></blockquote><p>运用拓扑排序可以解决哪些问题？</p><p>最常见的问题就是，课程安排问题。有些课是基础课程，有些课是综合课程，往往我们需要先学习基础课，再学习综合课程。现在给出所有的课，和每门课与先修课的对应关系。求出可否学完所有课程，或者课程学习的一个合理顺序。</p><p>类似的问题还有工程安排问题。</p><blockquote><p>总之拓扑排序适合于那些局部有序(两个元素之间)，总体可以无序。例如 工程 A，B，C，开始工程 B 之前 必须先完成工程 A，但 C 无要求，这样合理的工程安排顺序如下：A B C，或者 C A B。只要满足 A 在 B 的前面既可。</p></blockquote><p>题目链接：</p><p><a href="https://leetcode-cn.com/problems/course-schedule/">课程表</a>：本题需要求出能否学完所有课程。  <a href="https://leetcode-cn.com/problems/course-schedule/solution/ke-cheng-biao-by-leetcode-solution/">题解</a></p><p><a href="https://leetcode-cn.com/problems/course-schedule-ii/">课程表 II</a>：需要给出一个合理的课程学习顺序。<a href="https://leetcode-cn.com/problems/course-schedule-ii/solution/">题解</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 常用数据结构(列表,字典,元组,集合,序列,栈,队列)及方法</title>
      <link href="/2021/10/17/python-chang-yong-shu-ju-jie-gou-ji-fang-fa/"/>
      <url>/2021/10/17/python-chang-yong-shu-ju-jie-gou-ji-fang-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="列表">列表</h2><p><code>insert</code>、<code>remove</code>、<code>sort</code> 等方法只修改列表，不输出返回值——返回的默认值为 <code>None</code> 。这是所有 Python 可变数据结构的设计原则。</p><p>不是所有数据都可以排序或比较。例如，<code>[None, 'hello', 10]</code> 就不可排序，因为整数不能与字符串对比，而 None 不能与其他类型对比。</p><span id="more"></span><p>常用方法。</p><table><thead><tr><th style="text-align:center">方法名</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">list.append(x)</td><td style="text-align:left">在列表末尾添加一个元素，相当于 a[len(a):] = [x]</td></tr><tr><td style="text-align:center">list.extend(iterable)</td><td style="text-align:left">用可迭代对象的元素扩展列表。相当于 a[len(a):] = iterable</td></tr><tr><td style="text-align:center">list.insert(i, x)</td><td style="text-align:left">在指定位置插入元素。第一个参数 i 是插入元素的索引</td></tr><tr><td style="text-align:center">list.remove(x)</td><td style="text-align:left">从列表中删除第一个值为 x 的元素。未找到指定元素时，触发 ValueError 异常。</td></tr><tr><td style="text-align:center">list.pop([i])</td><td style="text-align:left">删除列表中指定位置的元素，并返回被删除的元素。未指定位置时，a.pop() 删除并返回列表的最后一个元素。(方法签名中 i 两边的方括号表示该参数是可选的，不是要求输入方括号。这种表示法常见于 Python 参考库）</td></tr><tr><td style="text-align:center">list.clear()</td><td style="text-align:left">删除列表里的所有元素，相当于 del a[:] 。</td></tr><tr><td style="text-align:center">list.index(x[, start[, end]])</td><td style="text-align:left">返回列表中第一个值为 x 的元素的零基索引。未找到指定元素时，触发 ValueError 异常。可选参数 start 和 end 是切片符号，用于将搜索限制为列表的特定子序列。返回的索引是相对于整个序列的开始计算的，而不是 start 参数。例如：list.index(3,0,2)</td></tr><tr><td style="text-align:center">list.count(x)</td><td style="text-align:left">返回列表中元素 x 出现的次数。</td></tr><tr><td style="text-align:center">list.sort(*, key=None, reverse=False)</td><td style="text-align:left">就地排序列表中的元素，关于自定义排序参数，详见 sorted()</td></tr><tr><td style="text-align:center">list.reverse()</td><td style="text-align:left">翻转列表中的元素。</td></tr><tr><td style="text-align:center">list.copy()</td><td style="text-align:left">返回列表的浅拷贝。相当于 a[:] 。浅拷贝：拷贝引用，不拷贝内存。</td></tr></tbody></table><h2 id="双端队列">双端队列</h2><p>collections.deque 是双端队列，可以在任意位置插入元素，可以从队头和队尾插入元素。</p><p>调用方法：<code>from collections import deque</code></p><p>常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>append(x)</td><td>添加 x 到右端。</td></tr><tr><td>appendleft(x)</td><td>添加 x 到左端。</td></tr><tr><td>clear()</td><td>移除所有元素，使其长度为0.</td></tr><tr><td>copy()</td><td>创建一份浅拷贝。</td></tr><tr><td>count(x)</td><td>计算 deque 中元素等于 x 的个数。</td></tr><tr><td>extend(iterable)</td><td>扩展deque的右侧，通过添加iterable参数中的元素。</td></tr><tr><td>extendleft(iterable)</td><td>扩展deque的左侧，通过添加iterable参数中的元素。注意，左添加时，在结果中iterable参数中的顺序将被反过来添加。</td></tr><tr><td>index(x[, start[, stop]])</td><td>返回 x 在 deque 中的位置（在索引 start 之后，索引 stop 之前）。 返回第一个匹配项，如果未找到则引发 ValueError。</td></tr><tr><td>insert(i, x)</td><td>在位置 i 插入 x 。</td></tr><tr><td>pop()</td><td>移去并且返回一个元素，deque 最右侧的那一个。 如果没有元素的话，就引发一个 IndexError。</td></tr><tr><td>popleft()</td><td>移去并且返回一个元素，deque 最左侧的那一个。 如果没有元素的话，就引发 IndexError。</td></tr><tr><td>remove(value)</td><td>移除找到的第一个 value。 如果没有的话就引发 ValueError。</td></tr><tr><td>reverse()</td><td>将deque逆序排列。返回 None 。</td></tr><tr><td>rotate (<em>n=1</em>)</td><td>向右循环移动 <em>n</em> 步。 如果 <em>n</em> 是负数，就向左循环。</td></tr><tr><td>maxlen</td><td>Deque的最大尺寸，如果没有限定的话就是 None 。只读属性，不能被修改</td></tr></tbody></table><blockquote><p>iterable 表示什么？</p><p>iterable 表示可迭代对象，意思是可由迭代器遍历的对象。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; items = [ <span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span> ]</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; iterator = iter(items)</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; next(iterator)</span> </span><br><span class="line">&#x27;one&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; next(iterator)</span> </span><br><span class="line">&#x27;two&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; next(iterator)</span> </span><br><span class="line">&#x27;three&#x27;</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; next(iterator)</span> </span><br><span class="line">&#x27;four&#x27;</span><br></pre></td></tr></table></figure><p>列表，字典，字符串等都属于可迭代对象（iterable）。</p><p>iterator 表示迭代器。</p></blockquote><p>除了以上操作，deque 还支持迭代、封存、len(d)、reversed(d)、copy.copy(d)、copy.deepcopy(d)、成员检测运算符 in 以及下标引用例如通过 d[0] 访问首个元素等。 索引访问在两端的复杂度均为 O(1) 但在中间则会低至 O(n)。 如需快速随机访问，请改用列表。</p><h2 id="元组">元组</h2><p>Python的元组与列表类似，不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。</p><p>元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup = ()  <span class="comment"># 创建空元组</span></span><br><span class="line">tup = (<span class="number">12</span>,) <span class="comment"># 创建只含一个元素的元组时，要加逗号</span></span><br></pre></td></tr></table></figure><p>访问元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tup[<span class="number">0</span>]       <span class="comment"># 访问 0 号元素</span></span><br><span class="line">tup[<span class="number">1</span>,<span class="number">3</span>]     <span class="comment"># 访问 1 2 号元素</span></span><br></pre></td></tr></table></figure><p>删除元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">del</span> tup</span><br></pre></td></tr></table></figure><p>常用方法</p><table><thead><tr><th>方法名</th><th>说明</th></tr></thead><tbody><tr><td>cmp(tuple1,tuple2)</td><td>比较两个元组元素</td></tr><tr><td>len(tuple)</td><td>计算元组元素个数。</td></tr><tr><td>max(tuple)</td><td>返回元组中元素最大值。</td></tr><tr><td>min(tuple)</td><td>返回元组中元素最小值。</td></tr><tr><td>tuple(list)</td><td>将列表转换为元组</td></tr></tbody></table><h2 id="队列">队列</h2><p>队列特点：先入先出</p><p>在双端队列作一些限制就可以作为队列使用。</p><p>初始化：<code>queue = deque([&quot;Hello&quot;,&quot;World&quot;])</code></p><p>入队：<code>queue.append(&quot;Larry&quot;)</code></p><p>出队：<code>queue.popleft() </code></p><p>判断非空  len(queue)!=0</p><h2 id="序列">序列</h2><p>序列和元组一样，都不可修改，但可以将多个序列连接为一个序列，也可以删除序列。</p><p>序列就是可包含多种数据类型的元组。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; t = 12345, 54321, <span class="string">&#x27;hello!&#x27;</span></span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; t</span></span><br><span class="line">(12345, 54321, &#x27;hello!&#x27;)</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; u = t,<span class="string">&#x27;world&#x27;</span>;</span></span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt; u</span></span><br><span class="line">((12345, 54321, &#x27;hello!&#x27;), &#x27;world&#x27;)      // 元组中可包含元组</span><br></pre></td></tr></table></figure><h2 id="堆栈">堆栈</h2><p>堆栈特点：先入后出</p><p>在双端队列作一些限制就可以作为堆栈使用。</p><p>初始化：<code>stack = deque([&quot;Hello&quot;,&quot;World&quot;])</code></p><p>入栈：<code>stack.append(&quot;nice&quot;)</code></p><p>出栈：<code>stack.pop()</code>       # 返回弹出的元素</p><p>判断非空：len(stack)!=0</p><h2 id="集合">集合</h2><p>集合是由不重复元素组成的无序容器。基本用法包括成员检测、消除重复元素。集合对象支持合集、交集、差集、对称差分等数学运算。</p><p>创建集合用花括号或 set()函数。注意，创建<strong>空集合</strong>只能用 <code>set()</code>，不能用 <code>&#123;&#125;</code>，<code>&#123;&#125;</code> 创建的是空字典。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">basket = &#123;&quot;abc&quot;,&quot;def&quot;,&quot;abc&quot;&#125;</span><br><span class="line">print(basket)              # &quot;abc&quot;,&quot;def&quot; 会自动去除重复元素</span><br><span class="line">a = set(&#x27;abracadabra&#x27;)</span><br><span class="line">b = set(&#x27;alacazam&#x27;)</span><br><span class="line">a                                 </span><br><span class="line">a - b                              # 在 a 中 但不在 b 中的元素</span><br><span class="line">a | b                              # 在 a 中或在 b 中的元素</span><br><span class="line">a &amp; b                              # 既在 a 中也在 b 中的元素</span><br><span class="line">a ^ b                              # 在 a 中或在 b 中，但不能 a b 都有。</span><br></pre></td></tr></table></figure><h2 id="字典">字典</h2><p>字典以 关键字 为索引，关键字通常是字符串或数字，也可以是其他任意不可变类型。只包含字符串、数字、元组的元组，也可以用作关键字，列表不能当关键字，因为列表可以用索引、切片、<code>append()</code> 、<code>extend()</code> 等方法修改。花括号 <code>&#123;&#125;</code> 用于创建空字典。另一种初始化字典的方式是，在花括号里输入逗号分隔的键值对，这也是字典的输出方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dic = &#123;&quot;jack&quot;:18,&quot;larry&quot;:22,&quot;mac&quot;:25&#125;        # 创建字典</span><br><span class="line">dic[&quot;jack&quot;] = 23.                            # 修改键所对应的值</span><br><span class="line">del dic[&#x27;mac&#x27;] # 删除元素</span><br><span class="line">list(dic) # 将字典的键作为列表返回</span><br><span class="line">sorted(dic) # 对键进行排序</span><br></pre></td></tr></table></figure><p>dict() 构造函数可以直接用键值对序列创建字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dict</span>([(<span class="string">&#x27;larry&#x27;</span>, <span class="number">1314</span>), (<span class="string">&#x27;sky&#x27;</span>, <span class="number">23</span>), (<span class="string">&#x27;jack&#x27;</span>, <span class="number">18</span>)]) <span class="comment"># &#123;&#x27;larry&#x27;: 1314, &#x27;sky&#x27;: 23, &#x27;jack&#x27;: 18&#125;</span></span><br><span class="line"><span class="built_in">dict</span>(mac=<span class="number">99</span>,windows=<span class="number">99</span>)      <span class="comment">#  &#123;&#x27;mac&#x27;: 99, &#x27;windows&#x27;: 99&#125;</span></span><br></pre></td></tr></table></figure><p>字典推导式可以用任意键值表达式创建字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;x: x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)&#125;</span><br><span class="line">&#123;<span class="number">2</span>: <span class="number">4</span>, <span class="number">4</span>: <span class="number">16</span>, <span class="number">6</span>: <span class="number">36</span>&#125;</span><br></pre></td></tr></table></figure><p>遍历遍历</p><p>用 <code>items()</code> 方法可同时取出键和对应的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dic=&#123;<span class="string">&quot;apple&quot;</span>:<span class="number">100</span>,<span class="string">&quot;windows&quot;</span>:<span class="number">24</span>&#125;</span><br><span class="line"><span class="keyword">for</span> k, v <span class="keyword">in</span> dic.items():</span><br><span class="line">     <span class="built_in">print</span>(k,v)</span><br></pre></td></tr></table></figure><p>在序列中循环时，用 enumerate()  函数可以同时取出位置索引和对应的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fruit=&#123;<span class="string">&quot;apple&quot;</span>:<span class="number">100</span>,<span class="string">&quot;banana&quot;</span>:<span class="number">26</span>&#125;</span><br><span class="line"><span class="keyword">for</span> i,v <span class="keyword">in</span> <span class="built_in">enumerate</span>(fruit):</span><br><span class="line"><span class="built_in">print</span>(i,v)</span><br></pre></td></tr></table></figure><h2 id="列表推导式">列表推导式</h2><p>使用 列表推导式子，可以方便地构造特定列表。</p><p>使用以下代码创建平方值列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">squares = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">squares.append(x**<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>注意，这段代码创建（或覆盖）变量 <code>x</code>，该变量在循环结束后仍然存在。下述方法可以无副作用地计算平方列表：</p><h3 id="map">map</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squares = <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>,<span class="built_in">range</span>(<span class="number">10</span>)))</span><br></pre></td></tr></table></figure><blockquote><p>map 第一个参数 function 以参数序列中的每一个元素调用 function 函数，返回包含每次 function 函数返回值的新列表。</p><p>map(function, iterable, …)，可以提供多个列表，函数的参数个数和列表个数相同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x: x ** <span class="number">2</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]))   <span class="comment"># 使用 lambda 匿名函数</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span>]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">map</span>(<span class="keyword">lambda</span> x, y: x + y, [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>], [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>])</span><br><span class="line">[<span class="number">3</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">19</span>]</span><br></pre></td></tr></table></figure><p>注：map 函数 Python 2.x 返回 列表，  Python 3.x 返回迭代器</p></blockquote><h3 id="表达式-for子句">表达式+for子句</h3><p>列表推导式的方括号内包含以下内容：一个表达式，后面为一个 <code>for</code> 子句，然后，是零个或多个 <code>for</code> 或 <code>if</code> 子句。结果是由表达式依据 <code>for</code> 和 <code>if</code> 子句求值计算而得出一个新列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(x, y) <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>] <span class="keyword">for</span> y <span class="keyword">in</span> [<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>] <span class="keyword">if</span> x != y  <span class="comment">#(x,y)表示元组，其值不可修改</span></span><br><span class="line">[(<span class="number">1</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">4</span>), (<span class="number">3</span>, <span class="number">1</span>), (<span class="number">3</span>, <span class="number">4</span>)]</span><br></pre></td></tr></table></figure><h2 id="嵌套的列表推导式">嵌套的列表推导式</h2><p>构造一个：3x4 矩阵</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">matrix = [</span><br><span class="line">     [1, 2, 3, 4],</span><br><span class="line">     [5, 6, 7, 8],</span><br><span class="line">     [9, 10, 11, 12],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>常规方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>transposed = []</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>):</span><br><span class="line"><span class="meta">... </span>    transposed.append([row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix])</span><br></pre></td></tr></table></figure><p>还可以使用列表推导式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[row[i] <span class="keyword">for</span> row <span class="keyword">in</span> matrix] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>)]</span><br></pre></td></tr></table></figure><h2 id="元素删除-del-语句">元素删除(<code>del</code> 语句)</h2><p>del 语句按索引，而不是值从列表中移除元素。与返回值的 pop() 方法不同， del 语句也可以从列表中移除切片，或清空整个列表（之前是将空列表赋值给切片）。 例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = [1,2,3,4,5]</span><br><span class="line">del a[0]       # 删除第一个元素</span><br><span class="line">del a[2:4]     # 删除 2号 和 3号 元素</span><br><span class="line">del a          # 删除整个变量</span><br></pre></td></tr></table></figure><h2 id="注意">注意</h2><p>对不同类型的对象来说，只要待比较的对象提供了合适的比较方法，就可以使用 <code>&lt;</code> 和 <code>&gt;</code> 进行比较。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++单例设计模式的两种实现</title>
      <link href="/2021/10/13/c-dan-li-she-ji-mo-shi-de-liang-chong-shi-xian/"/>
      <url>/2021/10/13/c-dan-li-she-ji-mo-shi-de-liang-chong-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1>单例设计模式的两种实现</h1><h2 id="单例模式的定义">单例模式的定义</h2><p>保证一个类仅有一个实例，并提供一个它的全局访问点，该实例被所有程序模块所共享。</p><p>那么就必须保证：</p><ul><li>该类不能被实例化</li><li>该类不能被复制。</li></ul><p>对于 C++，意味着：它的构造函数，拷贝构造函数和拷贝赋值运算符不能被公开调用。</p><span id="more"></span><p>单例模式通常有两种实现模式：</p><ul><li>懒汉式单例</li><li>饿汉式单例</li></ul><h2 id="懒汉式单例">懒汉式单例</h2><p>单例实例在第一次被使用时才进行初始化，这叫做延迟初始化。</p><h3 id="非线程安全实现">非线程安全实现</h3><p><strong>静态指针 + 用到时初始化</strong></p><p>版本 1：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!value_)</span><br><span class="line">    &#123;</span><br><span class="line">        value_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *value_;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>();</span><br><span class="line">    ~<span class="built_in">Singleton</span>();</span><br><span class="line">  <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton&amp;);</span><br><span class="line">Singleton&amp; <span class="keyword">operator</span>=(<span class="type">const</span> Singleton&amp;);</span><br><span class="line">    <span class="type">static</span> Singleton* value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化成员变量</span></span><br><span class="line">Singleton* Singleton::value_ = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>在单线程下可以正确，但在多线程下就可能出现问题。比如当A线程调用getInstance()，并进入 if 作用域内，在调用 new 之前，时间片用完了，就进入就绪队列，此时线程B也调用getInstance()，并成功执行 new 分配了对象。随后运行线程A，线程A 也调用了new 分配了对象。就不满足单例模式仅有一个实例的要求。</p><p>还有一个问题，可能造成内存泄漏，因为分配的动态内存没有主动释放。</p><p>针对第二个问题，可以改为以下版本：</p><p>版本3:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!value_)</span><br><span class="line">        &#123;</span><br><span class="line">            value_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Deletor</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~<span class="built_in">Deletor</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Singleton::getInstance != <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">delete</span> Singleton::value_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> Deletor deletor;</span><br><span class="line">    <span class="built_in">Singleton</span>();</span><br><span class="line">    ~<span class="built_in">Singleton</span>();</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;);</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;);</span><br><span class="line">    <span class="type">static</span> Singleton* value_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化成员变量</span></span><br><span class="line">Singleton *Singleton::value_ = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>版本 3可以解决 内存泄漏的问题。在类内定义了一个私有的 static 全局变量，因为程序在结束时析构全局变量。</p><h3 id="线程安全实现">线程安全实现</h3><p>还有多线程不安全问题：</p><p>方法1: 给临界区加锁</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">        <span class="keyword">if</span> (!value_)</span><br><span class="line">        &#123;</span><br><span class="line">            value_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>程序只是在初始化的时候需要加锁，初始化完之后就不需要锁了。使用双检测锁可以解决这个问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!value_)&#123;</span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (!value_)</span><br><span class="line">            &#123;</span><br><span class="line">                value_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>此时看似已经解决问题了，但还有一个隐含的问题：memory model。在某些内存模型中，或者由于编译器优化，或者运行时优化等原因，调用 getInstance()时虽然，value_ 不为 nullptr,但是还没有完全构造，此时调用的对象就是不完整的。出现问题的原因就是：<code>if(!value_)</code> 与 <code>value_ = new Singleton();</code>没有正确同步，在某种情况下，new 返回了地址给value_，但Singleton 还没有完全构造，当另一个线程调用时将不会进入if从而返回了不完全的实例对象给用户使用，造成了严重的错误。C++11引进了memory model，提供了Atomic实现内存的同步访问，即不同线程总是获取对象修改前或修改后的值，无法在对象修改期间获得该对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> atomic&lt;Singleton *&gt; value_;   </span><br></pre></td></tr></table></figure><p>将 value_ 定义为atomic&lt;Singleton *&gt;，此时它便具有原子属性。</p><p>完整代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton* <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!value_)&#123;</span><br><span class="line">            <span class="function">lock_guard&lt;mutex&gt; <span class="title">locker</span><span class="params">(mtx_)</span></span>;</span><br><span class="line">            <span class="keyword">if</span> (!value_)</span><br><span class="line">            &#123;</span><br><span class="line">                value_ = <span class="keyword">new</span> <span class="built_in">Singleton</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Deletor</span></span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~<span class="built_in">Deletor</span>()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Singleton::getInstance != <span class="literal">nullptr</span>)</span><br><span class="line">                <span class="keyword">delete</span> Singleton::value_;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="type">static</span> Deletor deletor;</span><br><span class="line">    <span class="built_in">Singleton</span>();</span><br><span class="line">    ~<span class="built_in">Singleton</span>();</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;);</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;);</span><br><span class="line">    <span class="type">static</span> atomic&lt;Singleton *&gt; value_;                   </span><br><span class="line">    <span class="type">static</span> std::mutex mtx_;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化成员变量</span></span><br><span class="line">atomic&lt;Singleton *&gt; Singleton::value_&#123;<span class="literal">nullptr</span>&#125;;</span><br></pre></td></tr></table></figure><h3 id="更优雅的方式">更优雅的方式</h3><p><strong>局部静态变量法</strong></p><p>C++11规定了local static在多线程条件下的初始化行为，要求编译器保证了内部静态变量的线程安全性。在C++11标准下，《Effective C++》提出了一种更优雅的单例模式实现，使用函数内的局部静态变量。只有当第一次访问<code>getInstance()</code>方法时才创建实例。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">static</span> Singleton value_;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>();</span><br><span class="line">    ~<span class="built_in">Singleton</span>();</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;);</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="饿汉式单例">饿汉式单例</h2><p>饿汉版（Eager Singleton）：指单例实例在程序运行时被立即执行初始化。</p><p><strong>直接定义静态对象</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton&amp; <span class="title">getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value_;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>();</span><br><span class="line">    ~<span class="built_in">Singleton</span>();</span><br><span class="line">    <span class="built_in">Singleton</span>(<span class="type">const</span> Singleton &amp;);</span><br><span class="line">    Singleton &amp;<span class="keyword">operator</span>=(<span class="type">const</span> Singleton &amp;);</span><br><span class="line">    <span class="type">static</span> Singleton value_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 main 函数之前创建，不存在线程安全问题。但是潜在问题在于no-local static对象（函数外的static对象）在不同编译单元中的初始化顺序是未定义的。也即，static Singleton value_;和static Singleton&amp; getInstance()二者的初始化顺序不确定，如果在 value_ 初始化完成之前调用 getInstance() 方法会返回一个未定义的实例。</p><p><strong>静态指针 + 类外初始化时new空间方式</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">Singleton</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Singleton *p;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> Singleton *<span class="title">initance</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> p;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Singleton *Singleton::p = <span class="keyword">new</span> Singleton;</span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><p><a href="https://zhuanlan.zhihu.com/p/37469260">https://zhuanlan.zhihu.com/p/37469260</a></p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单例模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和与二分查找的应用</title>
      <link href="/2021/10/03/qian-zhui-he-yu-er-fen-cha-zhao-de-ying-yong/"/>
      <url>/2021/10/03/qian-zhui-he-yu-er-fen-cha-zhao-de-ying-yong/</url>
      
        <content type="html"><![CDATA[<h1>前缀和与二分查找的应用</h1><p>题目链接：<a href="https://leetcode-cn.com/problems/maximize-the-confusion-of-an-exam/">考试的最大困扰度</a></p><p>给出一个只有’F’ 和 ‘T’ 的字符串，和一个整数 k，可以对字符串种的字符进行两种修改：1. 把 ‘T’ 变为 ‘F’ ，2. 把 ‘F’ 变为 ‘T’。最多能修改 k 次，求由相同字符组成的连续子串长度的最大值。</p><span id="more"></span><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;TTFF&quot;, k = 2</span><br><span class="line">可以变为 &quot;TTTT&quot;，返回 4</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;TFFT&quot;, k = 1</span><br><span class="line">可以变为&quot;FFFT&quot;，返回 3</span><br></pre></td></tr></table></figure><p>从该题可以学到：</p><ul><li>前缀和思想</li><li>二分查找思想</li></ul><h2 id="前缀和">前缀和</h2><p>前缀和是一种常用的预处理技术，可以在 O(1) 内进行查询。例如给出一个字符串 “TTFTTFTT”，任意给出一个范围，分别求该范围内 T 的个数和F的个数。通常情况下，需要 O(n) 来遍历计算。如果查询次数很大，可以在 O(n) 内获得前缀和，在之后的每次查询中，只需 O(1) 时间复杂度。</p><p>获取前缀和代码：字符串用 answerKey 表示，d 数组存储前缀和，大小为 字符串长度+1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> d[<span class="number">50005</span>];  </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; ++i)&#123;</span><br><span class="line">d[i<span class="number">+1</span>] = d[i] + (answerKey[i]==<span class="string">&#x27;T&#x27;</span>?<span class="number">1</span>:<span class="number">0</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>answerKey =“TTFTTFTT”</p><p>前缀和为 0 1 2 2 3 4 4 5 6</p><p>d[x]-d[0] 表示下标 0 到 x 范围内 T 的个数，用 w 表示，用该范围内字符总数减去 T 的个数，就是 F 的个数，即 x - (d[x]-d[0])，用 x-w 表示。</p><p>根据题意，给一个范围内，我们取 x 和 x-w 的最小值 minum， 如果 minum 大于 k，说明范围太大了，不能在 k 次内将子串修改为相同字符。如果 minum 小于等于 k，说明该范围完全可以在 k 次修改变成相同字符，在继续扩大范围，以相同方式判断。直到不能将范围扩大为止。</p><p>可以看到前缀和为递增数列，所有可能的范围如下，为了快速找到正确的右边界，很明显可以使用 二分查找。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_7E3EFB5C27F2-1.jpeg" alt="IMG_7E3EFB5C27F2-1" style="zoom:50%;" /><h2 id="二分查找">二分查找</h2><p>二分查找是一种快速的查找算法，它的时间复杂度为 O(lg n)。需要待查找数组有序。</p><p>由上图可知，所有可能的范围的右边界是递增的。我们可以根据中间位置判断正确答案在左边还是右边。</p><p>中间位置判断：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">binary</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=len; ++i)&#123;</span><br><span class="line"><span class="type">int</span> w = d[i] - d[i-x];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">min</span>(w,x-w)&lt;= k) <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">// w: T的个数   x-w: F 的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要以下的任何一种满足，右边界就在中间值的右边，否则在左边。</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_F8E2C06B01A3-1.jpeg" alt="IMG_F8E2C06B01A3-1"></p><p>二叉查找代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> l=<span class="number">1</span>,r=len;</span><br><span class="line"><span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line"><span class="type">int</span> mid=(l+r<span class="number">+1</span>)&gt;&gt;<span class="number">1</span>;     <span class="comment">// 防止死循环</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">judge</span>(mid)) l = mid;</span><br><span class="line"><span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="完整代码如下">完整代码如下</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> d[<span class="number">50005</span>];</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;=len; ++i)&#123;</span><br><span class="line">            <span class="type">int</span> w = d[i] - d[i-x];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">min</span>(w,x-w)&lt;=k) <span class="keyword">return</span> <span class="literal">true</span>;   <span class="comment">// w: T的个数   x-w: F 的个数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxConsecutiveAnswers</span><span class="params">(string answerKey, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        len = answerKey.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; ++i)&#123;</span><br><span class="line">            d[i<span class="number">+1</span>] = d[i] + (answerKey[i]==<span class="string">&#x27;T&#x27;</span>?<span class="number">1</span>:<span class="number">0</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> l=<span class="number">1</span>,r=len;</span><br><span class="line">        <span class="keyword">while</span>(l&lt;r)&#123;</span><br><span class="line">            <span class="type">int</span> mid=(l+r<span class="number">+1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">judge</span>(mid)) l = mid;</span><br><span class="line">            <span class="keyword">else</span> r = mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如有遗漏，欢迎指正。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀和 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态库和动态库制作</title>
      <link href="/2021/09/30/jing-tai-ku-he-dong-tai-ku-zhi-zuo/"/>
      <url>/2021/09/30/jing-tai-ku-he-dong-tai-ku-zhi-zuo/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是库">什么是库</h2><p>库文件是计算机上的一类文件，提供给使用者一些开箱即用的变量、函数或类。静态库和动态库，静态库和动态库的区别体现在程序的链接阶段：静态库在程序的链接阶段被复制到了程序中；动态库在链接阶段没有被复制到程序中，而是程序在运行时由系统动态加载到内存中供程序调用。</p><p>假设当前目录下有以下文件</p><p>├── main.c</p><p>├── tools.c</p><p>└── tools.h</p><span id="more"></span><p>tools.h  包含get_sum函数的声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> tools_h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tools_h</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">get_sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* tools_h */</span></span></span><br></pre></td></tr></table></figure><p>tools.c 包含get_sum函数的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">get_sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.c  需要使用到get_sum函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,get_sum(<span class="number">12</span>,<span class="number">12</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态库">静态库</h2><p>在程序的链接阶段被复制到了程序中，编译完后就不再需要引入的库了。</p><h3 id="命名规则">命名规则</h3><p>在Linux平台下：libxxx.a</p><p>​libxxx.a：库文件的名字</p><p>​lib:前缀（固定）</p><p>​xxx：库的名字，自己起</p><p>​.a：后缀（固定）</p><p>windows：libxxx.lib</p><h3 id="制作方法">制作方法</h3><p>tools.c</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tools.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> tools_h</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tools_h</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_sum</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* tools_h */</span></span></span><br></pre></td></tr></table></figure><p>上述源文件包含一个求和函数，现在我们想把它打包成一个库供其他程序使用。</p><ol><li><p>获得.o文件</p><p>使用-c参数，只生成汇编程序，不进行链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c tools.c</span><br></pre></td></tr></table></figure></li><li><p>将.o文件打包，使用ar工具(archive)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libtools.a tools.o</span><br></pre></td></tr></table></figure><p>r：将文件插入备存文件中，即libtools.a</p><p>c：create，创建备存文件</p><p>s：缩引</p></li></ol><h3 id="使用方法">使用方法</h3><p>此时文件结构：</p><p>├── libtools.a</p><p>├── main.c</p><p>├── tools.c</p><p>├── tools.h</p><p>└── tools.o</p><p>为了测试调用库中的文件，现在删除tools.c，tools.o，但不能删除tools.h，使用静态库来编译程序的时候需要用到，tools.h中保存了库文件中函数的定义。</p><p>现在目录结构：</p><p>├── libtools.a</p><p>├── main.c</p><p>└── tools.h</p><p>现在使用库文件libtools.a来编译main.c，需要指定-I(大i)，-l  -L参数</p><p>-I（大i，Include）:指定头文件路径</p><p>-l ：库的名字</p><p>-L：库文件的路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c -o app -I ./ -l tools -L ./</span></span><br></pre></td></tr></table></figure><h2 id="动态库">动态库</h2><h3 id="命名规则-2">命名规则</h3><p>Linux：<a href="http://libxxx.so">libxxx.so</a></p><p>​lib：前缀（固定）</p><p>​xxx：库的名字</p><p>​.so：后缀（固定）</p><p>​在Linux下是一个可执行文件</p><p>windows：libxxx.dll</p><h3 id="制作方法-2">制作方法</h3><p>假设此时目录结构：</p><p>├── main.c</p><p>├── tools.c</p><p>└── tools.h</p><p>内容和1、一致</p><ol><li><p>获得和位置无关的.o文件，需要添加 -fpic参数，在某些平台可能需要-fPIC</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c -fpic tools.c</span><br></pre></td></tr></table></figure><p>生成tools.o</p></li><li><p>获得动态库</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -shared tools.o -o libtools.so</span><br></pre></td></tr></table></figure></li></ol><p>现在动态库就制作好了，此时目录结构：</p><p>├── <strong><a href="http://libtools.so">libtools.so</a></strong></p><p>├── main.c</p><p>├── tools.c</p><p>├── tools.h</p><p>└── tools.o</p><h3 id="使用方法-2">使用方法</h3><ol><li><p>编译main.c</p><p>-I（大i，Include）:指定头文件路径</p><p>-l ：库的名字</p><p>-L：库文件的路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.c -o app -I ./ -l tools -L ./</span></span><br></pre></td></tr></table></figure></li><li><p>运行app</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./app</span></span><br><span class="line">./app: error while loading shared libraries: libtools.so: cannot open shared object file: No such file or directory</span><br></pre></td></tr></table></figure><p>此时报错了，原因是没有找到动态库，此时需要手动置顶动态库的地址。</p></li><li><p>ldd，该命令可以查看一个程序的依赖关系，即需要导入哪些动态库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd ./app</span></span><br><span class="line">linux-vdso.so.1 (0x00007ffdab47f000)</span><br><span class="line">libtools.so =&gt; not found</span><br><span class="line">libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fd4861ad000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007fd4867a0000)</span><br></pre></td></tr></table></figure><p>可以看到，<a href="http://xn--libtools-050px21t206a99cirkfxoyi0a.so">运行该程序需要libtools.so</a>，此时显示未找到。</p></li><li><p>指定动态库路径</p><p>假设动态库所在路径为/home/so</p><p><strong>临时指定</strong>，只在当前终端有效，关闭了或其他终端都不可用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/home/so</span></span><br></pre></td></tr></table></figure><p><strong>长期指定</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将上述命令写入用户的配置文件.bashrc，这样每次打开新的终端都会执行上面的代码</span></span><br><span class="line">vim ~/home/.bashrc</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在打开的文件最后写入 <span class="built_in">export</span> LD_LIBRARY_PATH=<span class="variable">$LD_LIBRARY_PATH</span>:/home/so</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存退出</span></span><br></pre></td></tr></table></figure></li><li><p>再次运行app</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./app</span></span><br><span class="line">24</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd app</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ldd ./app                           <span class="comment"># 查看app的依赖</span></span></span><br><span class="line">        linux-vdso.so.1 (0x00007fff4c1b5000)</span><br><span class="line">        libtools.so =&gt; /home/so/libtools.so (0x00007f470e7fd000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f470e40c000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f470ec01000)</span><br></pre></td></tr></table></figure></li></ol><h2 id="原理">原理</h2><ul><li><p>静态库：GCC进行链接时，将静态库中的代码打包到可执行程序中</p></li><li><p>动态库：GCC进行链接时，动态库的代码不会被打包到可执行程序中，只包含依赖</p></li><li><p>程序启动之后，动态库会被动态加载到内存中，通过ldd（list dynamic dependencies）命令检查动态库依赖关系。</p></li><li><p>如何定位共享库文件呢？</p><p>当系统加载可执行程序时，能够指导其所依赖的库的名字，但是还需要知道绝对路径，此时需要系统的动态载入器来获取动态库的绝对路径。</p><p>对于elf格式的可执行程序，有ld-linux.so来完成，它先后搜索DT_RPATH段，环境变量LD_LIBRARY_PATH，/etc/ld.so.cache文件列表，/lib/，/usr/lib目录找到库文件后将其载入内存。</p></li></ul><h2 id="区别">区别</h2><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-05-25%20%E4%B8%8B%E5%8D%884.04.43.png" alt="截屏2021-05-25 下午4.04.43" style="zoom:67%;" /><h3 id="静态库-2">静态库</h3><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-05-25%20%E4%B8%8B%E5%8D%884.05.23.png" alt="截屏2021-05-25 下午4.05.23" style="zoom:67%;" /><h4 id="优点">优点</h4><ul><li>静态库被打包到应用程序中加载速度快</li><li>发布程序无需提供静态库，移植方便</li></ul><h4 id="缺点">缺点</h4><ul><li><p>当多个程序需要使用用同一个库文件运行时，需要同时加载多个库文件，消耗系统资源，浪费内存。如下图所示：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-05-25%20%E4%B8%8B%E5%8D%884.09.42.png" alt="截屏2021-05-25 下午4.09.42" style="zoom:50%;" /></li><li><p>更新，部署，发布麻烦</p></li></ul><h3 id="动态库-2">动态库</h3><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-05-25%20%E4%B8%8B%E5%8D%884.13.16.png" alt="截屏2021-05-25 下午4.13.16" style="zoom:67%;" /><h4 id="优点-2">优点</h4><ul><li><p>可以实现进程间资源共享（共享库）</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-05-25%20%E4%B8%8B%E5%8D%884.15.58.png" alt="截屏2021-05-25 下午4.15.58" style="zoom: 67%;" /></li><li><p>更新，部署，发布简单</p></li><li><p>可以控制何时加载动态库</p></li></ul><h4 id="缺点-2">缺点</h4><p>加载速度比静态库慢</p><p>发布程序时，需要提供依赖的动态库</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 静态库 </tag>
            
            <tag> 动态库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ STL标准模版库总结</title>
      <link href="/2021/09/29/c-stl-biao-zhun-mo-ban-ku-zong-jie/"/>
      <url>/2021/09/29/c-stl-biao-zhun-mo-ban-ku-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="STL-的组成部分">STL 的组成部分</h2><p>模版是C++程序设计语言的一个重要特征，STL 正是基于这一特征，STL 具有强大的功能，同时兼具良好的可扩展性。</p><p>STL 分为 3 类：Algorithm（算法）、Container（容器）和Iterator（迭代器），容器和算法通过迭代器可以进行无缝地连接。</p><p>STL 由 6 部分组成：容器(Container)、算法（Algorithm）、 迭代器（Iterator）、仿函数（Function object）、适配器（Adaptor）、空间配制器（Allocator）。</p><span id="more"></span><p>（1）容器(Container)</p><p>是一种数据结构，使用<strong>模版类</strong>实现。分为序列容器：vector, list, ,forward_list, deque, array 和关联容器：map, set，及其它们的变种。</p><p>（2）算法（Algorithm）</p><p>用来操作容器中数据的<strong>模版函数</strong>：例如 sort 可以用来对支持随机访问的容器进行排序，例如：vector,array,deque 和普通数组。find 可以搜索容器内的元素，只要容器支持迭代器和容器元素支持 “==” 运算符。</p><p>（3）迭代器（Iterator）</p><p>提供了访问容器元素的方法，它的功能类似于指针，支持 ++，–，-&gt; , * 等运算符，它封装了指针，提供了比指针更强大的功能。迭代器也可以指那些定义了operator*()运算符以及类似于指针操作运算符的对象。</p><p>（4）仿函数（Function object）</p><p>定义了operator() 运算符的类或结构体。例如，以下函数就是仿函数，也叫函数对象。</p><pre><code>等于：equal_to&lt;T&gt;不等于：not_equal_to&lt;T&gt;大于：greater&lt;T&gt;大于等于：greater_equal&lt;T&gt;小于：less&lt;T&gt;小于等于：less_equal&lt;T&gt;</code></pre><p>（5）适配器（Adaptor）</p><p>封装了一些基本的容器，使之具备了某些特性的新容器，比如把deque封装一下变为一个具有stack功能的数据结构。得到的数据结构就叫适配器。STL 最常用的适配器是 stack, queue 和 priority_queue。适配器本质上还是容器，只不过大量使用已经写好的其它容器的代码，有必要的话可以添加其它代码。STL 使用的基础容器并不是固定的，可以根据实际情况选择。</p><table><thead><tr><th>容器适配器</th><th>基础容器筛选条件</th><th>默认使用的基础容器</th></tr></thead><tbody><tr><td>stack</td><td>需要支持的成员函数： empty() ，size()， back()， push_back()， pop_back()，满足条件的基础容器有 vector、deque、list。</td><td>deque</td></tr><tr><td>queue</td><td>需要支持的成员函数：empty()，size()，front()，back()，push_back()，pop_front()，满足条件的基础容器：deque, list</td><td>deque</td></tr><tr><td>priority_queue</td><td>需要支持的成员函数：empty()，size()，front()，push_back()，pop_back()，满足条件的基础容器：vector, deque</td><td>vector</td></tr></tbody></table><p>（6）空间配制器（Allocator）</p><p>为 STL 容器分配空间的系统，主要包括两部分：</p><ul><li><p>对象的创建与销毁；</p></li><li><p>内存的获取与释放。</p></li></ul><h2 id="STL-常用容器及其实现原理">STL 常用容器及其实现原理</h2><h3 id="顺序容器">顺序容器</h3><table><thead><tr><th>容器类型</th><th>实现原理</th><th>时间复杂度</th></tr></thead><tbody><tr><td>vector</td><td>动态数组，元素在内存中连续存放，在尾端增删元素具有较佳的性能。</td><td>随机存取：O(1)，插入：O(n)，删除：O(n)</td></tr><tr><td>deque</td><td>双向队列。所有适用于vector的操作都适用于deque，在两端增删元素具有较佳的性能。随机存取任何元素在常数时间内完成，仅次于vector，因为 deque底层是由数段内存组成，每一段的内存地址是连续的。</td><td>随机存取：O(1)，插入：O(n)，删除：O(n)</td></tr><tr><td>list</td><td>双向链表，元素在内存中不连续存放。</td><td>随机存取：O(n)，插入：O(1)，删除，O(1)</td></tr><tr><td>forward_list</td><td>单向链表，元素在内存中不连续存放。</td><td>随机存取：O(n)，插入：O(1)，删除，O(1)</td></tr></tbody></table><h3 id="关联容器">关联容器</h3><p>关联容器主要有：map，set</p><p>根据关键字是否可重复：multiset，multimap，上述容器的底层实现都是红黑树，插入，查找，删除的时间复杂度都是O(lgn)</p><p>元素是否有序又可细分为：unordered_set，unordered_map，上述容器的底层实现是哈希表，插入，查找，删除的平均时间复杂度是O(1)，最坏情况下时间复杂度是O(n)</p><table><thead><tr><th>容器类型</th><th>关键字是否可重复，元素是否有序</th></tr></thead><tbody><tr><td>map</td><td>不可重复，升序</td></tr><tr><td>set</td><td>不可重复，升序</td></tr><tr><td>multiset</td><td>可重复，升序</td></tr><tr><td>multimap</td><td>可重复，升序</td></tr><tr><td>unordered_set</td><td>不可重复，无序</td></tr><tr><td>unordered_map</td><td>不可重复，无序</td></tr><tr><td>unordered_multiset</td><td>可重复，无序</td></tr><tr><td>unordered_multimap</td><td>可重复，无序</td></tr></tbody></table><h3 id="容器适配器">容器适配器</h3><table><thead><tr><th>容器类型</th><th>底层实现</th><th>时间复杂度</th></tr></thead><tbody><tr><td>stack</td><td>栈，dqeue</td><td>入栈和弹栈：O(1)</td></tr><tr><td>queue</td><td>队列，dqeue</td><td>入队和出队：O(1)</td></tr><tr><td>priority_queue</td><td>优先队列，vector</td><td>入队：O(n)，出队：O(1)</td></tr></tbody></table><h2 id="STL-空间配置器">STL 空间配置器</h2><h3 id="三种内存分配方式">三种内存分配方式</h3><p>静态存储区分配：内存空间在编译阶段就已确定，如全局变量，静态变量等。</p><p>栈空间分配：程序运行期间，函数开始时自动在栈上预留足够的空间(栈帧)，函数结束后自动释放。如：局部变量。</p><p>堆空间分配：程序运行期间，使用 malloc 或 new 在堆空间为对象分配空间，使用 free 或 delete释放内存，这部分空间需要程序员手动管理内存，如果一个持续运行的程序分配了大量的堆内存，没有及时释放，就可能造成内存泄漏。</p><p>举个例子：Test 是一个类，Test test(); 和 Test *p = new Test; 对于前者，如果 test 位于函数内，那么它直接通过调用构造函数来构造对象。对于后者，则先使用 new 分配空间，然后调用构造函数。关于释放，前者是自动释放，后者需要使用 delete 来手动释放。</p><h3 id="STL-空间配置器-2">STL 空间配置器</h3><p>关于内存分配，STL 完全可以使用 new 或 malloc 来分配内存空间，但是 new 和 malloc 效率低还容易产生内存碎片。为了最大化提升效率，SGI STL采取了一定的措施，采用了更加高效复杂的空间分配策略。在SGI STL中，将对象的构造切分开来，分成空间配置和对象构造两部分。SGI STL 采用两级空间配置策略，一级主要考虑大块内存空间的分配，使用malloc 和 free 实现。二级主要考虑小块内存的分配，这样就大大减少了 malloc 的次数，提高了运行效率。使用 malloc 申请到的一大块内存构成一个内存池，使用链表free_list来维护。free_list通过union结构实现，空闲的内存块互相挂接在一块，内存块一旦被使用，则被从链表中剔除，易于维护。</p><p>内存配置操作: 通过allocate()实现<br>内存释放操作: 通过deallocate()实现<br>对象构造操作: 通过construct()实现<br>对象释放操作: 通过destroy()实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line"><span class="type">int</span> num;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Test</span>(<span class="type">int</span> _num):<span class="built_in">num</span>(_num)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Test is construct,num = &quot;</span> &lt;&lt;num&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">Test</span>()&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Test is destroy&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    allocator&lt;Test&gt; alloc;</span><br><span class="line">    Test *p = alloc.<span class="built_in">allocate</span>(<span class="number">5</span>);    <span class="comment">// 分配存放 5 个T对象的内存空间，不调用构造函数</span></span><br><span class="line">    alloc.<span class="built_in">construct</span>(p,<span class="number">12</span>);          <span class="comment">// 构造第一个对象</span></span><br><span class="line">    alloc.<span class="built_in">construct</span>(p<span class="number">+1</span>, <span class="number">12</span>);       <span class="comment">// 构造第二个对象</span></span><br><span class="line"></span><br><span class="line">    alloc.<span class="built_in">destroy</span>(p);               <span class="comment">// 调用第一个对象的析构函数(不释放内存)</span></span><br><span class="line">    alloc.<span class="built_in">destroy</span>(p + <span class="number">1</span>);           <span class="comment">// 调用第二个对象的析构函数(不释放内存)</span></span><br><span class="line"></span><br><span class="line">    alloc.<span class="built_in">deallocate</span>(p,<span class="number">5</span>);          <span class="comment">// 释放占用 5 个Test对象大小的内存空间</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">g++ allocator.cpp -o allocator</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./allocator</span> </span><br><span class="line">Test is construct,num = 12</span><br><span class="line">Test is construct,num = 12</span><br><span class="line">Test is destroy</span><br><span class="line">Test is destroy</span><br></pre></td></tr></table></figure><h2 id="迭代器">迭代器</h2><h3 id="什么是迭代器">什么是迭代器</h3><p>迭代器是类模版，本质上封装了原生指针，是指针概念的一种提升，提供了比指针更高级的行为。重载了指针的一些操作符，例如：++, --, *, -&gt;。迭代器返回对象的引用。</p><h3 id="迭代器的作用">迭代器的作用</h3><p>用于访问顺序容器和关联容器内的元素</p><p>通过非const迭代器还可以修改其指向的元素</p><h3 id="迭代器产生原因">迭代器产生原因</h3><p>Iterator类的访问方式就是把不同容器的访问逻辑抽象出来，使得不用暴露集合内部的结构而达到操作容器元素的目的。</p><h3 id="迭代器失效问题">迭代器失效问题</h3><p>迭代器失效主要原因为：erase和insert</p><p>对于顺序容器vector，deque来说，使用erase后，后边的每个元素的迭代器都会失效，后边每个元素都往前移动一位，erase返回下一个有效的迭代器。在中间插入元素时，会使插入位置之后的元素的迭代器失效，不能使用迭代器在循环中插入。</p><p>对于关联容器map, set及其变种，因为底层使用红黑树，使用erase 删除一个元素后不会改变其它元素的迭代器，在删除之前记录下一个元素的迭代器即可。 插入不会使得任何元素的迭代器失效。</p><p>对于list来说，它使用了不连续分配的内存，并且它的 erase 方法也会返回下一个有效的迭代器，因此上面两种方法都可以使用。插入不会改变其它元素的迭代器。</p><h2 id="resize-和-reserve-区别">resize 和 reserve 区别</h2><p>先明白两个概念：capacity 和 size</p><p>某些容器为了支持动态扩充，在初始化时会申请一段连续的内存，这个容量用capacity表示，表示该容器此时最大能容纳的对象个数，此时是无法通过下标访问的，因为还没有创建对象。创建完对象后，才可以用下标访问，实际创建对象的数量用 size 表示。</p><h3 id="区别">区别</h3><p>resize 即修改了capacity 的大小，也修改了 size 的大小。带两个参数，一个表示容器的大小，一个表示构造函数参数(如果有的话)。</p><p>reserve 只修改capacity的大小，相当于给容器扩容。带一个参数，表示容器的大小。</p><h3 id="共同点">共同点</h3><p>两者都保证了 vector 的空间最少达到它的参数所指定的大小。例如给定参数 size=10，则大于等于10的下标都无效。</p><h2 id="STL-容器动态链接可以产生的问题">STL 容器动态链接可以产生的问题</h2><h3 id="可能产生的问题">可能产生的问题</h3><p>容器是一种动态分配内存空间的一个变量。在一般的程序函数里，参数传递容器指针都是可以正常运行的，而在动态链接库函数内部使用容器也是没有问题的，但是给动态库函数传递容器的对象本身，则会出现内存堆栈破坏的问题。</p><h3 id="产生问题的原因">产生问题的原因</h3><p>容器和动态链接库相互支持不够好，动态链接库函数中使用容器时，参数中只能传递容器的引用，并且要保证容器的大小不能超出初始大小，否则导致容器自动重新分配，就会出现内存堆栈破坏问题。</p><h2 id="push-back-和-emplace-back-的区别">push_back 和 emplace_back 的区别</h2><p>使用push_back()插入元素， 需要先构造临时对象，再将这个对象拷贝到容器的末尾，而emplace_back()则直接在容器的末尾构造对象，这样就省去了拷贝的过程。</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STL </tag>
            
            <tag> 顺序容器 </tag>
            
            <tag> 关联容器 </tag>
            
            <tag> 迭代器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并查集原理与实现</title>
      <link href="/2021/09/28/bing-cha-ji-yuan-li-yu-shi-xian/"/>
      <url>/2021/09/28/bing-cha-ji-yuan-li-yu-shi-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="并查集原理">并查集原理</h2><p>（1）并查集用于解决以下问题</p><p>用于处理没有重复元素的集合(不交集)的查询和合并。可以快速判断一个元素是否在一个集合中，或者两个元素是否属于同一个集合。</p><p>（2）并查集支持以下操作：</p><span id="more"></span><ul><li>查询：查询某个元素属于哪个集合，通常是返回集合内的一个“代表元素”。这个操作是为了判断两个元素是否在同一个集合之中。</li><li>合并：将两个集合合并为一个。</li><li>添加：添加一个新集合，其中有一个新元素。添加操作不如查询和合并操作重要，常常被忽略。</li></ul><p>（3）并查集使用数组实现</p><p>初始时并查集由一系列孤立的元素组成，如图所示：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_448B9F5BE985-1.jpeg" alt="IMG_448B9F5BE985-1" style="zoom: 67%;" /><p>例如给出以下集合：1，3，5，7，8，用并查集表示如下：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_85A1D5D1B10C-1.jpeg" alt="IMG_85A1D5D1B10C-1" style="zoom: 50%;" /><p>1下标对应 3，3下标对应5，5下标对应7，7下标对应8，8 对应8，这样该集合的代表元素是 8，下面用 8 来表示这个集合。1，3，5，7，8就用并查集表示出来了。</p><ul><li><p>通过使用并查集，我们可以判断某个元素是否属于 8 这个集合，例如 5 这个元素，5 下标对应 7，7 下标对应 8，8 对应 8（结束）这样就知道 5 属于 8 这个集合。</p></li><li><p>使用并查集也可以快速判断某些元素是否属于同一个集合，例如 3，5，下标 3 对应 5，下标 5 对应 7，下标 7 对应 8，下标 8 对应 8（结束），再来看 5，下标 5 对应 7，下标 7 对应 8，下标 8 对应 8（结束）。使用同样的查找方式，我们都找到 3 和 5 都能对应8，说明 3 和 5 都属于同一个集合。</p></li></ul><p>并查集是一种树形数据结构，上述讨论的集合用树来表示如下：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_90DC33D16B62-1.jpeg" alt="IMG_90DC33D16B62-1" style="zoom:33%;" /><p>每个节点只有一个孩子节点，此时这棵树构成了一个单链表，查询效率也是最低的。查询元素 1 时需要查询 5 次。为了提高查询效率，需要对并查集进行路径压缩，如下图所示：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_55D4B8809961-1.jpeg" alt="IMG_55D4B8809961-1" style="zoom:50%;" /><p>此时为查询效率是最高的，查询任何一个元素都能在 2 次比较后结束。</p><h2 id="并查集的常用操作">并查集的常用操作</h2><h3 id="初始化">初始化</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">fa</span>(n<span class="number">+1</span>);</span><br></pre></td></tr></table></figure><p>使用fa 来表示并查集，它的元素范围从 1 到 n。刚开始，fa 只是一系列孤立的元素值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">fa[i]=i;</span><br></pre></td></tr></table></figure><h3 id="查找">查找</h3><p>以下用 c++ 语言实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(fa[x]==x)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">find</span>(fa,fa[x]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并">合并</h3><p>两集合合并是指将其中一个集合的代表元素指向另一个集合的代表元素，反之也可以。如下图所示：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_3351D6460AE2-1.jpeg" alt="IMG_3351D6460AE2-1" style="zoom:50%;" /><p>如上图所示，合并有两种方案，很面向左边的方案树的深度更低，查询更高效，右边的方案不好，因为它的深度更高，查询效率更低。</p><p>为了总是按照第一种方案来合并，我们就必须采用按秩合并（启发式合并）。使用一个数组来记录集合的深度，让深度大的集合合并深度小的集合。具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt;<span class="built_in">size</span>(n<span class="number">+1</span>,<span class="number">1</span>);       <span class="comment">// 初始化所有元素的深度为 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">unite</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> xx = <span class="built_in">find</span>(x);</span><br><span class="line">    <span class="type">int</span> yy = <span class="built_in">find</span>(y);</span><br><span class="line">    <span class="keyword">if</span>(xx==yy)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 保证小的合并到大的</span></span><br><span class="line">    <span class="keyword">if</span>(size[xx]&gt;size[yy])&#123;</span><br><span class="line">        fa[yy] = xx;</span><br><span class="line">        size[xx] += size[yy];     <span class="comment">// 跟踪深度大小</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        fa[xx] = yy;</span><br><span class="line">        size[yy] += size[xx];    </span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度">时间复杂度</h3><p>使用路径压缩和启发式合并后，并查集的每个操作都能在 O(α(n))，n 表示元素个数，α 表示阿克曼反函数，其增长极其缓慢，其单次操作的平均运行时间可以认为是一个很小的常数，对于一般可能出现的数值n，α(n)均小于5。</p><p>阿克曼函数定义如下：n 为元素个数， m 为运算次数。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-09-28%20%E4%B8%8B%E5%8D%884.25.35.png" alt="截屏2021-09-28 下午4.25.35" style="zoom:50%;" /><p>如果只使用启发式合并，而不使用路径压缩，时间复杂度为 O(m log n)，</p><p>如果只使用路径压缩，而不使用启发式合并，时间复杂度为 O(m α(m,n))</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-09-28%20%E4%B8%8B%E5%8D%884.24.39.png" alt="截屏2021-09-28 下午4.24.39" style="zoom:50%;" /><p>有时将 α(m,n) 写作 α(n)，将 m 看作一个常数。</p><h3 id="空间复杂度">空间复杂度</h3><p>取决于元素个数，即 O(n)</p><h2 id="推荐题目">推荐题目</h2><p><a href="https://www.luogu.com.cn/problem/P1551">亲戚 - 洛谷</a></p><h2 id="参考">参考</h2><p><a href="https://oi-wiki.org/ds/dsu/#_5">https://oi-wiki.org/ds/dsu/#_5</a></p><p><a href="https://zh.wikipedia.org/wiki/%E9%98%BF%E5%85%8B%E6%9B%BC%E5%87%BD%E6%95%B8#%E5%8F%8D%E5%87%BD%E6%95%B8">阿克曼函数 - 维基百科，自由的百科全书</a></p><p><a href="https://zh.wikipedia.org/wiki/%E5%B9%B6%E6%9F%A5%E9%9B%86#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6">并查集 - 维基百科，自由的百科全书</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
            <tag> 压缩路径 </tag>
            
            <tag> 启发式合并 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B树 B+树 B*树区别</title>
      <link href="/2021/09/27/b-shu-b-shu-b-shu-qu-bie/"/>
      <url>/2021/09/27/b-shu-b-shu-b-shu-qu-bie/</url>
      
        <content type="html"><![CDATA[<h2 id="B树的性质">B树的性质</h2><p>（1）B树的每个节点 x 都具有以下属性：</p><ul><li><p>x.n 存储在节点 x 中的关键字个数。</p></li><li><p>x.n 个关键字本身 x.key<sub>0</sub>, x.key<sub>1</sub>,…, x.key<sub>n-1</sub>，以升序排列，注编程语言数组下标从 0 开始。</p></li><li><p>x.leaf 布尔值，表示节点 x 是否是叶节点。</p></li></ul><span id="more"></span><p>（2）B树的每个内部节点具有以下属性：</p><ul><li>包含 x.n+1 个指向其孩子的指针 x.c<sub>0</sub>，x.c<sub>1</sub>，…，x.c<sub>n</sub>，叶节点没有孩子节点，它们的 c<sub>i</sub> 属性值未定义。</li></ul><p>（3）关键字 x.key<sub>i</sub>对子树节点中的关键字进行分割，如果 k<sub>i</sub>为任意一个存储在以 x.c<sub>i</sub>为根的子树中的关键字，那么：k<sub>1</sub>&lt;=x.key<sub>1</sub>&lt;=k<sub>2</sub>&lt;=…&lt;=x.key<sub>n</sub>&lt;=k<sub>x.n+1</sub>，如下图所示：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_C23F70EEC19E-1.jpeg" alt="IMG_C23F70EEC19E-1" style="zoom:50%;" /><p>（4）每个叶节点具有相同的深度，即树的高度 h</p><p>（5）每个节点所包含的关键字个数有上界和下界，用一个被称为B树的最小度数的固定整数 t&gt;=2 来表示这些界：</p><ul><li><p>下界：除了根节点以外的每个节点必须至少有 t-1 个关键字。除了根节点和叶子节点以外的每个节点至少有 t 个孩子。如果树非空，根节点至少有 1 个关键字。</p></li><li><p>上界：每个节点至多可包含 2t-1 个关键字，一个内部节点(非叶子节点)至多可有 2t 个孩子。当一个节点有 2t-1 个关键字时，称该节点为满的。</p></li><li><p>t 值越大，B树的高度就越小。</p></li></ul><p>查找时间复杂度</p><p>每个节点的遍历所有关键字值时间为 O(t)，搜索路径构成B树的一条简单路径，所以总的时间复杂度为 O(t$\log_t{n}$)</p><p>插入时间复杂度</p><p>插入用到一个辅助过程，insertNonFull ：向非满的节点中插入关键字。insert 需要访问的节点数为 O(h)，每次调用 insertNonFull 的时间复杂度为 O(1)，所以总的时间复杂度为 O(t$\log_t{n}$​)</p><p>删除时间复杂度</p><p>需要访问节点个数 O(h)，总的时间复杂度为 O(th) ==  O(t$\log_t{n}$)</p><h2 id="B-树的性质">B+树的性质</h2><p>B+ 树由B树改进而来，具有以下不同于 B树的性质：</p><p>（1）B 树的每个节点都包含数据和索引，B+树只在叶节点中存储数据，内部节点只存储索引。如下图所示：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-09-27%20%E4%B8%8B%E5%8D%889.26.23.png" alt="截屏2021-09-27 下午9.26.23" style="zoom: 33%;" /><p>注：内部节点 3 和 5 并不是关键字，它用来界定关键字的范围。</p><p>（2）B+树的叶子节点按升序排序，所有叶子节点构成一个链表。</p><p>B+树具有以下优点：</p><ul><li>单一节点存储的元素更多，使得查询的IO次数更少，平衡操作不经常发生，而且效率增加了，适合做为数据库MySQL的底层数据结构。</li><li>所有关键字都位于叶节点，查询更稳定，因为内存地址是连续的，用树的遍历去做范围查找，会不断在树中进行跳跃，即不断在内存中进行跳跃，会造成性能损失。</li><li>在查询大小区间的数据时候更方便，数据紧密性很高，缓存的命中率也会比B树高。</li><li>所有叶子节点构成一个链表，数据遍历更快。</li></ul><h2 id="B-树的性质-2">B*树的性质</h2><p>B*树是B+树的变种。具有以下不同于 B+树的性质。</p><ul><li><p>B*树，除根节点以外的内部节点，关键字个数至少为 3/2满，即 (2t-1)*2/3，向上取整。</p></li><li><p>所</p></li><li><p>而B*树节点满时会检查兄弟节点是否满（因为每个节点都有指向兄弟的指针），如果兄弟节点未满则向兄弟节点转移关键字，如果兄弟节点已满，则从当前节点和兄弟节点各拿出1/3的关键字创建一个新的节点出来。</p></li></ul><h2 id="参考">参考</h2><p><a href="https://segmentfault.com/a/1190000020416577">面试官问你B树和B+树，就把这篇文章丢给他 - SegmentFault 思否</a></p><p><a href="https://zhuanlan.zhihu.com/p/27700617">平衡二叉树、B树、B+树、B*树 理解其中一种你就都明白了 - 知乎</a></p><p><a href="https://zh.wikipedia.org/wiki/B%2B%E6%A0%91">B+树 - 维基百科，自由的百科全书</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> B树 </tag>
            
            <tag> B+树 </tag>
            
            <tag> B*树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B树原理与实现</title>
      <link href="/2021/09/27/b-shu-yuan-li-yu-shi-xian/"/>
      <url>/2021/09/27/b-shu-yuan-li-yu-shi-xian/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>B树是为磁盘等慢速IO设备设计的一种平衡搜索树，B树类似于红黑树，但它在降低I/O操作数方面要更好一些，许多数据库使用 B树或B树的变种来存储信息。</p><p>B 树与红黑树的不同之处在于 B树的节点可以有很多孩子，从数个到数千个。含有 n 个节点的B树的高度为 O(ln n)，一棵B树的严格高度可能比一棵红黑树的高度要小许多，因为它的分支因子，即表示高度的对数的底数可以非常大。因此我们可以使用 B树在 O(lg n) 内完成一些动态集合操作。</p><span id="more"></span><h2 id="磁盘结构">磁盘结构</h2><p>一个磁盘的典型结构如下：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_114F612089BE-1.jpeg" alt="IMG_114F612089BE-1" style="zoom:50%;" /><p>磁盘是一种辅存，一个计算机系统的主存使用硅存储芯片组成，这种存储技术每位的存储代价一般比磁存储技术高不只一个数量级。虽然固态硬盘正在越来越普及，但是磁盘具有的容量大，价格实惠等特点，还依然被广泛使用。一个典型的磁盘由以下部分组成，盘片，磁道，读/写头，主轴和磁臂组成。一个盘片由多个磁道组成，形状上看类似于同心圆。一个磁道由多个扇区组成，扇区是磁盘的最小读写单位，即每次可以读写一个或多个扇区。大多数磁盘的扇区大小为 512字节，即每次读取或写入 512字节。</p><p>那么磁盘如何读取数据？主轴带动盘片旋转，这样 读/写磁头 就能按位读/写扇区的数据。旋转磁臂就可以切换到不同的磁道，这个过程叫做寻道。磁盘之所以慢就是因为它在读/写数据的时候涉及到机械运动，分别是盘片旋转和磁臂移动。一个盘片旋转一周的时间要比硅存储的常见存取时间高出 5 个数量级。为了摊还机械运动所花费的等待时间，磁盘会一次存取多个数据线而不是一个。信息被分为一系列相等大小的在柱面内连续出现的页面(page)，一页的长度可能为 2<sup>11</sup>到2<sup>14</sup>。</p><h2 id="B树介绍">B树介绍</h2><p>一个典型的 B树应用所要处理的数据量非常大，以至于所有数据无法一次性装入主存。B树算法所需读或写的页数无法一次装入内存，B树算法将所需的页面从磁盘复制到主存，然后将修改过的页面写会磁盘。主存的大小并不限制被处理的 B树的大小。</p><p>大多数系统中，一个B树算法的运行时间主要由它所执行的 disk-read() 和 dis-write() 操作的次数决定，我们希望这些操作能读或写尽可能多的信息，一个B树节点通常和一个完整磁盘页一样大，并且比盘页的大小限制了一个 B树节点可以含有的孩子的个数。</p><p>对存储在磁盘的一棵大的B树，通常看到分支因子在 50到 2000之间，具体取决于一个关键字相对于一页的大小。一个大的分支因子可以大大地降低树的高度以及查找任何一个关键字所需的存取次数。下图所示一棵分支因子为 1001，高度为 2 的B树，它可以存储超过 10 亿个<code>(1001*1001-1)*1000</code>关键字。由于根节点可以持久地保存在主存中，这棵树中查找某个关键字至多只需两次磁盘存取。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_75D52E22A84C-1.jpeg" alt="IMG_75D52E22A84C-1" style="zoom:50%;" /><p>B树的每个节点一般在磁盘中分配空间，以下为了简化分析，在内存中分配节点，这样就可以省略在磁盘中分配节点的过程，以及必要的读写磁盘操作：disk-read() 和 dis-write() 过程。</p><h2 id="B树的定义">B树的定义</h2><p>一棵B树具有以下性质：</p><ol><li><p>（1）B树的每个节点 x 都具有以下属性：</p><ul><li><p>x.n 存储在节点 x 中的关键字个数。</p></li><li><p>x.n 个关键字本身 x.key<sub>0</sub>, x.key<sub>1</sub>,…, x.key<sub>n-1</sub>，以升序排列，注编程语言数组下标从 0 开始。</p></li><li><p>x.leaf 布尔值，表示节点 x 是否是叶节点。</p></li></ul><p>（2）B树的每个内部节点具有以下属性：</p><ul><li>包含 x.n+1 个指向其孩子的指针 x.c<sub>0</sub>，x.c<sub>1</sub>，…，x.c<sub>n</sub>，叶节点没有孩子节点，它们的 c<sub>i</sub> 属性值未定义。</li></ul><p>（3）关键字 x.key<sub>i</sub>对子树节点中的关键字进行分割，如果 k<sub>i</sub>为任意一个存储在以 x.c<sub>i</sub>为根的子树中的关键字，那么：k<sub>1</sub>&lt;=x.key<sub>1</sub>&lt;=k<sub>2</sub>&lt;=…&lt;=x.key<sub>n</sub>&lt;=k<sub>x.n+1</sub>，如下图所示：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_C23F70EEC19E-1.jpeg" alt="IMG_C23F70EEC19E-1" style="zoom:50%;" /><p>（4）每个叶节点具有相同的深度，即树的高度 h</p><p>（5）每个节点所包含的关键字个数有上界和下界，用一个被称为B树的最小度数的固定整数 t&gt;=2 来表示这些界：</p><ul><li><p>下界：除了根节点以外的每个节点必须至少有 t-1 个关键字。除了根节点和叶子节点以外的每个节点至少有 t 个孩子。如果树非空，根节点至少有 1 个关键字。</p></li><li><p>上界：每个节点至多可包含 2t-1 个关键字，一个内部节点(非叶子节点)至多可有 2t 个孩子。当一个节点有 2t-1 个关键字时，称该节点为满的。</p></li><li><p>t 值越大，B树的高度就越小。</p></li></ul></li></ol><p>t == 2 时的B树是最简单的。每个内部节点有2个，3个或则4个孩子，即一棵 2-3-4 树。实际上，t的值越大，B树的高度越小。</p><h2 id="B树的高度">B树的高度</h2><p>如果 n&gt;=1，那么对任意一棵包含 n 个关键字，高度为h，最小度数 t &gt;= 2 的B树T，有 h&lt;=  $\log_t{(n+1)/2}$​</p><p>在一棵树中检查任意一个节点都需要一次磁盘访问，所以B树避免了大量的磁盘访问。</p><h2 id="节点定义">节点定义</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;                                   <span class="comment">// 关键字个数</span></span><br><span class="line">    <span class="type">int</span> t;                                   <span class="comment">// 最小度</span></span><br><span class="line">    <span class="type">int</span>* key;                                <span class="comment">// 关键字</span></span><br><span class="line">    <span class="type">bool</span> leaf;                               <span class="comment">// 是否是叶子</span></span><br><span class="line">    TreeNode** child;                        <span class="comment">// 孩子指针</span></span><br><span class="line">    <span class="built_in">TreeNode</span>():<span class="built_in">leaf</span>(<span class="literal">true</span>), <span class="built_in">n</span>(<span class="number">0</span>) &#123;&#125;           <span class="comment">// 默认情况下，为叶子</span></span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> <span class="type">_t</span>, <span class="type">bool</span> _leaf):<span class="built_in">t</span>(<span class="type">_t</span>),<span class="built_in">leaf</span>(_leaf)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Btree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> t;</span><br><span class="line">    TreeNode *root;                                        <span class="comment">// 根节点</span></span><br><span class="line">    <span class="built_in">Btree</span>(<span class="type">int</span> t);                                          <span class="comment">// 无参构造函数</span></span><br><span class="line">    <span class="built_in">Btree</span>(<span class="type">int</span> <span class="type">_t</span>, <span class="type">bool</span> _leaf);                             <span class="comment">// 构造 B 树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">splitChild</span><span class="params">(TreeNode *x, <span class="type">int</span> i)</span></span>;</span><br><span class="line">    <span class="function">pair&lt;TreeNode *, <span class="type">int</span>&gt; <span class="title">search</span><span class="params">(TreeNode *x, <span class="type">int</span> k)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> key)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insertNonfull</span><span class="params">(TreeNode *x, <span class="type">int</span> k)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="B树上的基本操作">B树上的基本操作</h2><h3 id="搜索B树">搜索B树</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">pair&lt;TreeNode *, <span class="type">int</span>&gt;</span></span><br><span class="line"><span class="function"><span class="title">Btree::search</span><span class="params">(TreeNode *x, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;x-&gt;n &amp;&amp; k&gt;x-&gt;key[i])</span><br><span class="line">        ++i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(i&lt;x-&gt;n &amp;&amp; k==x-&gt;key[i])</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_pair</span>(x, i);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(x-&gt;leaf) </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">make_pair</span>(<span class="literal">nullptr</span>,i);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(x-&gt;child[i],k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度</p><p>它的搜索过程遇到的节点构成了一条从树根向下的简单路径。B树需要访问的节点个数为 O(h) =  O($\log_t{n}$)，h 为 B树的高度，n 为B树所含关键字的个数。由于 x.n &lt;= 2t，while 循环在每个节点所花费的时间为 O(t)，总的 cpu 时间为 O(th) = O(t$\log_t{n}$​)。</p><h3 id="创建一棵空的B树">创建一棵空的B树</h3><p>使用构造函数创建B树</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Btree::<span class="built_in">Btree</span>(<span class="type">int</span> <span class="type">_t</span>,<span class="type">bool</span> _leaf)&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;t = <span class="type">_t</span>;</span><br><span class="line">    root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(_leaf); </span><br><span class="line">    root-&gt;key = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">2</span>*t<span class="number">-1</span>];</span><br><span class="line">    root-&gt;child = <span class="keyword">new</span> TreeNode*[<span class="number">2</span>*t];</span><br><span class="line">    root-&gt;n = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="插入B树">插入B树</h3><p>我们将关键字插入一个已经存在的叶节点上，由于不能插入一个满的叶节点，需要引入一个操作，将一个满的节点y(2t-1个关键字)按其中间关键字 y.key<sub>t</sub>分裂为两个各含 t-1 个关键字的节点。中间关键字被提升到y的父节点，以标识两棵树的划分点。如果 y 的父节点也是满的，就必须在插入新的关键字之前将其分裂，最终满节点的分裂会沿着树向上传播。</p><h4 id="插入">插入</h4><p>判断根节点是否满，如果非满则调用insertNonfull，如果满了则需要调用splitChild将根节点分裂为两个，创建新的根节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">Btree::insert</span><span class="params">(<span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    TreeNode *r = root;</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;n == <span class="number">2</span>*t<span class="number">-1</span>)&#123;</span><br><span class="line">        TreeNode *s = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">        root = s;</span><br><span class="line">        s-&gt;leaf = <span class="literal">false</span>;</span><br><span class="line">        s-&gt;n = <span class="number">0</span>;</span><br><span class="line">        s-&gt;child[<span class="number">0</span>] = r;</span><br><span class="line">        <span class="built_in">splitChild</span>(s,<span class="number">0</span>);</span><br><span class="line">        <span class="built_in">insertNonfull</span>(s,key);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">insertNonfull</span>(r,key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="分裂B树中的节点">分裂B树中的节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Btree::splitChild</span><span class="params">(TreeNode *x,<span class="type">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 需要在 x 中 下标为 index 的子节点插入，但它已经满了，需要将其分裂 </span></span><br><span class="line">    TreeNode *z = <span class="keyword">new</span> <span class="built_in">TreeNode</span>();</span><br><span class="line">    TreeNode *y = x-&gt;child[index];</span><br><span class="line">    z-&gt;leaf = y-&gt;leaf;</span><br><span class="line">    z-&gt;n = t<span class="number">-1</span>;                    </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;t<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">        x-&gt;key[i] = y-&gt;key[i+t];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!y-&gt;leaf)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;t; ++i)&#123;</span><br><span class="line">            z-&gt;child[i] = y-&gt;child[i+t];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    y-&gt;n = t<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x-&gt;n; i&gt;index; --i)&#123;</span><br><span class="line">        x-&gt;child[i<span class="number">+1</span>] = x-&gt;child[i];</span><br><span class="line">    &#125;</span><br><span class="line">    x-&gt;child[index + <span class="number">1</span>] = z;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=x-&gt;n; i&gt;=index; --i)&#123;</span><br><span class="line">        x-&gt;key[i<span class="number">+1</span>] = x-&gt;key[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    x-&gt;key[index] = y-&gt;key[t];</span><br><span class="line">    x-&gt;n = x-&gt;n<span class="number">+1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="插入非满节点">插入非满节点</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">Btree::insertNonfull</span><span class="params">(TreeNode *x, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = x-&gt;n;</span><br><span class="line">    <span class="keyword">if</span>(x-&gt;leaf)&#123;</span><br><span class="line">        <span class="comment">// 如果当前节点为叶子节点，则之间插入</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; k&lt;x-&gt;key[i])&#123;</span><br><span class="line">            x-&gt;key[i<span class="number">+1</span>] = x-&gt;key[i];</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        x-&gt;key[i<span class="number">+1</span>] = k;</span><br><span class="line">        x-&gt;n = x-&gt;n<span class="number">+1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">// 如果非叶子节点，找到插入位置，如果其子节点为满，则将其分类，然后递归</span></span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span> &amp;&amp; k&lt;x-&gt;key[i])&#123;</span><br><span class="line">            --i;</span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">        <span class="keyword">if</span>(x-&gt;child[i]-&gt;n==<span class="number">2</span>*t<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="built_in">splitChild</span>(x,i);</span><br><span class="line">            <span class="keyword">if</span>(k&gt; x-&gt;key[i])&#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">insertNonfull</span>(x-&gt;child[i],k);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_B592E67F349A-1.jpeg" alt="IMG_B592E67F349A-1" style="zoom: 67%;" /><p>时间复杂度</p><p>insert 访问O(h) 个节点，h 为 B树的高度，每次调用 insertNonfull，所需时间为 O(1)，insertNonfull为递归，递归深度最多为 O(h)，每次递归对 n 个关键字进行扫描，由于 x.n &lt;= 2t，每个节点所花费的时间为 O(t)。总的 cpu 时间为 O(th) = O(t$\log_t{n}$​)，n 为B树所含关键字的个数。</p><h3 id="删除">删除</h3><p>参考：<a href="https://www.geeksforgeeks.org/delete-operation-in-b-tree/">https://www.geeksforgeeks.org/delete-operation-in-b-tree/</a></p><h2 id="参考">参考</h2><p>《算法导论》</p><p><a href="https://www.geeksforgeeks.org/introduction-of-b-tree-2/">Introduction of B-Tree - GeeksforGeeks</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> B树 </tag>
            
            <tag> 磁盘结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串转整数——自动机</title>
      <link href="/2021/09/17/zi-fu-chuan-zhuan-zheng-shu-zi-dong-ji/"/>
      <url>/2021/09/17/zi-fu-chuan-zhuan-zheng-shu-zi-dong-ji/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/string-to-integer-atoi/">题目链接</a></p><p>请你来实现一个 myAtoi(string s) 函数，使其能将字符串转换成一个 32 位有符号整数（类似 C/C++ 中的 atoi 函数）。</p><p>函数 myAtoi(string s) 的算法如下：</p><span id="more"></span><p>读入字符串并丢弃无用的前导空格<br>检查下一个字符（假设还未到字符末尾）为正还是负号，读取该字符（如果有）。 确定最终结果是负数还是正数。 如果两者都不存在，则假定结果为正。<br>读入下一个字符，直到到达下一个非数字字符或到达输入的结尾。字符串的其余部分将被忽略。<br>将前面步骤读入的这些数字转换为整数（即，“123” -&gt; 123， “0032” -&gt; 32）。如果没有读入数字，则整数为 0 。必要时更改符号（从步骤 2 开始）。<br>如果整数数超过 32 位有符号整数范围 [−231,  231 − 1] ，需要截断这个整数，使其保持在这个范围内。具体来说，小于 −231 的整数应该被固定为 −231 ，大于 231 − 1 的整数应该被固定为 231 − 1 。<br>返回整数作为最终结果。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;42&quot;</span><br><span class="line">输出：42</span><br></pre></td></tr></table></figure><p>示例2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;   -42&quot;</span><br><span class="line">输出：-42</span><br></pre></td></tr></table></figure><p>示例3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;4193 with words&quot;</span><br><span class="line">输出：4193</span><br></pre></td></tr></table></figure><p>示例4:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;words and 987&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p>示例5:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;-91283472332&quot;</span><br><span class="line">输出：-2147483648</span><br></pre></td></tr></table></figure><h2 id="方法一">方法一</h2><p>首先识别出字符串中的数字，并记录其正负。从低位到高位，对于每一个字符 c，用 c - ‘0’ 得到实际数字值，对于所有数字累加：<code>ans = ans*10 + c-'0'</code>，ans 是 int 类型，需要注意溢出问题。<code>ans*10</code>会溢出，ans*10 + c-'0’也会溢出。判断方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num = c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(ans &gt; INT_MAX/<span class="number">10</span> || (ans==INT_MAX &amp;&amp; num&gt;<span class="number">7</span>))&#123;</span><br><span class="line"><span class="comment">// 溢出</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  ans = ans*<span class="number">10</span> + c-<span class="string">&#x27;0&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// first 和 last 记录数字范围</span></span><br><span class="line">        <span class="type">int</span> first = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> last = <span class="number">0</span>;</span><br><span class="line">        <span class="type">bool</span> ispositive = <span class="literal">false</span>;   <span class="comment">// 是否为负</span></span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 去除前导0</span></span><br><span class="line">        <span class="keyword">for</span>(; first&lt;s.<span class="built_in">length</span>(); ++first)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[first]!=<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断正负号</span></span><br><span class="line">        <span class="keyword">if</span>(s[first]==<span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">                ispositive=<span class="literal">true</span>;</span><br><span class="line">                ++first;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[first]==<span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                ++first;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">       <span class="comment">// 判断数字</span></span><br><span class="line">       <span class="keyword">if</span>(s[first]&lt;<span class="string">&#x27;0&#x27;</span> || s[first]&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 去除前导0</span></span><br><span class="line">       <span class="keyword">for</span>(; first&lt;s.<span class="built_in">length</span>(); ++first)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[first]!=<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 找到第一个非数字符号</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=first; i&lt;s.<span class="built_in">length</span>(); ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]&lt;<span class="string">&#x27;0&#x27;</span> || s[i]&gt;<span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                last = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=first; i&lt;=last; ++i)&#123;</span><br><span class="line">            <span class="type">int</span> num = s[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(ans &gt; INT_MAX/<span class="number">10</span> || (ans==INT_MAX/<span class="number">10</span> &amp;&amp; num&gt;<span class="number">7</span>))</span><br><span class="line">                <span class="keyword">return</span> ispositive?INT_MIN:INT_MAX;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                ans = ans*<span class="number">10</span> + num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(ispositive)&#123;</span><br><span class="line">            <span class="keyword">return</span> -ans;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到代码容易写的比较臃肿，接下来介绍自动机方法。</p><h2 id="方法二">方法二</h2><p>自动机法。本方法使用的自动机，也叫有限状态自动机，它包含多种状态，有开始状态，也有结束状态，一个状态可以跳转到其他状态。从开始状态开始，经过状态的改变来到结束状态。</p><p>使用自动机：可以识别特定的符号，当然它也可以在字符串中识别数字。</p><p>如下图所示自动机：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-09-17%20%E4%B8%8B%E5%8D%8811.35.15.png" alt="截屏2021-09-17 下午11.35.15" style="zoom:50%;" /><p>start 表示开始状态，end 表示结束状态</p><p>start 表示开始状态，开始状态遇到 ‘空格’ 还是start 状态(相当于去掉前导0)；遇到数字，就跳转到 in_number 状态；遇到+/-号，就跳转到 signed；遇到其他字符就进入 end 状态(表示无数字)。</p><p>signed 遇到数字，进入 in_number(开始处理数字)，遇到其它非数字符号，就进入 end 状态。</p><p>in_number 遇到数字还是 in_number；遇到其它字符，说明已经处理完数字，直接进入 end 。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Automata</span>&#123;</span><br><span class="line">    string state = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">    unordered_map&lt;string,vector&lt;string&gt;&gt; table = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;start&quot;</span>,&#123;<span class="string">&quot;start&quot;</span>, <span class="string">&quot;signed&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;signed&quot;</span>,&#123;<span class="string">&quot;end&quot;</span>,<span class="string">&quot;end&quot;</span>,<span class="string">&quot;in_number&quot;</span>,<span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;in_number&quot;</span>,&#123;<span class="string">&quot;end&quot;</span>,<span class="string">&quot;end&quot;</span>,<span class="string">&quot;in_number&quot;</span>,<span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;end&quot;</span>,&#123;<span class="string">&quot;end&quot;</span>,<span class="string">&quot;end&quot;</span>,<span class="string">&quot;end&quot;</span>,<span class="string">&quot;end&quot;</span>&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_col</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isspace</span>(c)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;+&#x27;</span>||c==<span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="type">long</span> <span class="type">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">        state = table[state][<span class="built_in">get_col</span>(c)];</span><br><span class="line">        <span class="keyword">if</span>(state==<span class="string">&quot;in_number&quot;</span>)&#123;</span><br><span class="line">            ans = ans*<span class="number">10</span> + c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            ans = sign==<span class="number">1</span> ? <span class="built_in">min</span>(ans,(<span class="type">long</span> <span class="type">long</span>)INT_MAX): <span class="built_in">min</span>(ans,-(<span class="type">long</span> <span class="type">long</span>)INT_MIN);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == <span class="string">&quot;signed&quot;</span>)&#123;</span><br><span class="line">            sign = c==<span class="string">&#x27;+&#x27;</span>?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        Automata automata;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">            automata.<span class="built_in">get</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> automata.sign * automata.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上述代码使用自动机扫描字符串，并识别其中的数字和正负号。代码中使用 long long 类型，它是 64 位系统独有的，不适用于 32 位系统。为了提高兼容性，接下来给出 适用于 32 位系统的版本。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Automata</span>&#123;</span><br><span class="line">    string state = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">    unordered_map&lt;string,vector&lt;string&gt;&gt; table = &#123;</span><br><span class="line">        &#123;<span class="string">&quot;start&quot;</span>,&#123;<span class="string">&quot;start&quot;</span>, <span class="string">&quot;signed&quot;</span>, <span class="string">&quot;in_number&quot;</span>, <span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;signed&quot;</span>,&#123;<span class="string">&quot;end&quot;</span>,<span class="string">&quot;end&quot;</span>,<span class="string">&quot;in_number&quot;</span>,<span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;in_number&quot;</span>,&#123;<span class="string">&quot;end&quot;</span>,<span class="string">&quot;end&quot;</span>,<span class="string">&quot;in_number&quot;</span>,<span class="string">&quot;end&quot;</span>&#125;&#125;,</span><br><span class="line">        &#123;<span class="string">&quot;end&quot;</span>,&#123;<span class="string">&quot;end&quot;</span>,<span class="string">&quot;end&quot;</span>,<span class="string">&quot;end&quot;</span>,<span class="string">&quot;end&quot;</span>&#125;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_col</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isspace</span>(c)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(c==<span class="string">&#x27;+&#x27;</span>||c==<span class="string">&#x27;-&#x27;</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isdigit</span>(c)) <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sign = <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> finish = <span class="literal">true</span>;   <span class="comment">// 标记是否已经达到最大值，为 true 表示未达到最大值</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">get</span><span class="params">(<span class="type">char</span> c)</span></span>&#123;</span><br><span class="line">        state = table[state][<span class="built_in">get_col</span>(c)];</span><br><span class="line">        <span class="keyword">if</span>(state==<span class="string">&quot;in_number&quot;</span>)&#123;</span><br><span class="line">            <span class="type">int</span> num = c-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(ans &gt; INT_MAX/<span class="number">10</span> || (ans==INT_MAX/<span class="number">10</span> &amp;&amp; num&gt;<span class="number">7</span>))&#123;</span><br><span class="line">                ans = sign==<span class="number">1</span>?INT_MAX:INT_MIN;</span><br><span class="line">                finish = <span class="literal">false</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(finish==<span class="literal">true</span>)&#123;</span><br><span class="line">                ans = ans*<span class="number">10</span> + num; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(state == <span class="string">&quot;signed&quot;</span>)&#123;</span><br><span class="line">            sign = c==<span class="string">&#x27;+&#x27;</span>?<span class="number">1</span>:<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">myAtoi</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        Automata automata;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">char</span> c:s)&#123;</span><br><span class="line">            automata.<span class="built_in">get</span>(c);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(automata.finish)</span><br><span class="line">            <span class="keyword">return</span> automata.ans * automata.sign;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> automata.ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 自动机 </tag>
            
            <tag> 字符串转整数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 缓冲区溢出漏洞</title>
      <link href="/2021/09/17/linux-huan-chong-qu-yi-chu-lou-dong/"/>
      <url>/2021/09/17/linux-huan-chong-qu-yi-chu-lou-dong/</url>
      
        <content type="html"><![CDATA[<p>缓冲区溢出是一种非常普遍的漏洞，它的原理为输入大量的数据，超出了缓冲区的大小，且系统没有对输入数据的长度进行检查，这样数据可能覆盖了内存的重要区域，例如返回地址等，攻击者只需制作特定的数据，就可以让受攻击的计算机执行指定的代码。为了重现一些经典的缓冲区溢出漏洞，需要关闭 Linux 下针对这方面的一些保护措施，例如：</p><h2 id="SSP-Stack-Smashing-Protector">SSP( Stack Smashing Protector )</h2><span id="more"></span><p>SSP 是 gcc 提供的针对栈上缓冲区溢出提供的检查机制。典型的缓冲区溢出攻击会构造输入数据来覆盖缓冲区之外的数据，尤其是函数返回地址。启用 SSP机制后，在编译器生成的代码中，对于那些存在缓冲区的函数，函数开始时会在对应栈帧中压入一个随机值，当函数快要返回时，检查该随机值是否发生了变化，如果发生了变化，就将控制流转移到特定的函数。比较常见为输出以下信息，并退出进程。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*** stack smashing detected ***: &lt;unknown&gt; terminated</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure><p>使用以下代码进行说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">hacked</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;I am hacked&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">foo</span><span class="params">(<span class="type">char</span> *s)</span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">20</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(buffer,s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You entered: %s\n&quot;</span>,buffer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buff[<span class="number">300</span>];</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Enter some text: &quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,buff);</span><br><span class="line">    foo(buff);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 GDB 查看 foo 的反汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info function</span><br><span class="line">All defined functions:</span><br><span class="line"></span><br><span class="line">Non-debugging symbols:</span><br><span class="line">0x000003e0  _init</span><br><span class="line">0x00000420  printf@plt</span><br><span class="line">0x00000430  strcpy@plt</span><br><span class="line">0x00000440  __libc_start_main@plt</span><br><span class="line">0x00000450  __isoc99_scanf@plt</span><br><span class="line">0x00000460  __cxa_finalize@plt</span><br><span class="line">0x00000468  __gmon_start__@plt</span><br><span class="line">0x00000470  _start</span><br><span class="line">0x000004b0  __x86.get_pc_thunk.bx</span><br><span class="line">0x000004c0  deregister_tm_clones</span><br><span class="line">0x00000500  register_tm_clones</span><br><span class="line">0x00000550  __do_global_dtors_aux</span><br><span class="line">0x000005a0  frame_dummy</span><br><span class="line">0x000005a5  __x86.get_pc_thunk.dx</span><br><span class="line">0x000005a9  hacked</span><br><span class="line">0x000005d4  foo</span><br><span class="line">0x00000614  main</span><br><span class="line">0x00000680  __x86.get_pc_thunk.ax</span><br><span class="line">0x00000690  __libc_csu_init</span><br><span class="line">0x000006f0  __libc_csu_fini</span><br><span class="line">0x000006f4  _fini</span><br></pre></td></tr></table></figure><p>由上述代码可知，在函数开始，gs:0x14 的值被存储在 ebp - 0xc，在函数返回之前对 ebp - 0xc处的值进行检查，如果和 gs:0x14 不一样，说明发生了溢出，紧接着执行__stack_chk_fail_local 并退出进程。</p><p>根据汇编代码，可以知道foo 函数中 buffer 缓冲区的位置为 ebp-0x20。当我们输入的数据长度大于缓冲区的大小时，就可能覆盖缓冲区以外的内容。在函数结束时，就可能被检查出来。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc -g -m32 t.c -o t</span></span><br><span class="line">mygit@ubuntu:~/webServer-master/test$ ./t</span><br><span class="line">Enter some text: cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc</span><br><span class="line">You entered: cccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccc</span><br><span class="line">*** stack smashing detected ***: &lt;unknown&gt; terminated</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure><p>在 gcc 中  SSP 是默认开启的。使用以下命令开启和关闭 SSP。日常建议开启，如果需要对简单的缓冲区漏洞进行重现，就需要关闭该选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-fstack-protector    //编译时启用SSP机制</span><br><span class="line">-fno-stack-protector //编译时禁用SSP机制</span><br></pre></td></tr></table></figure><h2 id="DEP-Data-Execution-Prevention">DEP( Data Execution Prevention )</h2><p>某一类缓冲区溢出攻击通过将攻击指令存储在栈上，然后通过缓冲区溢出，修改函数的返回地址为栈上攻击指令的首地址。这样当函数返回时，函数的执行流就跳转到栈上构造好的指令序列。在现代编译器中，为防止栈中的数据被作为指令执行，使用了 DEP机制，即限制内存的属性。使得栈(可写不可执行)，代码段(可执行不可写)。</p><p>使用 gcc 编译时，使用 -z execstack 参数来让最终的可执行程序中的栈具有可执行权限。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-z execstack    //设置栈内存段具备可执行权限</span><br></pre></td></tr></table></figure><p>在程序运行时，可通过cat /proc/pid/maps 查看 pid 所对应的进程的内存映射情况,其中包括对进程的段的属性描述。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/28214/maps</span><br><span class="line">565ee000-565ef000 r-xp 00000000 08:01 1074931                            /home/mygit/webServer-master/test/t</span><br><span class="line">565ef000-565f0000 r--p 00000000 08:01 1074931                            /home/mygit/webServer-master/test/t</span><br><span class="line">565f0000-565f1000 rw-p 00001000 08:01 1074931                            /home/mygit/webServer-master/test/t</span><br><span class="line">57c81000-57ca3000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">f7ce0000-f7eb2000 r-xp 00000000 08:01 1966086                            /lib32/libc-2.27.so</span><br><span class="line">f7eb2000-f7eb3000 ---p 001d2000 08:01 1966086                            /lib32/libc-2.27.so</span><br><span class="line">f7eb3000-f7eb5000 r--p 001d2000 08:01 1966086                            /lib32/libc-2.27.so</span><br><span class="line">f7eb5000-f7eb6000 rw-p 001d4000 08:01 1966086                            /lib32/libc-2.27.so</span><br><span class="line">f7eb6000-f7eb9000 rw-p 00000000 00:00 0 </span><br><span class="line">f7ed9000-f7edb000 rw-p 00000000 00:00 0 </span><br><span class="line">f7edb000-f7ede000 r--p 00000000 00:00 0                                  [vvar]</span><br><span class="line">f7ede000-f7edf000 r-xp 00000000 00:00 0                                  [vdso]</span><br><span class="line">f7edf000-f7f05000 r-xp 00000000 08:01 1966082                            /lib32/ld-2.27.so</span><br><span class="line">f7f05000-f7f06000 r--p 00025000 08:01 1966082                            /lib32/ld-2.27.so</span><br><span class="line">f7f06000-f7f07000 rw-p 00026000 08:01 1966082                            /lib32/ld-2.27.so</span><br><span class="line">ffabc000-ffadd000 rw-p 00000000 00:00 0                                  [stack]</span><br></pre></td></tr></table></figure><h2 id="ASLR-address-space-layout-randomization">ASLR( address space layout randomization )</h2><p>在基本的缓冲区溢出攻击中，最基本的步骤就是定位某些目标的内存映射地址。例如最简单的 shellcode 注入需要在栈上构造特定指令序列，并通过缓冲区溢出使用攻击指令序列地址覆盖函数的返回地址。ret2libc 方法则需要定位内存中的标准库函数的内存映射地址。ASLR ，即内存布局随机化机制由操作系统实现，主要被划分为映像随机化、栈随机化和堆随机化这几类，分别针对程序的加载基地址、栈基址和堆基址进行随机化。</p><p>编译好的程序，它的各个段的加载地址是固定的，也就是程序运行时它的各个段的地址是固定的。通过查看 ELF 文件的 Program header table 信息，可以知道需加载入内存的各个段的基地址。通过命令 <code>objdump -h</code>查看，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">objdump -h t</span></span><br><span class="line"></span><br><span class="line">t:     file format elf32-i386</span><br><span class="line"></span><br><span class="line">Sections:</span><br><span class="line">Idx Name          Size      VMA       LMA       File off  Algn</span><br><span class="line">  0 .interp       00000013  00000154  00000154  00000154  2**0</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  1 .note.ABI-tag 00000020  00000168  00000168  00000168  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  2 .note.gnu.build-id 00000024  00000188  00000188  00000188  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  3 .gnu.hash     00000020  000001ac  000001ac  000001ac  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">..</span><br><span class="line">  8 .rel.dyn      00000040  000003bc  000003bc  000003bc  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line">  9 .rel.plt      00000028  000003fc  000003fc  000003fc  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"> 10 .init         00000023  00000424  00000424  00000424  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 11 .plt          00000060  00000450  00000450  00000450  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 12 .plt.got      00000010  000004b0  000004b0  000004b0  2**3</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 13 .text         000002e4  000004c0  000004c0  000004c0  2**4</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 14 .fini         00000014  000007a4  000007a4  000007a4  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, CODE</span><br><span class="line"> 15 .rodata       0000003a  000007b8  000007b8  000007b8  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, READONLY, DATA</span><br><span class="line"> ...</span><br><span class="line"> 20 .dynamic      000000f8  00001ed4  00001ed4  00000ed4  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 21 .got          00000034  00001fcc  00001fcc  00000fcc  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 22 .data         00000008  00002000  00002000  00001000  2**2</span><br><span class="line">                  CONTENTS, ALLOC, LOAD, DATA</span><br><span class="line"> 23 .bss          00000004  00002008  00002008  00001008  2**0</span><br><span class="line">                  ALLOC</span><br><span class="line"> 24 .comment      00000029  00000000  00000000  00001008  2**0</span><br><span class="line">                  CONTENTS, READONLY</span><br></pre></td></tr></table></figure><p>对于运行中的程序，使用 cat /proc/pid/maps，查看 pid 的内存映射情况，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ cat /proc/28214/maps</span><br><span class="line">565ee000-565ef000 r-xp 00000000 08:01 1074931                            /home/mygit/webServer-master/test/t (deleted)</span><br><span class="line">565ef000-565f0000 r--p 00000000 08:01 1074931                            /home/mygit/webServer-master/test/t (deleted)</span><br><span class="line">565f0000-565f1000 rw-p 00001000 08:01 1074931                            /home/mygit/webServer-master/test/t (deleted)</span><br><span class="line">57c81000-57ca3000 rw-p 00000000 00:00 0                                  [heap]</span><br><span class="line">f7ce0000-f7eb2000 r-xp 00000000 08:01 1966086                            /lib32/libc-2.27.so</span><br><span class="line">f7eb2000-f7eb3000 ---p 001d2000 08:01 1966086                            /lib32/libc-2.27.so</span><br><span class="line">f7eb3000-f7eb5000 r--p 001d2000 08:01 1966086                            /lib32/libc-2.27.so</span><br><span class="line">f7eb5000-f7eb6000 rw-p 001d4000 08:01 1966086                            /lib32/libc-2.27.so</span><br><span class="line">f7eb6000-f7eb9000 rw-p 00000000 00:00 0 </span><br><span class="line">f7ed9000-f7edb000 rw-p 00000000 00:00 0 </span><br><span class="line">f7edb000-f7ede000 r--p 00000000 00:00 0                                  [vvar]</span><br><span class="line">f7ede000-f7edf000 r-xp 00000000 00:00 0                                  [vdso]</span><br><span class="line">f7edf000-f7f05000 r-xp 00000000 08:01 1966082                            /lib32/ld-2.27.so</span><br><span class="line">f7f05000-f7f06000 r--p 00025000 08:01 1966082                            /lib32/ld-2.27.so</span><br><span class="line">f7f06000-f7f07000 rw-p 00026000 08:01 1966082                            /lib32/ld-2.27.so</span><br><span class="line">ffabc000-ffadd000 rw-p 00000000 00:00 0                                  [stack]</span><br></pre></td></tr></table></figure><p>在过去的系统环境中，程序的.text、.bss、.rodata等段地址在加载入内存时是确定的，程序运行时进程中 stack 和 heap 的起始地址也总是固定的。这样攻击者就更容易定位到特定代码的地址。ALSR 机制后，操作系统会在加载段时在其原始的基地址上加上一个随机值，这样同一程序多次运行，它的内存布局都会不一样，这样攻击者更难实施特定的攻击。</p><p>使用命令 <code>cat /proc/sys/kernel/randomize_va_space</code>查看 ASLR 的设置情况：</p><ul><li>0:  ASLR未启用</li><li>1：ALSR 机制会随机化 stack、vdso和 mmap 的起始基地址</li><li>2：对上述目标进行随机化外还会对堆基地址进行随机化。</li></ul><p>通过命令 <code>echo 0 &gt; /proc/sys/kernel/randomize_va_space</code> 关闭 ALSR，或设置为其它值。</p><p>上述命令为全局生效，且需要 root 权限，使用以下命令只在当前终端中关闭 ALSR。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　setarch `uname -m` -R /bin/bash</span><br></pre></td></tr></table></figure><h2 id="通过-GDB-获得目标地址">通过 GDB 获得目标地址</h2><p>使用 GDB 可以确定目标代码的地址，例如目标缓冲区的地址。</p><p>使用以下代码查看 foo 的汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">disassemble foo</span><br><span class="line">Dump of assembler code for function foo:</span><br><span class="line">0x000005d4 &lt;+0&gt;:     push   %ebp</span><br><span class="line">0x000005d5 &lt;+1&gt;:     mov    %esp,%ebp</span><br><span class="line">0x000005d7 &lt;+3&gt;:     push   %ebx</span><br><span class="line">0x000005d8 &lt;+4&gt;:     sub    $0x24,%esp</span><br><span class="line">0x000005db &lt;+7&gt;:     call   0x66b &lt;__x86.get_pc_thunk.ax&gt;</span><br><span class="line">0x000005e0 &lt;+12&gt;:    add    $0x19f0,%eax</span><br><span class="line">0x000005e5 &lt;+17&gt;:    sub    $0x8,%esp</span><br><span class="line">0x000005e8 &lt;+20&gt;:    push   0x8(%ebp)</span><br><span class="line">0x000005eb &lt;+23&gt;:    lea    -0x1c(%ebp),%edx</span><br><span class="line">0x000005ee &lt;+26&gt;:    push   %edx</span><br><span class="line">0x000005ef &lt;+27&gt;:    mov    %eax,%ebx</span><br><span class="line">0x000005f1 &lt;+29&gt;:    call   0x430 &lt;strcpy@plt&gt;</span><br><span class="line">0x000005f6 &lt;+34&gt;:    add    $0x10,%esp</span><br><span class="line">0x000005f9 &lt;+37&gt;:    nop</span><br><span class="line">0x000005fa &lt;+38&gt;:    mov    -0x4(%ebp),%ebx</span><br><span class="line">0x000005fd &lt;+41&gt;:    leave  </span><br><span class="line">0x000005fe &lt;+42&gt;:    ret    </span><br></pre></td></tr></table></figure><p>由上述代码可知，foo 函数内 buffer 缓冲区的地址为：ebp - 0x1c</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">(gdb) info function</span><br><span class="line">All defined functions:</span><br><span class="line"></span><br><span class="line">Non-debugging symbols:</span><br><span class="line">0x000003e0  _init</span><br><span class="line">0x00000420  printf@plt</span><br><span class="line">0x00000430  strcpy@plt</span><br><span class="line">0x00000440  __libc_start_main@plt</span><br><span class="line">0x00000450  __isoc99_scanf@plt</span><br><span class="line">0x00000460  __cxa_finalize@plt</span><br><span class="line">0x00000468  __gmon_start__@plt</span><br><span class="line">0x00000470  _start</span><br><span class="line">0x000004b0  __x86.get_pc_thunk.bx</span><br><span class="line">0x000004c0  deregister_tm_clones</span><br><span class="line">0x00000500  register_tm_clones</span><br><span class="line">0x00000550  __do_global_dtors_aux</span><br><span class="line">0x000005a0  frame_dummy</span><br><span class="line">0x000005a5  __x86.get_pc_thunk.dx</span><br><span class="line">0x000005a9  hacked</span><br><span class="line">0x000005d4  foo</span><br><span class="line">0x00000614  main</span><br><span class="line">0x00000680  __x86.get_pc_thunk.ax</span><br><span class="line">0x00000690  __libc_csu_init</span><br><span class="line">0x000006f0  __libc_csu_fini</span><br><span class="line">0x000006f4  _fini</span><br></pre></td></tr></table></figure><p>由上述信息可知，foo 的地址 和  hacked 的地址。</p><h2 id="总结">总结</h2><p>在 GDB 中看到的地址不一定是真实程序运行的地址，原因多种多样，例如环境变量不一致会导致地址差异。Linux 近年来为了预防缓冲区漏洞的产生，也采取了多种措施，不只是上述提到的三种。在增强了 Linux 安全性的同时，也大大提高了缓冲区溢出攻击的门槛。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 缓冲区溢出 </tag>
            
            <tag> 信息安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>恢复二叉搜索树</title>
      <link href="/2021/09/16/hui-fu-er-cha-sou-suo-shu/"/>
      <url>/2021/09/16/hui-fu-er-cha-sou-suo-shu/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/recover-binary-search-tree/">题目链接</a></p><p>给你二叉搜索树的根节点 root ，该树中的两个节点被错误地交换。请在不改变其结构的情况下，恢复这棵树。</p><p>进阶：使用 O(n) 空间复杂度的解法很容易实现。你能想出一个只使用常数空间的解决方案吗？</p><span id="more"></span><p>示例 1：<br><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-09-16%20%E4%B8%8B%E5%8D%8812.01.40.png" alt="截屏2021-09-16 下午12.01.40" style="zoom: 33%;" /></p><p>输入：root = [1,3,null,null,2]<br>输出：[3,1,null,null,2]<br>解释：3 不能是 1 左孩子，因为 3 &gt; 1 。交换 1 和 3 使二叉搜索树有效。</p><h2 id="显式中序遍历">显式中序遍历</h2><p>这种方法，我们需要借助一个数组，保存二叉树的中序遍历(左-根-右)顺序，一颗二叉搜索树的前序遍历是有序数列(从小到大)。遍历完成后，只需遍历数组就可以找到哪两个节点被错误交换了位置。</p><p>如上图所示，左边子树的中序遍历为: 3 2 1。正常应该为递增数列，很明显 3 和 1被交换了位置，正确顺序应该为：1 2 3，只需交换 3 和 1 的节点值即可。</p><p>我们使用节点类型的数组，直接保存节点，而不是节点值，后续就可以直接交换节点值了，不然又要遍历修改。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;TreeNode*&gt; vec;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">            vec.<span class="built_in">push_back</span>(root);</span><br><span class="line">            <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 获取中序遍历结果</span></span><br><span class="line">      <span class="built_in">dfs</span>(root);   </span><br><span class="line">        TreeNode* x;</span><br><span class="line">        <span class="type">bool</span> isNotLast = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 找到第一个不满足递增序列的数</span></span><br><span class="line">        <span class="keyword">for</span>(; i&lt;vec.<span class="built_in">size</span>()<span class="number">-1</span>; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[i]-&gt;val&gt;vec[i<span class="number">+1</span>]-&gt;val)&#123;</span><br><span class="line">                x = vec[i];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 找到最后一个不满足递增序列的数</span></span><br><span class="line">        <span class="keyword">while</span>(i<span class="number">+1</span>&lt;vec.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span>(vec[++i]-&gt;val&gt;=x-&gt;val)&#123;</span><br><span class="line">                isNotLast = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 判断是不是最后一个，如果不是，将 i-1 即为需要交换的值</span></span><br><span class="line">        <span class="keyword">if</span>(isNotLast)&#123;</span><br><span class="line">            i = i<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(x-&gt;val,vec[i]-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度">时间复杂度</h3><p>DFS 耗时 O(n)，后续只需循环一次，最多耗时 O(n)，n 为节点个数，所以总的时间复杂度为 O(2n)=O(n)。</p><h3 id="空间复杂度">空间复杂度</h3><p>存储遍历需要 O(n)，递归所需空间O(H*1)，H 为二叉搜索树的深度，因为 O(H*1) &lt;=  O(n)，根据渐进关系，空间复杂度为 O(n)。</p><h2 id="隐式中序遍历">隐式中序遍历</h2><p>有没有办法只需一次遍历就可以找到两个被错误交换的节点。使用 pre 标记节点的前驱，如果当前节点 root-&gt;val &lt; pre-&gt;val，说明root 和 pre 应该交换。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-09-16%20%E4%B8%8B%E5%8D%881.12.41.png" alt="截屏2021-09-16 下午1.12.41" style="zoom: 33%;" /><p>由上图所示，当使用中序遍历时，记录每个节点的前驱节点，初始化 pre == nullptr。</p><p>root 为 1 时，它的前驱为 nullptr，设置 pre 为 1</p><p>root 为 3 时，它的前驱为 1，root 应该大于它的前驱，设置 pre 为 3</p><p>root 为 2时，它的前驱为 3，root 应该大于它的前驱，但此时 root 小于了前驱，说明应该交换 root 和 它的前驱。到此时 DFS 的任务完成。设置 pre 为 2</p><p>root 为 4时，它的前驱为 2，root 应该大于它的前驱，设置 pre 为 4</p><p>DFS 结束，找到了应该结合的两个节点。 3 和 2。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* x = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* y = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span>(pre!=<span class="literal">nullptr</span> &amp;&amp; root-&gt;val&lt;pre-&gt;val)&#123;</span><br><span class="line">            y = root;</span><br><span class="line">            <span class="keyword">if</span>(x==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                x = pre;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        pre = root;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;pre=&quot;</span>&lt;&lt;pre-&gt;val&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root);</span><br><span class="line">        <span class="built_in">swap</span>(x-&gt;val,y-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度-2">时间复杂度</h3><p>DFS 的时间复杂度：O(n)，n 为节点个数，总的时间复杂度为 O(n)</p><h3 id="空间复杂度-2">空间复杂度</h3><p>每次递归需要 O(1) 空间，递归深度为H，总的空间复杂度为 O(H)，H 为二叉搜索树的深度。</p><h3 id="迭代优化">迭代优化</h3><p>使用递归，结构更加清晰。关于递归的缺点，和二叉树的迭代实现细节可以参考：<a href="https://www.wangjunblogs.com/2021/09/08/c-er-cha-shu-bian-li-die-dai-shi-xian/">c++迭代实现二叉树遍历 | 编程之禅</a></p><p>递归的另一个缺点就是，当找到了需要交换的两个节点之后，并不会马上退出递归函数，它需要遍历完所有节点才会退出。使用迭代实现，当找到需要交换的两个节点之后可以马上退出。</p><p>具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* x = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* y = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        stack&lt;TreeNode*&gt;s;   <span class="comment">// 模拟递归栈</span></span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                s.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            root = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">          <span class="comment">// 比较当前根节点和前驱节点，根节点值应该大于前驱节点，应该中序遍历为递增数列</span></span><br><span class="line">            <span class="keyword">if</span>(pre != <span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt; pre-&gt;val)&#123;</span><br><span class="line">                y = root;</span><br><span class="line">                <span class="keyword">if</span>(x==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    x = pre;</span><br><span class="line">                &#125;<span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = root;</span><br><span class="line">            root  = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(x-&gt;val,y-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度和空间复杂度和 递归版本一致</p><h2 id="Morris-中序遍历">Morris 中序遍历</h2><p>Morris 中序遍历可以实现O(1) 的空间复杂度，即它不需要一个栈来存储递归路径。它的原理就是，对于它的每一个子树，只要它的左孩子存在，就将其左子树中序遍历的最后一个节点(前驱节点)的右孩子指向子树根节点，这样当遍历完左子树的时候，可以回到子树根节点。回到根节点后，根据它的前驱节点的右孩子是否为空，判断它的右孩子是否访问过，如果为空，代表它的右孩子还没访问，如果不为空，表示它的右孩子已经访问过，此时将它的前驱节点的右孩子置为空，恢复为原来的结构。</p><p>具体代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">recoverTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode* x = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* y = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* pre = <span class="literal">nullptr</span>;</span><br><span class="line">        TreeNode* predecessor = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">          <span class="comment">// 当前子树左节点不为空</span></span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left!=<span class="literal">nullptr</span>)&#123;     </span><br><span class="line">                predecessor = root-&gt;left;</span><br><span class="line">                <span class="comment">// 找到根节点的前驱节点</span></span><br><span class="line">                <span class="keyword">while</span>(predecessor-&gt;right!=<span class="literal">nullptr</span> &amp;&amp; predecessor-&gt;right!=root)&#123;</span><br><span class="line">                    predecessor = predecessor-&gt;right;</span><br><span class="line">                &#125; </span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果当前子树的前驱节点的右孩子为空，则将其右孩子设置为当前子树根节点。root 设置为其左孩子</span></span><br><span class="line">                <span class="keyword">if</span>(predecessor-&gt;right == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">                    predecessor-&gt;right = root;</span><br><span class="line">                    root = root-&gt;left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;     </span><br><span class="line">                    <span class="comment">// 如果当前子树的前驱节点的右孩子不为空，说明其右孩子已经访问过了</span></span><br><span class="line">                    <span class="comment">// 将该前驱节点的右孩子置为空，恢复原来的结构</span></span><br><span class="line">                    <span class="comment">// root 设置为它的后继节点，相当于回溯</span></span><br><span class="line">                    <span class="keyword">if</span>(pre!=<span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt; pre-&gt;val)&#123;</span><br><span class="line">                        y = root;</span><br><span class="line">                        <span class="keyword">if</span>(x==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                            x = pre;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    pre = root;</span><br><span class="line">                    predecessor-&gt;right = <span class="literal">nullptr</span>;</span><br><span class="line">                    root = root-&gt;right;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;  <span class="comment">// 如果没有左子树，直接访问右子树</span></span><br><span class="line">                <span class="keyword">if</span>(pre!=<span class="literal">nullptr</span> &amp;&amp; root-&gt;val &lt; pre-&gt;val)&#123;</span><br><span class="line">                        y = root;</span><br><span class="line">                        <span class="keyword">if</span>(x==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">                            x = pre;</span><br><span class="line">                        &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = root;</span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(x-&gt;val,y-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度-3">时间复杂度</h3><p>每个节点被访问了两次，因此时间复杂度为 O(2N)=O(N)，N 为节点个数。</p><h3 id="空间复杂度-3">空间复杂度</h3><p>O(1)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉搜索树 </tag>
            
            <tag> 中序遍历 </tag>
            
            <tag> Morris中序遍历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求解子集的两种办法</title>
      <link href="/2021/09/13/qiu-jie-zi-ji-de-liang-chong-ban-fa/"/>
      <url>/2021/09/13/qiu-jie-zi-ji-de-liang-chong-ban-fa/</url>
      
        <content type="html"><![CDATA[<p><a href="https://leetcode-cn.com/problems/subsets/">题目链接</a></p><p>给你一个整数数组 nums ，数组中的元素 互不相同 。返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。你可以按 任意顺序 返回解集。</p><p>示例 1：</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><p><code>nums</code> 中的所有元素互不相同</p><h2 id="二进制枚举子集">二进制枚举子集</h2><p>n 为元素的集合，子集的个数(含空集)为2<sup>n</sup>，表示 2<sup>n</sup> 种状态。假设集合为nums = [1,2,3]，它的子集表示如下：</p><table><thead><tr><th>子集</th><th>二进制</th><th>对应十进制</th></tr></thead><tbody><tr><td>[]</td><td>000</td><td>0</td></tr><tr><td>[1]</td><td>001</td><td>1</td></tr><tr><td>[2]</td><td>010</td><td>2</td></tr><tr><td>[1,2]</td><td>011</td><td>3</td></tr><tr><td>[3]</td><td>100</td><td>4</td></tr><tr><td>[1,3]</td><td>101</td><td>5</td></tr><tr><td>[2,3]</td><td>110</td><td>6</td></tr><tr><td>[1,2,3]</td><td>111</td><td>7</td></tr></tbody></table><p>从 000 到 111 总共包含 2<sup>3</sup> 种状态，恰好对应子集的个数。我们将对应的二进制位为 1 表示取集合中该位置元素，为 0 表示不取集合中该位置元素。例如<code>010</code>，二进制位的序号为 0，1，2，下标 0 和 2为 0 ，不取，下标 1 为 1，表示取，所以该子集为 [nums[1]] = [2]。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; tem;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> mask = <span class="number">0</span>; mask &lt; (<span class="number">1</span> &lt;&lt; len); ++mask) &#123;</span><br><span class="line">            tem.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; len; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mask &amp; (<span class="number">1</span> &lt;&lt; i)) &#123;</span><br><span class="line">                    tem.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tem);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用 1 &lt;&lt; len 得到 2<sup>n</sup></p><h3 id="时间复杂度">时间复杂度</h3><p>n 个元素的集合，总共有 2<sup>n</sup>种状态，每种状态都需要遍历 n 次，总的时间复杂度为 O(n 2<sup>n</sup>)</p><h3 id="空间复杂度">空间复杂度</h3><p>临时数组 tem 的空间，空间复杂度为 O(n)</p><h2 id="回溯">回溯</h2><p>对于 n 个元素的集合来说，我们需要对集合做 n 次选择，从左到右选择元素，对于每一个元素，要么选，要么不选，所以可以用回溯法来实现。</p><p>递归树如下：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_9B4724B19554-1.jpeg" alt="IMG_9B4724B19554-1" style="zoom:50%;" /><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tem;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur,vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tem);    <span class="comment">// cur 等于元素个数时，已经选完</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        tem.<span class="built_in">push_back</span>(nums[cur]);  <span class="comment">// 选择第 cur 个元素</span></span><br><span class="line">        <span class="built_in">dfs</span>(cur<span class="number">+1</span>,nums);</span><br><span class="line">        tem.<span class="built_in">pop_back</span>();            <span class="comment">// 不选第 cur 个元素</span></span><br><span class="line">        <span class="built_in">dfs</span>(cur<span class="number">+1</span>,nums);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,nums);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度-2">时间复杂度</h3><p>根据递归树可知，它的叶子节点个数为子集个数，叶节点个数为 2<sup>n</sup> ，构建每个子集都需要 O(n) 的时间，所以总的时间为 O(n 2<sup>n</sup>)。</p><h3 id="空间复杂度-2">空间复杂度</h3><p>临时数组 tem O(n) ，递归的深度为 n，每次递归空间复杂度为 O(1)。所以总的空间复杂度为: O(n)。</p><h2 id="进阶——存在重复元素">进阶——存在重复元素</h2><p><a href="https://leetcode-cn.com/problems/subsets-ii/">题目链接</a></p><p>给你一个整数数组 nums ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。</p><p>解集 不能 包含重复的子集。返回的解集中，子集可以按 任意顺序 排列。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,2]</span><br><span class="line">输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[[],[0]]</span><br></pre></td></tr></table></figure><h3 id="二进制枚举">二进制枚举</h3><p>给定一个集合[1,2,2]，当选择元素 x ，若前面有一个相同元素 y 并没有被选取，那么包含 x 的所有子集必然会出现包含 y 的子集中。我们可以通过判断，排除存在重复的子集。</p><p>在开始枚举之前，现将 nums 数组进行排序。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tem;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">bool</span> isuse;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> mask=<span class="number">0</span>; mask&lt; (<span class="number">1</span>&lt;&lt;len); ++mask)&#123;</span><br><span class="line">            tem.<span class="built_in">clear</span>();</span><br><span class="line">            isuse = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i&lt;len; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="number">1</span>&amp;(mask&gt;&gt;i))&#123;</span><br><span class="line">                    <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; nums[i]==nums[i<span class="number">-1</span>] &amp;&amp; !(<span class="number">1</span>&amp;(mask&gt;&gt;(i<span class="number">-1</span>))))&#123;  <span class="comment">// 判断是否重复</span></span><br><span class="line">                        isuse = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        tem.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isuse) <span class="comment">// 不存在重复时才加入 ans</span></span><br><span class="line">                ans.<span class="built_in">push_back</span>(tem);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：</p><p>​排序时间复杂度为 O(n lgn)，总共构造 2<sup>n</sup> 个子集，构造每个子集所需时间为 O(n)，生成所有子集的时间为 O(n 2<sup>n</sup>)，因为从渐进意义上来讲 O(n lgn) &lt; O(n 2<sup>n</sup>)，所以总的时间复杂度为 O(n 2<sup>n</sup>)</p><p>空间复杂度</p><p>​使用了一个长度最多为 n 的临时数组，所以为 O(n)</p><h3 id="回溯-2">回溯</h3><p>不存在重复元素的情况类似，当选择元素 x ，若前面有一个相同元素 y 并没有被选取，那么包含 x 的所有子集必然会出现包含 y 的子集中。若当前元素为符合上述条件中的 x，则直接返回。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; ans;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tem;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cur, vector&lt;<span class="type">int</span>&gt;&amp; nums,<span class="type">bool</span> pre)</span></span>&#123;</span><br><span class="line">      <span class="comment">// pre 表示当前元素之前的元素是否被选择，为 true 则被选择</span></span><br><span class="line">        <span class="keyword">if</span>(cur==nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(tem);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">dfs</span>(cur<span class="number">+1</span>,nums,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">if</span>(!pre &amp;&amp; cur&gt;<span class="number">0</span> &amp;&amp; nums[cur]==nums[cur<span class="number">-1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        tem.<span class="built_in">push_back</span>(nums[cur]);</span><br><span class="line">        <span class="built_in">dfs</span>(cur<span class="number">+1</span>,nums,<span class="literal">true</span>);</span><br><span class="line">        tem.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,nums,<span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>时间复杂度：</p><p>​最坏情况下为不存在重复元素，排序所需时间 O(n lgn)，1 个叶节点代表一个子集，叶节点的个数为 2<sup>n</sup>，构造每个子集需要 O(n)，构造子集的时间为 O(n 2<sup>n</sup>)，O(n lgn) &lt; O(n 2<sup>n</sup>),时间复杂度总是忽略低阶项，所以全过程的时间复杂度为 O(n 2<sup>n</sup>)</p><p>空间复杂度</p><p>​使用一个临时数组 tem，递归最深时栈空间 O(n)，总的空间复杂度为 O(n)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 二进制枚举子集 </tag>
            
            <tag> DFS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归算法时间与空间复杂度分析</title>
      <link href="/2021/09/12/di-gui-suan-fa-shi-jian-yu-kong-jian-fu-za-du-fen-xi/"/>
      <url>/2021/09/12/di-gui-suan-fa-shi-jian-yu-kong-jian-fu-za-du-fen-xi/</url>
      
        <content type="html"><![CDATA[<p>递归是一种强大的技术，可以解决很多复杂的问题。很多算法都建立递归之上，像树的遍历，深搜，广搜，还有很多强大的排序算法等。现在来分析以下这些常见的递归算法的时间复杂度是怎样的。</p><p><strong>递归的时间复杂度=递归的深度*每层递归的代价</strong></p><p><strong>递归的空间复杂度=递归的深度*每次递归所需空间</strong></p><span id="more"></span><h2 id="求阶乘">求阶乘</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fac</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n*<span class="built_in">fac</span>(n<span class="number">-1</span>); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度">时间复杂度</h3><p>算法运算时间的递归式为：T(n) = T(n-1) + O(1)</p><p>总共递归n层，每层的时间复杂度为 O(1)，所以总的时间复杂度为 O(n*1) = O(n)</p><h3 id="空间复杂度">空间复杂度</h3><p>总共递归 n 层，函数的每次调用产生的空间复杂度为 O(1)，所以总的空间复杂度为 O(n*1) = O(n)</p><h3 id="注意">注意</h3><p>由于 int 大小的限制，它最多能求解16的阶乘，因为 int 最大值为2147483647，大于 2147483647 ,int 型变量就会变成负值。</p><h2 id="求解斐波那契数列">求解斐波那契数列</h2><p>斐波那契数列: 0 1 1 2 3 5 8 13</p><p>从 n 大于等于 2 开始，每个斐波那契数都是前两个数之和。</p><p>求解第 n 个斐波那契数是一个经典的问题，现在用递归来解决这个问题。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fib</span>(n<span class="number">-1</span>)+<span class="built_in">fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度分析">时间复杂度分析</h3><p>算法运行时间的递归式为：T(n) = T(n-1) + T(n-2) + O(1)。</p><blockquote><p>递归树是递归分析的常用工具，通过递归树可以看出递归的深度，每层的代价。</p></blockquote><p>当 n==5 时的递归树如下。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-08-28%20%E4%B8%8B%E5%8D%8812.12.19.png" alt="截屏2021-08-28 下午12.12.19" style="zoom: 25%;" /><p>从递归树可知<strong>每层的代价为它的结点个数</strong>，<strong>树的深度为 n</strong>(根节点为第1层)</p><p>递归的总代价为总节点个数，而递归的节点个数 以2<sup>n</sup>增长，所以该算法的时间复杂度为 <strong>O(2<sup>n</sup>)</strong></p><h3 id="空间复杂度分析">空间复杂度分析</h3><p>对单线程来说，递归的空间复杂度为：递归树的深度*每次递归所需要的空间</p><p>由递归树可知，递归的深度为n，每次递归所需时间为 O(1)</p><p>所以总的时间复杂度为 O(n*1) = <strong>O(n)</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 递归算法 </tag>
            
            <tag> 阶乘 </tag>
            
            <tag> 斐波那契 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>插入排序原理</title>
      <link href="/2021/09/12/cha-ru-pai-xu-yuan-li/"/>
      <url>/2021/09/12/cha-ru-pai-xu-yuan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="原理">原理</h2><p>对于少数元素的排序，这是一个有效算法。插入排序类似于排序手中的扑克牌。开始时，我们左手为空并且桌子上的牌面向下。然后我们每次从桌子上拿走一张牌并将它插入左手中正确的位置。为了找到一张牌的正确位置，我们从右到左将它与已在手中的每张牌进行比较。</p><span id="more"></span><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_9B2354F2DC6E-1.jpeg" alt="IMG_9B2354F2DC6E-1" style="zoom:50%;" /><p>假设每个人发10张扑克牌，我们使用for循环来遍历每一张需要拿起的牌。</p><p>每拿起一张牌，我们都从右往左，依次与手中的每张牌比较，若大于刚拿起的牌，则将它往后移一位，移位之后就有空缺的位置，若不大于，则将它插入空缺的位置上。</p><h2 id="代码实现">代码实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertion</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;nums.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">      <span class="comment">//i代表第i个数字将要插入已排好序的序列中</span></span><br><span class="line">        <span class="type">int</span> key = nums[i];   <span class="comment">//用key来暂存需要插入的数字</span></span><br><span class="line">        <span class="type">int</span> j = i<span class="number">-1</span>;         <span class="comment">//用j来遍历有序数组中从右到左的每个数，直到找到一个数组中小于k的值tem，然后将key值插入tem的右边。若没找到，则将key插入到有序数组最左边</span></span><br><span class="line">        <span class="keyword">while</span>(j&gt;<span class="number">-1</span> &amp;&amp; nums[j]&gt;key)&#123;</span><br><span class="line">            nums[j<span class="number">+1</span>] = nums[j];  <span class="comment">//因为第i个数已经保存在key中，相当于空出来一个位置，如果nums[j]&gt;key，则将它右移一位</span></span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[j<span class="number">+1</span>] = key; <span class="comment">//跳出了while循环，说明已经找到了key值的正确位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度分析">复杂度分析</h2><p>空间复杂度：O(1)。插入排序为原址排序，只用了常数个空间</p><p>当数组按逆序排列时，例如(6,5,4,3,2,1)，每个元素需要平均移动步数最多，总的移动步数为闭区间[1,n-1]所有元素的和。根据等差数列前项和公式。</p><p>总的移动步数为：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-09-12%20%E4%B8%8A%E5%8D%8810.45.11.png" alt="等差数列前 n 和公式" style="zoom: 50%;" /><p>时间复杂度：O(n<sup>2</sup>)。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 插入排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++动态内存与智能指针</title>
      <link href="/2021/09/12/c-dong-tai-nei-cun-yu-zhi-neng-zhi-zhen/"/>
      <url>/2021/09/12/c-dong-tai-nei-cun-yu-zhi-neng-zhi-zhen/</url>
      
        <content type="html"><![CDATA[<p>使用智能指针需包含以下头文件：<code>#include  &lt;memory&gt;</code></p><h2 id="shared-ptr类">shared_ptr类</h2><p>shared_ptr允许多个指针指向同一个对象<br><strong>支持的操作：</strong></p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;T&gt; sp;      <span class="comment">//空智能指针，可以指向类型为T的对象</span></span><br><span class="line">p                      <span class="comment">//将p用作一个条件判断，若p指向一个对象，则为true</span></span><br><span class="line">*p                     <span class="comment">//解引用sp, 获得它指向的对象</span></span><br><span class="line">p-&gt;mem                 <span class="comment">//等价于(*p).mem</span></span><br><span class="line">p.<span class="built_in">get</span>()                <span class="comment">//返回p中保存的指针。要小心使用，若指针指针释放了其对象，返回的指针所指向的对象也就消失了</span></span><br><span class="line"><span class="built_in">swap</span>(p,q) 等价于 p.<span class="built_in">swap</span>(q)              <span class="comment">//交换p和q中的指针</span></span><br><span class="line"><span class="built_in">make_shared</span>&lt;T&gt;(args)   <span class="comment">//返回一个shared_ptr，指向一个动态分配的类型为T的对象。使用args初始化次对象</span></span><br><span class="line">shared_ptr&lt;T&gt;<span class="built_in">p</span>(q)       <span class="comment">//p是shared_ptr的拷贝；次操作会递增q中的计数器。q中的指针必须能转换为T*</span></span><br><span class="line">p=q                     <span class="comment">//p和q都是shared_ptr，所保存的指针必须能相互转换。此操作会递减p的引用计数，递增q的引用计数；若p的引用计数变为0, 则其管理的原内存会被释放</span></span><br><span class="line">p.<span class="built_in">unique</span>()              <span class="comment">//若p.use_count()为1，返回true; 否则返回false</span></span><br><span class="line">p.<span class="built_in">use_count</span>()           <span class="comment">// 返回与p共享对象的智能指针的数量；可能很慢，主要用于调试</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="shared-ptr和new结合使用">shared_ptr和new结合使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">double</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">1024</span>))</span></span>;   <span class="comment">//p1指向一个值为42的int</span></span><br><span class="line">shared_ptr&lt;<span class="type">double</span>&gt; p1 = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>);  <span class="comment">//错误，必须使用直接初始化形式</span></span><br></pre></td></tr></table></figure><h3 id="改变shared-ptr的方法">改变shared_ptr的方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;T&gt;<span class="built_in">p</span>(u)    <span class="comment">//p从unique_ptr u那里接管了对象的所有权：将u置为空</span></span><br><span class="line">shared_ptr&lt;T&gt;<span class="built_in">p</span>(q,d)  <span class="comment">//p接管了内置指针q所指向的对象的所有权。q必须能转换为T*类型。p将使用可调用对象d来代替delete</span></span><br><span class="line">p.<span class="built_in">reset</span>()            <span class="comment">//若p为唯一指向其对象的shared_ptr，reset会释放此对象</span></span><br><span class="line">p.<span class="built_in">reset</span>(q)           <span class="comment">//释放为p，令p指向q</span></span><br><span class="line">p.<span class="built_in">reset</span>(q,d)         <span class="comment">//调用d而不是delete来释放q</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><h3 id="自定义释放操作">自定义释放操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义自己的释放函数</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span> </span>&#123;<span class="built_in">disconnect</span>(*p);&#125;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(destination &amp;d)</span></span>&#123;</span><br><span class="line">  connection c = <span class="built_in">connect</span>(&amp;d);</span><br><span class="line">  <span class="function">shared_ptr&lt;connection&gt; <span class="title">p</span><span class="params">(&amp;c, end_connection)</span></span>;   <span class="comment">//当f退出时（即使是由于异常而退出），connection会被正确关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="unique-ptr类">unique_ptr类</h2><p>与shared_ptr不一样，某个时刻只能有一个unique_ptr指向一个给定对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">42</span>))</span></span>;  <span class="comment">//unique_ptr必须采用直接初始化形式，而不能采用拷贝和赋值</span></span><br></pre></td></tr></table></figure><h3 id="unique-ptr的常见操作">unique_ptr的常见操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;T&gt; u1;        <span class="comment">//空unique_ptr</span></span><br><span class="line">unique_ptr&lt;T,D&gt;u2;       <span class="comment">//空unique_ptr，u2使用类型为D的可调用对象来释放它的指针</span></span><br><span class="line">unique_ptr&lt;T,D&gt;<span class="built_in">u</span>(d);     <span class="comment">//空unique_ptr，指向类型为T的对象，用类型为D的对象d代替delete</span></span><br><span class="line">u = <span class="literal">nullptr</span>              <span class="comment">//释放u指向的对象，将u置为空</span></span><br><span class="line">u.<span class="built_in">release</span>()              <span class="comment">//u放弃对指针的控制权，返回指针，将u置为空</span></span><br><span class="line">u.<span class="built_in">reset</span>()                <span class="comment">//将u置为空</span></span><br><span class="line">u.<span class="built_in">reset</span>(q)               <span class="comment">//将u置为空，令u指向q。</span></span><br><span class="line">u.<span class="built_in">reset</span>(<span class="literal">nullptr</span>)         <span class="comment">//将u置为空，令u指向nullptr</span></span><br></pre></td></tr></table></figure><h3 id="赋值和拷贝">赋值和拷贝</h3><p>我们可以拷贝或赋值一个将要销毁的unique_ptr</p><p>例如： <code>return unique_ptr&lt;int&gt;&lt;new int(p)&gt;</code></p><h3 id="赋值和拷贝-2">赋值和拷贝</h3><p><strong>自定义销毁操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span> </span>&#123;<span class="built_in">disconnect</span>(*p);&#125;   <span class="comment">//定义自己的释放</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(destination &amp;d)</span></span>&#123;</span><br><span class="line">  connection c = <span class="built_in">connect</span>(&amp;d);</span><br><span class="line">  <span class="function">unique_ptr&lt;connection,<span class="title">decltype</span><span class="params">(end_connection)</span>*&gt; <span class="title">p</span><span class="params">(&amp;c, end_connection)</span></span>;   <span class="comment">//当f退出时（即使是由于异常而退出），connection会被正确关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="weak-ptr类">weak_ptr类</h2><p>weak_ptr是一种不控制所指向对象生存周期的智能指针，它指向一个由shared_ptr管理的对象。当最后一个指向shared_ptr被销毁时，对象就会被释放。</p><p><strong>weak_ptr支持的常见操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">weak_ptr&lt;T&gt; w;           <span class="comment">//空weak_ptr</span></span><br><span class="line"><span class="function">weak_ptr&lt;T&gt; <span class="title">w</span><span class="params">(sp)</span></span>;       <span class="comment">//与shared_ptr指向相同对象的weak_ptr</span></span><br><span class="line">w = p                    <span class="comment">//p可以是一个shared_ptr或一个weak_ptr</span></span><br><span class="line">w.<span class="built_in">reset</span>()                <span class="comment">//将w置为空</span></span><br><span class="line">w.<span class="built_in">use_count</span>()            <span class="comment">//与w共享对象的shared_ptr的数量</span></span><br><span class="line">w.<span class="built_in">expired</span>()              <span class="comment">//如果w.use_count()为0，返回true，否则返回false</span></span><br><span class="line">w.<span class="built_in">lock</span>()                 <span class="comment">//如果expired为true，返回一个空shared_ptr；否则返回一个指向w的对象的shared_ptr</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><h2 id="直接管理内存">直接管理内存</h2><h3 id="分配">分配</h3><p>用new运算符分配内存，使用delete释放new分配的内存</p><p>int *p = new int;           //p指向一个动态分配的，未初始化的无名对象</p><p>string *ps = new string   //ps指向一个动态分配的空string</p><p><strong>直接初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *pi = <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1024</span>);</span><br><span class="line"></span><br><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="number">10</span>,<span class="string">&#x27;a&#x27;</span>);</span><br></pre></td></tr></table></figure><p><strong>使用列表初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; *pv = <span class="keyword">new</span> vector&lt;<span class="type">int</span>&gt;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure><p><strong>进行值初始化</strong>：在类型名后加一对空括号即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string *ps = <span class="keyword">new</span> <span class="built_in">string</span>();      <span class="comment">//初始为空string</span></span><br><span class="line"></span><br><span class="line">string *pi = <span class="keyword">new</span> <span class="built_in">int</span>();             <span class="comment">//初始化为0</span></span><br></pre></td></tr></table></figure><p><strong>动态分配的const对象</strong></p><p>//初始化为一个const int</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">const</span> <span class="built_in">int</span>(<span class="number">1024</span>);</span><br></pre></td></tr></table></figure><h3 id="释放内存">释放内存</h3><p>如果分配了内存没有释放，会造成内存空间耗尽，也称为内存泄漏。当内存耗尽时，就无法再重新分配内存。默认情况下当new无法再分配动态内存时，会抛出一个bad_alloc异常。我们可以添加nothrow来阻止它抛出异常，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p1 = <span class="keyword">new</span> <span class="type">int</span>;  <span class="comment">//如果分配失败，new抛出std::bad_alloc</span></span><br><span class="line"><span class="type">int</span> *p2 = <span class="built_in">new</span>(nothrow) <span class="type">int</span>;</span><br></pre></td></tr></table></figure><p><strong>释放格式：</strong></p><p>delete p;</p><p><strong>技巧：delete之后重置指针</strong></p><p>int *p(new int(43));     //p指向动态内存</p><p>auto q = p;                   //q和p指向相同的内存</p><p>delete p;                      //p和q均变为无效</p><p>p = nullptr;                   //指出p不再绑定到任何对象</p><h2 id="动态数组">动态数组</h2><p><strong>分配形式</strong>：</p><p>int *p = new int[get_size()];    //p指向第一个int</p><p><strong>类型别名</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Array[<span class="number">42</span>];       <span class="comment">//Array表示42个int的数组类型</span></span><br><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> Array;          <span class="comment">//等价于int *p = new int[42];</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>初始化</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *p = <span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>]();    <span class="comment">//10个值初始化为0</span></span><br><span class="line">string *p2 = <span class="keyword">new</span> string[<span class="number">10</span>]()    <span class="comment">//10个空string</span></span><br></pre></td></tr></table></figure><p><strong>释放</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> []p;</span><br></pre></td></tr></table></figure><h2 id="智能指针和动态数组">智能指针和动态数组</h2><h3 id="用unique-ptr管理动态数组">用unique_ptr管理动态数组</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>[]&gt; <span class="title">up</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>])</span></span>;</span><br><span class="line">up.<span class="built_in">release</span>();   <span class="comment">//自动delete []销毁其指针</span></span><br></pre></td></tr></table></figure><p><strong>支持的操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_ptr&lt;T[]&gt; <span class="title">u</span><span class="params">(p)</span></span>;       <span class="comment">//u指向p指向的动态数组</span></span><br><span class="line">u[i]                        <span class="comment">//返回数组位置i处的对象</span></span><br></pre></td></tr></table></figure><h3 id="shared-ptr管理动态数组">shared_ptr管理动态数组</h3><p>为了使用shared_ptr，必须提供一个删除器</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">shared_ptr&lt;int&gt; sp(new int[10], [](int *p)&#123;delet[] p&#125;)</span><br><span class="line">sp.reset();   //使用delete[] p;</span><br></pre></td></tr></table></figure><p><strong>局限：未定义下标运算符，且不支持指针的算术运算</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i!=<span class="number">10</span>; i++)&#123;</span><br><span class="line">  *(sp.<span class="built_in">get</span>() +i) = i; <span class="comment">//使用get获取动态数组的第一个元素的指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="allocator类">allocator类</h2><p>使用allocator可以先分配空间，后构造对象。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">allocate&lt;string&gt; alloc;               <span class="comment">//可以分配string的allocator对象</span></span><br><span class="line"><span class="keyword">auto</span> <span class="type">const</span> p = alloc.<span class="built_in">allocate</span>(n);     <span class="comment">//分配n个未初始化的string</span></span><br></pre></td></tr></table></figure><p><strong>常见操作</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;T&gt;a;         <span class="comment">//可以分配T类型的allocator对象</span></span><br><span class="line">a.<span class="built_in">allocate</span>(n);         <span class="comment">//分配一段原始的，未构造的内存，保存n个类型为n的对象</span></span><br><span class="line">a.<span class="built_in">deallocate</span>(p,n)      <span class="comment">//释放从T*指针p中地址开始的内存，n必须为p创建时的大小。前执行a.deallocate之前，必须对这块内存的每个对象调用destroy</span></span><br><span class="line">a.<span class="built_in">construct</span>(p, args)    <span class="comment">//p必须为类型为T*的指针，指向一块原始内存：args被传递给类型为T的构造函数</span></span><br><span class="line">a.<span class="built_in">destroy</span>()             <span class="comment">//p为T*类型的指针，此算法对p指向的对象执行析构函数</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">auto q = p;</span><br><span class="line">alloc.construct(q++,10,&#x27;c&#x27;);</span><br><span class="line">alloc.construct(q++,&quot;hi&quot;);</span><br></pre></td></tr></table></figure><p><strong>警告：</strong></p><p>不能在未构造对象的情况下使用原始内存</p><p><strong>销毁动态数组</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(q != p)&#123;</span><br><span class="line">  alloc.<span class="built_in">destroy</span>(--q);    <span class="comment">//释放真正构造的string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拷贝和填充未初始化内存的算法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//这些函数在给定目的位置创建元素，而不是由系统分配内存给它们</span><br><span class="line">uninitialized_copy(b,e,b2);     //从迭代器b和e指出的输入范围中拷贝元素到迭代器b2指定的未构造的原始内存中。b2指向的内存必须足够大，能容纳输入序列中元素的拷贝</span><br><span class="line">uninitialized_copy_n(b,n,b2) 从迭代器b指向的元素开始，拷贝n个元素到b2开始的内存中</span><br><span class="line">uninitialized_fill(b,e,t)    在迭代器b和e指定的原始内存中创建对象，对象的值均为t的拷贝</span><br><span class="line">uninitialized_fill_n(b,n,t)  从迭代器b指向的内存地址开始创建n个对象。b必须指向足够大的未构造的原始内存，能容纳给定数量的对象</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//假设有一个int的vector vi，希望将其内容拷贝到动态内存中</span></span><br><span class="line"><span class="comment">//分配比vi中元素所占用空间大一倍的动态内存</span></span><br><span class="line"><span class="keyword">auto</span> p = alloc.<span class="built_in">allocate</span>(vi.<span class="built_in">size</span>()*<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过拷贝vi中的元素来构造从p开始的元素</span></span><br><span class="line"><span class="keyword">auto</span> q = <span class="built_in">uninitialized_copy</span>(vi.<span class="built_in">begin</span>(), bi.<span class="built_in">end</span>(), p);</span><br><span class="line"></span><br><span class="line"><span class="comment">//将剩余元素初始化为42</span></span><br><span class="line"><span class="built_in">uninitialized_fill_n</span>(q,vi.<span class="built_in">size</span>(),<span class="number">42</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动态内存 </tag>
            
            <tag> 智能指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前缀和——找到含有相同数量 0 和 1 的最长连续子数组</title>
      <link href="/2021/09/12/qian-zhui-he-zhao-dao-han-you-xiang-tong-shu-liang-0-he-1-de-zui-chang-lian-xu-zi-shu-zu/"/>
      <url>/2021/09/12/qian-zhui-he-zhao-dao-han-you-xiang-tong-shu-liang-0-he-1-de-zui-chang-lian-xu-zi-shu-zu/</url>
      
        <content type="html"><![CDATA[<h1>问题描述</h1><p>给定一个二进制数组, 找到含有相同数量的 0 和 1 的最长连续子数组（的长度）。</p><p><strong>示例 1:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1]</span><br><span class="line">输出: 2</span><br><span class="line">说明: [0, 1] 是具有相同数量0和1的最长连续子数组。</span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>示例 1:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: [0,1,0]</span><br><span class="line">输出: 2</span><br><span class="line">说明: [0, 1] (或 [1, 0]) 是具有相同数量0和1的最长连续子数组。</span><br></pre></td></tr></table></figure><h1>先上代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">public:</span><br><span class="line">  <span class="type">int</span> <span class="title function_">findMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;&amp; nums)</span> &#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="type">int</span>,<span class="type">int</span>&gt; exist;    </span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt; <span class="title function_">prefix</span><span class="params">(nums.size()+<span class="number">1</span>)</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=nums.size(); ++i)&#123;</span><br><span class="line">    prefix[i] = prefix[i<span class="number">-1</span>] + (nums[i<span class="number">-1</span>]==<span class="number">0</span>?<span class="number">-1</span>:<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;=nums.size(); ++i)&#123;</span><br><span class="line">      <span class="keyword">if</span>(exist.count(prefix[i])) ans = max(ans,i-exist[prefix[i]]);<span class="comment">//若再次出现时，可直接计算出间隔距离，可能出现多组数据，取最大值即可</span></span><br><span class="line">      <span class="keyword">else</span> exist[prefix[i]] = i;   <span class="comment">//计算前缀和第一次出现的位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>思路</h1><p>如果把0替换为-1，若某个子数组含有相同数量的0和1，那么其和必为0。</p><p>利用前缀和是否等于0，可以在O(1)时间复杂度判断，从数组起始位置到当前位置是否含有相同数量的0和1</p><p>例如：</p><p><strong>给定二进制数组nums：0 1 0 0 1，假定数组长度为nums</strong></p><p>作相应的替换为：-1 1 -1 -1 1</p><h2 id="求其前缀和">求其前缀和</h2><p>假定：<code>vectorint prefix(n+1);</code>存储前缀和</p><p>计算前缀和的公式：<code>prefix[i] = prefix[i-1] + (nums[i-1]==0?1:1)</code>   //括号内为c语言三目运算符，nums[i-1]==0，则括号的值为-1,否则值为1</p><p>计算完毕，前缀和数组内容为：0 -1 0 -1 -2 -1</p><p><strong>从前缀和可以得到两个关键信息：</strong></p><blockquote><ol><li><p>若prefix[n] == 0</p><p>表示 nums[0]+nums[1]+nums[2]+…+nums[n-1]==0，即数组nums，0到n-1具有相同的0和1</p></li><li><p>若prefix[m]==prefix[n]</p><p>表示nums[m]+nums[m+1]+nums[m+2]+…+nums[n-1]==0</p><p>==我们只需求出前缀和中，值相同的两个元素间隔最长的距离即可，例如prefix[1]和prefix[5]就满足这个条件，因此该组数据的答案为5-1=4==</p></li></ol></blockquote><h2 id="利用map计算值相同的两个元素间隔最长的距离">利用map计算值相同的两个元素间隔最长的距离</h2><p>利用map记录前缀和第一次出现的位置，后续可以判断一个数是否在map里，若在里面，说明出现了值相同的两个元素，直接计算其间隔距离即可。可能存在多组数据，取最大值即可。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 前缀和 </tag>
            
            <tag> 最长连续子数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 并发与进程管理</title>
      <link href="/2021/09/11/linux-bing-fa-yu-jin-cheng-guan-li/"/>
      <url>/2021/09/11/linux-bing-fa-yu-jin-cheng-guan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="进程和程序的区别">进程和程序的区别</h2><p><strong>程序</strong></p><p>程序本质上是一系列二进制信息，这些信息描述了如何在运行时创建一个进程：</p><ul><li>二进制格式标识:每个程序文件都包含用于描述可执行文件格式的元信息。内核利用此信息来解释 文件中的其他信息。</li><li>机器语言指令。</li><li>程序入口地址:标识程序开始执行时的起始指令位置。</li><li>数据:程序文件包含的变量初始值和程序使用的字面量值(比如字符串)。</li></ul><span id="more"></span><ul><li>符号表及重定位表:描述程序中函数和变量的位置及名称。这些表格有多重用途，其中包括调试和 运行时的符号解析(动态链接)。</li><li>共享库和动态链接信息:程序文件所包含的一些字段，列出了程序运行时需要使用的共享库，以及 加载共享库的动态连接器的路径名。</li><li>其他信息:程序文件还包含许多其他信息，用以描述如何创建进程。</li></ul><p><strong>进程</strong></p><ul><li>进程是正在运行的程序的实例。是一个具有独立功能的程序，包含运行时所需的各种资源。</li><li>它是操作系统动态执行的基本单元，在传统的操作系统中，进程既是基本的分配单元，也是基本的 执行单元。</li><li>可以用一个程序来创建多个进程，进程是由内核定义的抽象实体，并为该实体分配用以执行程序的 各项系统资源。</li><li>从内核的角度看，进程由用户内存空间和一系列内核数据结构组成，其中用户内存空间包含了程序 <strong>代码</strong>及代码所使用的<strong>变量</strong>，而内核数据结构则用于<strong>维护进程状态</strong>信息。记录在内核数据结构中的信 息包括许多与<strong>进程相关的标识号(IDs)</strong>、<strong>虚拟内存表</strong>、<strong>打开文件的描述符表</strong>、<strong>信号传递及处理的 有关信息</strong>、<strong>进程资源使用及限制</strong>、<strong>当前工作目录</strong>和大量的其他信息。</li><li>对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始 运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。</li><li>在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。</li></ul><h2 id="单道和多道程序设计">单道和多道程序设计</h2><ul><li>单道程序，即在计算机内存中只允许一个的程序运行。</li><li>多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在管理程序控制下，相 互穿插运行，两个或两个以上程序在计算机系统中同处于开始到结束之间的状态, 这些程序共享计 算机系统资源。引入多道程序设计技术的根本目的是为了提高 CPU 的利用率。</li><li>对于一个单 CPU 系统来说，程序同时处于运行状态只是一种宏观上的概念，他们虽然都已经开始 运行，但就微观而言，任意时刻，CPU 上运行的程序只有一个。</li><li>在多道程序设计模型中，多个进程轮流使用 CPU。而当下常见 CPU 为纳秒级，1秒可以执行大约 10 亿条指令。由于人眼的反应速度是毫秒级，所以看似同时在运行。</li></ul><h2 id="并行和并发">并行和并发</h2><h3 id="并行">并行</h3><p>并行(parallel): 指在同一时刻，有多条指令在多个处理器上同时执行。</p><p><img src="/Users/wangjun/work/%E5%B9%B6%E8%A1%8C.png" alt="并行"></p><h3 id="并发">并发</h3><p>并发(concurrency): 指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行，使 得在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干 段，使多个进程快速交替的执行。</p><p><img src="/Users/wangjun/work/%E5%B9%B6%E5%8F%91.png" alt="并发"></p><h2 id="进程控制块（PCB）">进程控制块（PCB）</h2><p>为了管理进程，内核必须对每个进程所做的事情进行清楚的描述。内核为每个进程分配一个 PCB(Processing Control Block)进程控制块，维护进程相关的信息，Linux 内核的进程控制块是 task_struct 结构体。</p><p>Linux中的PCB包括以下信息：</p><ul><li>进程id:系统中每个进程有唯一的 id，用 pid_t 类型表示，其实就是一个非负整数</li><li>进程的状态:有就绪、运行、挂起、停止等状态</li><li>进程切换时需要保存和恢复的一些CPU寄存器</li><li>描述虚拟地址空间的信息</li><li>描述控制终端的信息</li><li>当前工作目录(Current Working Directory)</li><li>umask 掩码（创建文件或目录的默认权限）</li><li>文件描述符表，包含很多指向 file 结构体的指针</li><li>和信号相关的信息</li><li>用户 id 和组 id</li><li>会话(Session)和进程组</li><li>进程可以使用的资源上限(Resource Limit)</li></ul><p>5 <strong>进程的状态</strong></p><p>在三态模型 中，进程状态分为三个基本状态，即就绪态，运行态，阻塞态。在五态模型中，进程分为新建态、就绪 态，运行态，阻塞态，终止态。</p><ul><li>运行态:进程占有处理器正在运行</li><li>就绪态:进程具备运行条件，等待系统分配处理器以便运行。当进程已分配到除CPU以外的所有必 要资源后，只要再获得CPU，便可立即执行。在一个系统中处于就绪状态的进程可能有多个，通常 将它们排成一个队列，称为就绪队列</li><li>阻塞态:又称为等待(wait)态或睡眠(sleep)态，指进程不具备运行条件，正在等待某个事件的完成</li></ul><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E4%B8%89%E6%80%81%E6%A8%A1%E5%9E%8B.png" alt="三态模型" style="zoom:50%;" /><ul><li>新建态:进程刚被创建时的状态，尚未进入就绪队列</li><li>终止态:进程完成任务到达正常结束点，或出现无法克服的错误而异常终止，或被操作系统及有终 止权的进程所终止时所处的状态。进入终止态的进程以后不再执行，但依然保留在操作系统中等待 善后。一旦其他进程完成了对终止态进程的信息抽取之后，操作系统将删除该进程。</li></ul><h2 id="进程相关指令">进程相关指令</h2><h3 id="查看进程">查看进程</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ps aux / ajx </span><br><span class="line">a:显示终端上的所有进程，包括其他用户的进程 </span><br><span class="line">u:显示进程的详细信息 </span><br><span class="line">x:显示没有控制终端的进程 </span><br><span class="line">j:列出与作业控制相关的信息</span><br></pre></td></tr></table></figure><p>STAT参数意义:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">D 不可中断 Uninterruptible(usually IO)</span><br><span class="line">R 正在运行，或在队列中的进程</span><br><span class="line">S 处于休眠状态</span><br><span class="line">T 停止或被追踪</span><br><span class="line">Z 僵尸进程</span><br><span class="line">W 进入内存交换(从内核2.6开始无效)</span><br><span class="line">X 死掉的进程</span><br><span class="line">&lt; 高优先级</span><br><span class="line">N 低优先级</span><br><span class="line">s 包含子进程</span><br><span class="line">+ 位于前台的进程组</span><br></pre></td></tr></table></figure><h3 id="实时进程动态">实时进程动态</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p>可以在使用 top 命令时加上 -d 来指定显示信息更新的时间间隔，在 top 命令执行后，可以按以下按键 对显示的结果进行排序:</p><ul><li>M 根据内存使用量排序</li><li>P 根据 CPU 占有率排序</li><li>T 根据进程运行时间长短排序</li><li>U 根据用户名来筛选进程</li><li>K 输入指定的 PID 杀死进程</li></ul><h3 id="杀死进程">杀死进程</h3><p>kill并不是去杀死一个进程，而是给进程发送某个信号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill [-signal] pid</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kill –l 列出所有信号</span><br><span class="line">kill –SIGKILL 进程ID</span><br><span class="line">kill -9 进程ID</span><br><span class="line">killall name 根据进程名杀死进程</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">kill –l</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">输入上述密令的执行结果为：</span></span><br><span class="line"> 1) SIGHUP 2) SIGINT 3) SIGQUIT 4) SIGILL 5) SIGTRAP</span><br><span class="line"> 6) SIGABRT 7) SIGBUS 8) SIGFPE 9) SIGKILL10) SIGUSR1</span><br><span class="line">11) SIGSEGV12) SIGUSR213) SIGPIPE14) SIGALRM15) SIGTERM</span><br><span class="line">16) SIGSTKFLT17) SIGCHLD18) SIGCONT19) SIGSTOP20) SIGTSTP</span><br><span class="line">21) SIGTTIN22) SIGTTOU23) SIGURG24) SIGXCPU25) SIGXFSZ</span><br><span class="line">26) SIGVTALRM27) SIGPROF28) SIGWINCH29) SIGIO30) SIGPWR</span><br><span class="line">31) SIGSYS34) SIGRTMIN35) SIGRTMIN+136) SIGRTMIN+237) SIGRTMIN+3</span><br><span class="line">38) SIGRTMIN+439) SIGRTMIN+540) SIGRTMIN+641) SIGRTMIN+742) SIGRTMIN+8</span><br><span class="line">43) SIGRTMIN+944) SIGRTMIN+1045) SIGRTMIN+1146) SIGRTMIN+1247) SIGRTMIN+13</span><br><span class="line">48) SIGRTMIN+1449) SIGRTMIN+1550) SIGRTMAX-1451) SIGRTMAX-1352) SIGRTMAX-12</span><br><span class="line">53) SIGRTMAX-1154) SIGRTMAX-1055) SIGRTMAX-956) SIGRTMAX-857) SIGRTMAX-7</span><br><span class="line">58) SIGRTMAX-659) SIGRTMAX-560) SIGRTMAX-461) SIGRTMAX-362) SIGRTMAX-2</span><br><span class="line">63) SIGRTMAX-164) SIGRTMAX</span><br></pre></td></tr></table></figure><p>数字9为SIGKILL</p><p><code>kill –SIGKILL 进程ID</code> 和 <code>kill -9 进程ID</code>等价，也可根据名字来杀死进程：<code>killall name 根据进程名杀死进程</code></p><h3 id="进程号相关函数">进程号相关函数</h3><p>每个进程都由进程号来标识，其类型为 pid_t(整型)，进程号的范围:0~32767。进程号总是唯一</p><p>的，但可以重用。当一个进程终止后，其进程号就可以再次使用。<br>任何进程(除 init 进程)都是由另一个进程创建，该进程称为被创建进程的父进程，对应的进程号称为</p><p>父进程号(PPID)。 进程组是一个或多个进程的集合。他们之间相互关联，进程组可以接收同一终端的各种信号，关联的进</p><p>程有一个进程组号(PGID)。默认情况下，当前的进程号会当做当前的进程组号。 进程号和进程组相关函数:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pid_t getpid(void);</span><br><span class="line">pid_t getppid(void);</span><br><span class="line">pid_t getpgid(pid_t pid);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;进程号&quot;</span>&lt;&lt;<span class="built_in">getpid</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;父进程号&quot;</span>&lt;&lt;<span class="built_in">getppid</span>()&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;9568进程组号&quot;</span>&lt;&lt;<span class="built_in">getpgid</span>(<span class="number">9568</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">执行结果：</span><br><span class="line">进程号<span class="number">10246</span></span><br><span class="line">父进程号<span class="number">32628</span></span><br><span class="line"><span class="number">9568</span>进程组号<span class="number">9568</span></span><br></pre></td></tr></table></figure><h3 id="进程创建">进程创建</h3><p>系统允许一个进程创建新进程，新进程即为子进程，子进程还可以创建新的子进程，形成进程树结构模型。除了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span> </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">pid_t</span> <span class="title">fork</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>返回值:<br>成功:子进程中返回 0，父进程中返回子进程 ID 失败:返回 -1</p><p>失败的两个主要原因:<br>当前系统的进程数已经达到了系统规定的上限，这时 errno 的值被设置为 EAGAIN 系统内存不足，这时 errno 的值被设置为 ENOMEM</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    Linux下创建子进程实例</span></span><br><span class="line"><span class="comment">    #include &lt;sys/types.h&gt;</span></span><br><span class="line"><span class="comment">    #include &lt;unistd.h&gt;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    pid_t fork(void);</span></span><br><span class="line"><span class="comment">        函数的作用：用于创建子进程。</span></span><br><span class="line"><span class="comment">        返回值：</span></span><br><span class="line"><span class="comment">            fork()的返回值会返回两次。一次是在父进程中，一次是在子进程中。</span></span><br><span class="line"><span class="comment">            在父进程中返回创建的子进程的ID,</span></span><br><span class="line"><span class="comment">            在子进程中返回0</span></span><br><span class="line"><span class="comment">            如何区分父进程和子进程：通过fork的返回值。</span></span><br><span class="line"><span class="comment">            在父进程中返回-1，表示创建子进程失败，并且设置errno</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        父子进程之间的关系：</span></span><br><span class="line"><span class="comment">        区别：</span></span><br><span class="line"><span class="comment">            1.fork()函数的返回值不同</span></span><br><span class="line"><span class="comment">                父进程中: &gt;0 返回的子进程的ID</span></span><br><span class="line"><span class="comment">                子进程中: =0</span></span><br><span class="line"><span class="comment">            2.pcb中的一些数据</span></span><br><span class="line"><span class="comment">                当前的进程的id pid</span></span><br><span class="line"><span class="comment">                当前的进程的父进程的id ppid</span></span><br><span class="line"><span class="comment">                信号集</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        共同点：</span></span><br><span class="line"><span class="comment">            某些状态下：子进程刚被创建出来，还没有执行任何的写数据的操作</span></span><br><span class="line"><span class="comment">                - 用户区的数据</span></span><br><span class="line"><span class="comment">                - 文件描述符表</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">        父子进程对变量是不是共享的？</span></span><br><span class="line"><span class="comment">            - 刚开始的时候，是一样的，共享的。如果修改了数据，不共享了。</span></span><br><span class="line"><span class="comment">            - 读时共享（子进程被创建，两个进程没有做任何的写的操作），写时拷贝。</span></span><br><span class="line"><span class="comment">        </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> num = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是父进程还是子进程</span></span><br><span class="line">    <span class="keyword">if</span>(pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// printf(&quot;pid : %d\n&quot;, pid);</span></span><br><span class="line">        <span class="comment">// 如果大于0，返回的是创建的子进程的进程号，当前是父进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am parent process, pid : %d, ppid : %d\n&quot;</span>, <span class="built_in">getpid</span>(), <span class="built_in">getppid</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num : %d\n&quot;</span>, num);</span><br><span class="line">        num += <span class="number">10</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;parent num += 10 : %d\n&quot;</span>, num);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 当前是子进程</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i am child process, pid : %d, ppid : %d\n&quot;</span>, <span class="built_in">getpid</span>(),<span class="built_in">getppid</span>());</span><br><span class="line">       </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num : %d\n&quot;</span>, num);</span><br><span class="line">        num += <span class="number">100</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;child num += 100 : %d\n&quot;</span>, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// for循环</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;i : %d , pid : %d\n&quot;</span>, i , <span class="built_in">getpid</span>());</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实际上，更准确来说，Linux 的 fork() 使用是通过写时拷贝 (copy- on-write) 实现。</span></span><br><span class="line"><span class="comment">    写时拷贝是一种可以推迟甚至避免拷贝数据的技术。</span></span><br><span class="line"><span class="comment">    内核此时并不复制整个进程的地址空间，而是让父子进程共享同一个地址空间。</span></span><br><span class="line"><span class="comment">    只用在需要写入的时候才会复制地址空间，从而使各个进行拥有各自的地址空间。</span></span><br><span class="line"><span class="comment">    也就是说，资源的复制是在需要写入的时候才会进行，在此之前，只有以只读方式共享。</span></span><br><span class="line"><span class="comment">    注意：fork之后父子进程共享文件，</span></span><br><span class="line"><span class="comment">    fork产生的子进程与父进程相同的文件文件描述符指向相同的文件表，引用计数增加，共享文件偏移指针。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 并发 </tag>
            
            <tag> 进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>归并排序原理</title>
      <link href="/2021/09/11/gui-bing-pai-xu-yuan-li/"/>
      <url>/2021/09/11/gui-bing-pai-xu-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>归并排序属于分治法思想，归并排序完全遵循分治模式。直观上其操作如下：</p><ul><li>分解：分解待排序的n个元素成各具n/2个元素的两个子序列。</li><li>解决：使用归并排序递归地排序两个子序列。</li><li>合并：合并两个已排序的子序列以产生已排序的数组。</li></ul><p>核心函数有两个，merge(A,p,q,r)：将已经有序的序列 A[p…q]和A[q+1,r] 合并为一个有序序列。</p><span id="more"></span><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> p, <span class="type">int</span> q, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n1 = q - p + <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> n2 = r - q;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">L</span><span class="params">(n1 + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">R</span><span class="params">(n2 + <span class="number">1</span>)</span></span>;</span><br><span class="line">    L[n1] = INT_MAX;</span><br><span class="line">    R[n2] = INT_MAX;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n1; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        L[i] = A[p + i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n2; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        R[i] = A[q + i + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = p; k &lt;= r; ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (L[i] &lt;= R[j])</span><br><span class="line">        &#123;</span><br><span class="line">            A[k] = L[i];</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            A[k] = R[j];</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> p,<span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;r)&#123;</span><br><span class="line">        <span class="type">int</span> q = (p+r)&gt;&gt;<span class="number">1</span>;   <span class="comment">// (p+r)/2</span></span><br><span class="line">        <span class="built_in">merge_sort</span>(A,p,q);</span><br><span class="line">        <span class="built_in">merge_sort</span>(A,q<span class="number">+1</span>,r);</span><br><span class="line">        <span class="built_in">merge</span>(A,p,q,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; A&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="built_in">merge_sort</span>(A,<span class="number">0</span>,A.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:A)&#123;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分治法时间复杂度分析">分治法时间复杂度分析</h2><p>假设 T(n) 是规模为 n 的一个问题的运行时间。把原问题分解为 a 个子问题，每个子问题的规模为原问题的 1/b（对于归并排序，a和b都是2）。为了求解一个规模为 n/b 的子问题，需要 T(n/b)，所以需要<strong>aT(n/b)的时间来求解a个子问题</strong>。如果<strong>分解问题成子问题需要时间 D(n)</strong>，<strong>合并子问题为原问题的解需要时间 C(n)</strong>，那么得到以下递归式：<strong>T(n) = aT(n/b) + D(n) + C(n)</strong></p><h2 id="归并排序算法">归并排序算法</h2><h3 id="时间复杂度">时间复杂度</h3><p>分解：只需计算数组中间的下标位置，需要常量时间，D(n) = O(1)</p><p>解决：我们递归地求解两个规模为 n/2 的子为题，将产生 2T(n/2) 的时间</p><p>合并：排序两个有序数组，需要线性时间，C(n) =Θ(n)，为什么这里用Θ，而不用 O，因为 O(n)还包括常数时间，Θ(n)不包括常数时间。</p><p><strong>T(n) = Θ(1)</strong>  当n==1</p><p><strong>T(n) = 2T(n/2) + Θ(n)</strong>  当 n &gt;1</p><p>以下为 T(n)的递归树：</p><p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/IMG_082FCEFC406D-1.jpeg" alt="IMG_082FCEFC406D-1"></p><p>顶层具有总代价 cn，下一层具有总代价 c(n/2)+c(n/2) == cn，下一层的下一层具有总代价 c(n/4)+c(n/4)+c(n/4)+c(n/4) == cn。总的来说，递归树每一层的代价都为 cn</p><p>递归树的总的层数为 lgn+1，其中 n是叶数，对应输入规模。总的代价为 cn( lgn+1) = cn$\lg n$​+cn。忽略低阶项和常量 c，最终归并排序的时间复杂度为 O(n lgn)。</p><h3 id="空间复杂度">空间复杂度</h3><p>递归树的深度为 lgn+1，每次递归使用常量空间 O(1)</p><p>使用两个零时数组，空间复杂度为 O(n)</p><p>所以总的空间复杂度为 O(n + 1*(lgn+1) )，忽略低阶项和常数项 1，最终空间复杂度为 O(n)</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 归并排序 </tag>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 权限管理</title>
      <link href="/2021/09/10/linux-quan-xian-guan-li/"/>
      <url>/2021/09/10/linux-quan-xian-guan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux系统中用户和权限">Linux系统中用户和权限</h2><p>三种不同类型的用户：文件拥护者（user），同组用户（group），可以访问系统的其他用户（others）。<br>三种访问文件或目录的方式：可读文件（r），可写文件（w），可执行文件（x）。</p><p>在shell环境中执行ls -la 输出当前目录的详细信息</p><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mygit@ubuntu:~/code$ ls -la</span><br><span class="line">total 148</span><br><span class="line">drwxr-xr-x 24 mygit mygit 4096 Apr  3 02:53 .</span><br><span class="line">drwxr-xr-x 24 mygit mygit 4096 Apr  9 12:20 ..</span><br><span class="line">drwxr-xr-x  3 mygit mygit 4096 Apr  2 20:49 auto_complete</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>total 148</strong></p><blockquote><p>表示当前目录下有148个文件或目录</p></blockquote><p><strong>drwxr-xr-x  3 mygit mygit 4096 Apr  2 20:49 auto_complete</strong></p><blockquote><ol><li><p>drwxr-xr-x表示文件类型和<strong>用户权限</strong></p><p>第1个字符表示文件类型：</p><ul><li>d：目录</li><li>-: 普通文件</li><li>l ：连接文件</li><li>b：块设备文件</li><li>c：字符设备文件</li><li>p：管道文件</li><li>s：套接字文件</li></ul><p>后面9个字符代表相应用户对该文件的权限：r:读权限  w:写权限  x:执行权限  -无权限</p><p>有权限用1表示，无用0表示，rwx代表最高权限，用二进制数表示为111，即八进制7，—代表无权限，用000表示，即八进制0。</p><ul><li>rwx 111 7</li><li>r-- 011 3</li><li>rw- 001 1</li><li>-w- 010 2</li></ul><p>前三个：文件所属用户；中间三个：文件所属组；后三个：其他用户</p></li><li><p>数字3</p><p>表示目录中文件数目或文件的硬连接数</p></li><li><p>mygit mygit</p><p>分别表示文件所属用户名，文件所属组名</p></li><li><p>数字4096</p><p>对于普通文件：表大小；对于目录：包含的文件名所占据的大小（4096的整数倍，至少4096）</p></li><li><p>Apr  2 20:49</p><p>修改日期</p></li><li><p>auto_complete</p><p>文件名或目录名</p></li></ol></blockquote><h2 id="常用命令">常用命令</h2><h3 id="chmod（控制文件或目录的访问权限）">chmod（控制文件或目录的访问权限）</h3><p>使用方式：chmod 参数  文件名/路径名</p><table><thead><tr><th>选项</th><th>说明</th></tr></thead><tbody><tr><td>-c</td><td>若该文件权限与目录确实已经更改，才显示其更改动作</td></tr><tr><td>-f</td><td>若该文件权限与目录无法被更改也不要显示错误讯息</td></tr><tr><td>-v</td><td>显示权限变更的详细资料</td></tr><tr><td>-R</td><td>对当前目录下的所有文件与目录进行相同的权限变更</td></tr><tr><td>–help</td><td>显示辅助说明</td></tr><tr><td>–version</td><td>显示版本</td></tr></tbody></table><h4 id="字符表示法">字符表示法</h4><p>chmod [u g o a] [= + -] [r w x]，字符间不加空格：</p><p>例如：<code>chmod u-x,g-w,o+r t1.txt</code></p><blockquote><p>取消文件所属用户的执行权限，取消文件所属组的读权限，赋予其他用户读权限</p></blockquote><table><thead><tr><th>字符</th><th>说明</th></tr></thead><tbody><tr><td>a (all)</td><td>所有用户</td></tr><tr><td>u(user)</td><td>文件所属用户</td></tr><tr><td>g(group)</td><td>文件所属组</td></tr><tr><td>o(other)</td><td>其它用户</td></tr><tr><td>=</td><td>该用户将只有一种权限</td></tr><tr><td>-</td><td>减去某种权限</td></tr><tr><td>+</td><td>增加某种权限</td></tr><tr><td>r</td><td>读权限</td></tr><tr><td>w</td><td>写权限</td></tr><tr><td>x</td><td>可执行权限</td></tr></tbody></table><h4 id="八进制表示法">八进制表示法</h4><p>使用三位八进制数字分别代表文件拥有者用户，同组用户，其它用户的权限，读，写，执行权限所对应的数值分别是4，2和1。若要表示rwx属性，则4+2+1=7；若要表示rw-属性，则4+2+0=6；若要表示r-x属性，则4+0+1=5。</p><p>例如：<code>chmod -R 777 test</code>  递归赋予test及其子目录文件读写执行权限。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 权限管理 </tag>
            
            <tag> chmod </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法分析渐近记号</title>
      <link href="/2021/09/10/suan-fa-fen-xi-jian-jin-ji-hao/"/>
      <url>/2021/09/10/suan-fa-fen-xi-jian-jin-ji-hao/</url>
      
        <content type="html"><![CDATA[<p>当输入规模足够大，使得运行时间只与增长量级有关时，需要研究算法的渐近效率。也就是，当输入规模无限增加时，在极限中，算法的运行时间如何随着输入规模的变大而增加。本文中所用插图来自《算法导论》。</p><p>不同的记号从不同的方面来刻画一个算法的运行效率。将插入排序的最坏运行时间刻画为下式：</p><span id="more"></span><p><strong>f(n) = an<sup>2</sup>+bn+c</strong>，其中 a,b,c为常量，n为输入规模。下面针对插入排序最坏运行时间<strong>f(n)</strong> 来展开讨论<br>根据与 f(n) 的大小关系，可分为 “==”, “&gt;=” “&gt;” “&lt;=” “&lt;” 共5种记号，分别为 ：</p><ul><li>Θ（西塔） “==”</li><li>O （大o） “&gt;=”</li><li>o（小欧）“&gt;”</li><li>Ω（大欧米伽）“&lt;=”</li><li>ω（小欧米伽）</li></ul><h2 id="Θ（西塔）渐近紧确界">Θ（西塔）渐近紧确界</h2><p>c<sub>1</sub>，c<sub>2</sub>为某个正常量，当n大于某一值时满足 <strong>0 &lt;= c<sub>1</sub>g(n) &lt;=  f(n) &lt;= c<sub>2</sub>g(n)</strong>，</p><p>插入排序最坏运行时间刻画为下式：<strong>f(n) = an<sup>2</sup>+bn+c</strong></p><p>最坏运行时间：T(n) == Θ(g(n)) == Θ(n<sup>2</sup>)。一个渐近正函数的低阶项在确定渐近确界时可以被忽略，因为对很大的 n，它们是无足轻重的，当 n 较大时，高阶项的一个很小的部分足以支配所有的低阶项。</p><p>如下图所示：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-08-27%20%E4%B8%8B%E5%8D%886.35.40.png" alt="截屏2021-08-27 下午6.35.40" style="zoom:50%;" /><h2 id="O-（大o）上界">O （大o）上界</h2><p>c 为某个正常量，当n大于某一值时满足   <strong>cg(n) &lt;=  f(n)</strong></p><p>插入排序最坏运行时间刻画为下式：<strong>f(n) = an<sup>2</sup>+bn+c</strong></p><p>最坏运行时间 <strong>T(n) == O(g(n)) == O(n<sup>2</sup>)</strong></p><p>如下图所示：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-08-27%20%E4%B8%8B%E5%8D%886.44.56.png" alt="截屏2021-08-27 下午6.44.56" style="zoom:50%;" /><h2 id="o（小欧）非渐近紧确的上界">o（小欧）非渐近紧确的上界</h2><p>任意正常量 c ，当 n 大于某w一值时，满足 **f(n)&gt;cg(n) **</p><p>例如某个算法运行时间刻画为下式： <strong>f(n) = 2n</strong></p><p>算法运行时间：<strong>T(n) == o(g(n)) == o(n<sup>2</sup>)</strong></p><p>O 和 o 的区别：</p><p>f(n) = O(g(n))，  0 =&lt; f(n) &lt;= cg(n) 对某个大于 0 的常量 c 决定。</p><p>f(n) = o(g(n))， 0 =&lt; f(n) &lt;= cg(n) 对于所有大于 0 的常量 c成立。</p><h2 id="Ω（大欧米伽）下界">Ω（大欧米伽）下界</h2><p>O 记号提供了一个函数的渐近上界，Ω记号提供了渐近下界。</p><p>c 为某个正常量，当 n 大于某个值时，满足 <strong>0&lt; c(g(n)) &lt; f(n)</strong></p><p>算法运行时间：<strong>T(n) == o(g(n)) == o(n<sup>2</sup>)</strong></p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-08-27%20%E4%B8%8B%E5%8D%886.59.57.png" alt="截屏2021-08-27 下午6.59.57" style="zoom:50%;" /><h2 id="ω（小欧米伽）非渐近紧确的下界">ω（小欧米伽）非渐近紧确的下界</h2><p>ω 记号 和 Ω 记号 的关系类似于 o 记号和 O 记号的关系。</p><p>对任意的正常量 c，当 n 大于某个值时，满足   <strong>0 &lt; cg(n) &lt; f(n)</strong></p><p>算法运行时间：<strong>T(n) == o(g(n))</strong></p><h2 id="Θ-和-O-的关系">Θ 和 O 的关系</h2><p>**当只有一个渐近上界时，使用 O 记号。注意：f(n)=Θ(g(n))蕴涵着f(n)=O(g(n))，因为 Θ 是一个比 O 记号更强的概念，按照集合论中的写法，就是 Θ(g(n)) ⊆O(g(n)) ，关于任意二次函数an<sup>2</sup>+bn+c，其中 a&gt;0，用Θ(n<sup>2</sup>)表示，任意这样的二次函数也在O(n<sup>2</sup>)中。更加让人惊讶的是，当 a&gt;0时，任意线性函数 an+b 也在 O(n<sup>2</sup>)中   **</p><p><strong>既然 O 记号描述上界，那么当它用来限制算法的最坏运行情况运行时间时，关于算法的每个输入上的运行时间，我们也有一个界。因此，对插入排序的最坏情况运行时间的界O(n<sup>2</sup>)也适用于该算法的每个输入的运行时间。然而，对插入排序的最坏情况运行时间的界Θ(n<sup>2</sup>)并未暗示该算法对每个输入的运行时间也是Θ(n<sup>2</sup>)，例如 当输入已排好序时，插入排序的运行时间为 Θ(n)。</strong></p><p><strong>从技术上讲，称插入排序的运行时间为 O(n<sup>2</sup>)有点不合适，因为对给定的 n，实际的运行时间是变化的，依赖于规模为 n 的特定输入。当我们说“运行时间为  O(n<sup>2</sup>) 时” ，意指存在一个O(n<sup>2</sup>)的函数 f(n)，使得对 n 的任意值，不管选择什么特定规模为 n 的输入，其运行时间的上界都是 f(n)。这也就是说最坏情况运行时间为  O(n<sup>2</sup>)</strong></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法分析 </tag>
            
            <tag> 渐进符号 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MakeFile 基础教程</title>
      <link href="/2021/09/10/makefile-ji-chu-jiao-cheng/"/>
      <url>/2021/09/10/makefile-ji-chu-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1>Makefile 作用</h1><p>Makefile的作用为实现自动化编译，主要为了解决以下问题：</p><ul><li>有很多源文件需要编译时</li><li>当存在很多源文件时，只修改了个别源文件，这时只需要编译修改过的文件即可，而无需整个项目都编译一遍。</li><li>当多个源文件存在依赖关系时，需要先编译一些文件，后编译一些文件</li></ul><h1>Makefile安装</h1><span id="more"></span><p>要使用MakeFile，首先要按照make工具</p><p>在ubuntu18.0.4系统下，安装命令为：</p><p>sudo apt install build-essential</p><p>该命令会同时安装gcc/g++/make等工具</p><h1>Makefile文件命名和规则</h1><h2 id="文件命名">文件命名</h2><p>makefile或Makefile</p><h2 id="Makefile-规则">Makefile 规则</h2><p>一个 Makefile 文件中可以有一个或者多个规则</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">目标 ... : 依赖 ...</span><br><span class="line">命令（Shell 命令)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>目标：最终要生成的文件（伪目标除外）</p><p>依赖：生成目标所需要的文件或是目标</p><p>命令：通过执行命令对依赖操作生成目标（命令前必须 Tab 缩进）</p><p>Makefile 中的其它规则一般都是为第一条规则服务的。</p><h2 id="基本原理">基本原理</h2><p>1.命令在执行之前，需要先检查规则中的依赖是否存在</p><p>​a.如果存在，执行命令</p><p>​b.如果不存在，向下检查其它的规则，检查有没有一个规则是用来生成这个依赖的，如果找到了，则执行该规则中的命令</p><p>2.检测更新，在执行规则中的命令时，会比较目标和依赖文件的时间</p><p>​a.如果依赖的时间比目标的时间晚，需要重新生成目标</p><p>​b.如果依赖的时间比目标的时间早，目标不需要更新，对应规则中的命令不需要被执行</p><h2 id="变量">变量</h2><h3 id="自定义变量">自定义变量</h3><p>变量名=变量值</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var=hello</span><br><span class="line"><span class="comment">#获取变量的值 $(变量名)</span></span><br><span class="line"><span class="variable">$(var)</span></span><br></pre></td></tr></table></figure><h3 id="预定义变量">预定义变量</h3><p>AR : 归档维护程序的名称，默认值为 ar</p><p>CC : C 编译器的名称，默认值为 cc</p><p>CXX : C++ 编译器的名称，默认值为 g++</p><p>$@ : 目标的完整名称</p><p>$&lt; : 第一个依赖文件的名称</p><p>$^ : 所有的依赖文件</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">app:main.c a.c b.c</span></span><br><span class="line">gcc -c main.c a.c b.c -o app</span><br><span class="line"></span><br><span class="line"><span class="comment">#自动变量只能在规则的命令中使用</span></span><br><span class="line"><span class="section">app:main.c a.c b.c</span></span><br><span class="line"><span class="variable">$(CC)</span> -c <span class="variable">$^</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><h2 id="模式匹配">模式匹配</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">      gcc -c add.c</span><br><span class="line"><span class="section">div.o:div.c</span></span><br><span class="line">      gcc -c div.c</span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">      gcc -c sub.c</span><br><span class="line"><span class="section">mult.o:mult.c</span></span><br><span class="line">      gcc -c mult.c</span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line">      gcc -c main.c</span><br></pre></td></tr></table></figure><p>%.o:%.c</p><p>​%: 通配符，匹配一个字符串</p><p>​两个%匹配的是同一个字符串</p><p>%.o:%.c</p><p>​gcc -c $&lt; -o $@</p><h2 id="函数">函数</h2><p><strong>$(wildcard PATTERN…)</strong></p><ul><li><p>功能：获取指定目录下指定类型的文件列表</p></li><li><p>参数：PATTERN 指的是某个或多个目录下的对应的某种类型的文件，如果有多个目录，一般使用空格间隔</p></li><li><p>返回：得到的若干个文件的文件列表，文件名之间使用空格间隔</p></li><li><p>示例：获取 当前目录下和sub目录中所有的 c 源文件。</p><p>​$(wildcard *.c ./sub/*.c)</p><p>​返回值格式: a.c b.c c.c d.c e.c f.c</p></li></ul><p>$(patsubst &lt;pattern&gt;,&lt;replacement&gt;,&lt;text&gt;)</p><ul><li><p>功能：查找&lt;text&gt;中的单词(单词以“空格”、“Tab”或“回车”“换行”分隔)是否符合模式&lt;pattern&gt;，如果匹配的话，则以&lt;replacement&gt;替换。</p></li><li><p>&lt;pattern&gt;可以包括通配符<code>%</code>，表示任意长度的字串。如果&lt;replacement&gt;中也包含<code>%</code>，那么，&lt;replacement&gt;中的这个<code>%</code>将是&lt;pattern&gt;中的那个%所代表的字串。(可以用<code>\</code>来转义，以<code>\%</code>来表示真实含义的 % 字符)</p></li><li><p>返回：函数返回被替换过后的字符串列表，不更改任何文件</p></li><li><p>示例：将当前目录前所有的 .c 文件都替换为 .o 文件返回，</p><p>​$(patsubst %.c, %.o, x.c bar.c)</p><p>​返回值格式: x.o bar.o</p></li></ul><h1>Makefile实战</h1><h2 id="源文件">源文件</h2><p>├── add.c<br>├── main.c<br>├── math.h<br>└── subtract.c</p><p>文件内容分别为：</p><p>main.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a=%d b=%d\n&quot;</span>,a,b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a+b=%d\n&quot;</span>,add(a,b));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;a-b=%d\n&quot;</span>,subtract(a,b));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义头文件</p><p>math.h</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> math_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> math_h</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>头文件里两个函数的实现：</p><p>add.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>subtract.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;math.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">subtract</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不用Makefile">不用Makefile</h2><p>如果要生成可执行文件，需要编译main.c add.c subtract.c</p><p>编译命令为：</p><p>gcc main.c add.c subtract.c -o app</p><h2 id="用Makefile">用Makefile</h2><h3 id="第一版Makefile">第一版Makefile</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">app:main.c add.c subtract.c</span></span><br><span class="line">gcc main.c add.c subtract.c -o app</span><br></pre></td></tr></table></figure><h3 id="第二版Makefile">第二版Makefile</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">app:main.o add.o subtract.o</span></span><br><span class="line"></span><br><span class="line">    gcc main.o add.o subtract.o -o app</span><br><span class="line"></span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line"></span><br><span class="line">    gcc -c main.c -o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line"></span><br><span class="line">    gcc -c add.c -o add.o</span><br><span class="line"></span><br><span class="line"><span class="section">subtract.o:subtract.c</span></span><br><span class="line"></span><br><span class="line">    gcc -c subtract.c -o subtract.o</span><br></pre></td></tr></table></figure><h3 id="第三版Makefile">第三版Makefile</h3><p>#定义变量</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">src=subtract.o add.o main.o</span><br><span class="line"></span><br><span class="line">target=app</span><br><span class="line"></span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(src)</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(src)</span> -o <span class="variable">$(target)</span></span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line"></span><br><span class="line">    gcc -c add.c -o add.o</span><br><span class="line"></span><br><span class="line"><span class="section">subtract.o:subtract.c</span></span><br><span class="line"></span><br><span class="line">    gcc -c subtract.c -o subtract.o</span><br><span class="line"></span><br><span class="line"><span class="section">main.o:main.c</span></span><br><span class="line"></span><br><span class="line">    gcc -c main.c -o main.o</span><br></pre></td></tr></table></figure><h3 id="第四版Makefile">第四版Makefile</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#定义变量</span></span><br><span class="line"></span><br><span class="line">src=subtract.o add.o main.o</span><br><span class="line"></span><br><span class="line">target=app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(src)</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(src)</span> -o <span class="variable">$(target)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br></pre></td></tr></table></figure><h3 id="第五版Makefile">第五版Makefile</h3><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">src=<span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line"></span><br><span class="line">objs=<span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line">target=app</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将所有的.o 文件编译为可执行程序 </span></span><br><span class="line"><span class="variable">$(target)</span>:<span class="variable">$(objs)</span></span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(objs)</span> -o <span class="variable">$(target)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># $&lt; 表示第一个依赖项,$@ 表示目标，将所有的源文件编译为 .o 文件(目标文件，不进行链接)</span></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#clean为伪目标</span></span><br><span class="line"></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm <span class="variable">$(objs)</span> -f</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> makefile </tag>
            
            <tag> 编译 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++迭代实现二叉树遍历</title>
      <link href="/2021/09/08/c-er-cha-shu-bian-li-die-dai-shi-xian/"/>
      <url>/2021/09/08/c-er-cha-shu-bian-li-die-dai-shi-xian/</url>
      
        <content type="html"><![CDATA[<h1>递归的缺点</h1><p>二叉树的主要遍历方式有以下几种：</p><p>前序遍历：根- 左子树-右子树（<strong>前序遍历可以唯一确定一棵二叉树</strong>）</p><p>中序遍历：左子树-根-右子树（<strong>二叉搜索树使用此遍历可以从小大到大输出所有元素。</strong>）</p><p>后序遍历：左子树-右子树-根（<strong>结合中序遍历可以唯一确定一棵二叉树</strong>）</p><p>二叉树遍历最常见的，也是最简单的思路是使用递归算法。既然有了最简答的写法，为什么还有学习更复杂的迭代实现呢？主要是递归有以下缺点：</p><p>递归的本质是函数调用，对于大多数操作系统，每一次函数调用都是一个代价较高的过程，主要因为以下几个方面：</p><ul><li><p>性能上考虑：<strong>函数每一次调用都得往栈中压入函数返回地址，函数参数，以及为函数内的所有局部变量分配空间。每个进程的栈空间是有限的，递归层次太多，会导致往栈中存在太多数据，易导致栈溢出，进而程序崩溃。</strong></p></li><li><p>效率上考虑：<strong>当系统进行函数调用时，会向栈中压入函数返回地址，函数形参，为局部变量分配空间，当函数执行完毕时，需要进行弹栈(也称为清栈)操作使之与函数调用前一模一样，往栈中压入数据和弹出数据都需要时间，从某种程度上降低了程序的性能。</strong></p></li></ul><p>说了递归的缺点，现在说下迭代的好处：<strong>迭代没有函数调用所产生的额外开销，也没有压栈和弹栈操作，通常空间利用率更高，程序运行效率更好。</strong><br><code>系统 : ubuntu 18.04 64位</code></p><p><code>编程语言: c++</code></p><p><code>g++ 版本: g++ 8.4.0</code></p><span id="more"></span><p>节点定义：为了简化代码，省略了父节点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode *parent;     </span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>)&#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了封装二叉树的各种操作，我们创建一个二叉树类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BinaryTree</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode *root;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(TreeNode *node)</span></span>;                           <span class="comment">// 插入元素</span></span><br><span class="line">  <span class="function">TreeNode* <span class="title">treeBuild</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;tab, <span class="type">int</span> &amp;index, TreeNode *parent)</span>；     <span class="comment">// 构造二叉树</span></span></span><br><span class="line"><span class="function">    <span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode *root)</span></span>;                          <span class="comment">// 前序遍历(递归)</span></span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">preIteration</span><span class="params">(TreeNode *root)</span></span>;<span class="comment">// 前序遍历(迭代)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1>二叉树构造</h1><p>为了测试遍历代码的正确性，往往需要构建一棵二叉树。二叉树的构建方法主要有两种：</p><h2 id="前序遍历法">前序遍历法</h2><p>使用前序遍历可以唯一确定一棵二叉树，二叉树的前序遍历顺序：根-左子树-右子树，可以使用 vector 来存储二叉树的前序遍历，遍历序列中必须包含空子树标记。例如：现在给定一个前序遍历序列：<code>vector&lt;int&gt; pre&#123;4,2,1,NULL,NULL,3,NULL,NULL,5,NULL,NULL&#125;;</code> 可以根据前序遍历的步骤来构建二叉树。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode*</span></span><br><span class="line"><span class="function"><span class="title">BinaryTree::treeBuild</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;tab, <span class="type">int</span> &amp;index, TreeNode *parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *root = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; tab.<span class="built_in">size</span>() &amp;&amp; tab[index] != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(tab[index]);</span><br><span class="line">        root-&gt;parent = parent;</span><br><span class="line">        root-&gt;left = <span class="built_in">treeBuild</span>(tab, ++index, root);</span><br><span class="line">        root-&gt;right = <span class="built_in">treeBuild</span>(tab, ++index, root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="随机插入法">随机插入法</h2><p>此方法适用于二叉搜索树，一棵二叉搜索树的定义如下，若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值。二叉搜索树的所有子树都为二叉搜索树。</p><p>给定一组序列，使用二叉搜索树的插入方法，可以构建一棵有序的二叉树。次方法不必知道二叉树的结构。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">BinaryTree::insert</span><span class="params">(TreeNode *node)</span></span>&#123;</span><br><span class="line">    TreeNode *x = root;</span><br><span class="line">    TreeNode *y = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;val &lt; x-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        root = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (node-&gt;val &lt; y-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        y-&gt;left = node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        y-&gt;right = node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>前序遍历</h1><h2 id="递归法">递归法</h2><ul><li>递归的本质是自己调用自己，每一次调用都是输出当前子树的根节点值。</li><li>函数第一次调用时，root 为根节点，首先输出根节点值。</li><li>然后再递归调用左子树，右子树。这样就依次输出了左节点值，右节点。和前序遍历的要求一致：根-左-右</li></ul><p>递归本质是基于栈的回溯，即它在递归的时候，会在栈中记录所走的路径，回溯时输出节点值。可以看到递归法代码更加简洁，只需4行代码即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BinaryTree::preOrder</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 前序遍历，输出所有节点值</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">preOrder</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">preOrder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法">迭代法</h2><p>迭代的原理就是利用一个栈来记录路径，模拟函数调用的回溯。迭代法避免了函数调用产生的代价，具有更高的运行效率，但代码会更复杂一些。</p><ul><li>循环开始前，将根节点入栈。</li><li>每一次循环都先输出当前子树根节点值，弹出当前子树根节点 cur，然后再 cur 的右子树，左子树入栈。因为栈本身的特性，后到先服务。</li><li>再下一轮循环中，首先处理左子树，然后处理右子树。这样就满足前序遍历：根-左子树-右子树的要求。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">BinaryTree::preIteration</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// 前序遍历，输出所有节点值</span></span><br><span class="line">    stack&lt;TreeNode *&gt; s;</span><br><span class="line">    s.<span class="built_in">push</span>(root); </span><br><span class="line">    <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        TreeNode *p = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        cout&lt;&lt;p-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先将右节点入栈，后将左节点入栈，因为前序遍历，需要先访问左节点，再访问右节点</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(p-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>中序遍历</h1><h2 id="递归法-2">递归法</h2><p>只需改变输出根节点值的位置即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">BinaryTree::inOrder</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 中序遍历，输出所有节点值</span></span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;left);</span><br><span class="line">        cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">inOrder</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代法-2">迭代法</h2><p>中序遍历是；左-根-右。</p><ul><li>使用 cur 作为当前节点，循环开始前 cur 的值为根节点。</li><li>因为要先输出左子树，在循环开始，使用一个子循环将 当前节点 cur 的左孩子节点，左孩子的左孩子入栈，直到 cur 为空为止。</li><li>此时栈顶就是输出的第一个节点。弹出栈顶到 cur 中，并输出，将 cur 设置为它的右孩子，如果其右孩子存在的话，对其右子树执行相同的操作，就是找到最左边节点；如果 其右孩子为空，则 cur 也为空，在循环开始处不会有节点在进栈，此时弹出的当前节点 cur 就是最先输出节点的父节点，将该节点输出，然后将 cur 设置为其右孩子，对其右孩子执行相同的操作。这样就实现了回溯的功能。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">BinaryTree::inIteration</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 中序遍历输出所有节点值</span></span><br><span class="line">    stack&lt;TreeNode *&gt; s;</span><br><span class="line">    TreeNode* cur = root;</span><br><span class="line">    <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span> || !s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        cout&lt;&lt; cur-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        cur = cur-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>后序遍历</h1><h2 id="递归版本">递归版本</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">BinaryTree::postOrder</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 后续遍历输出所有节点值</span></span><br><span class="line">    <span class="keyword">if</span>(root!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="built_in">postOrder</span>(root-&gt;left);</span><br><span class="line">        <span class="built_in">postOrder</span>(root-&gt;right);</span><br><span class="line">        cout&lt;&lt;root-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代版本">迭代版本</h2><p>后续遍历的迭代版本会更加复杂一些。</p><ul><li>后序遍历: 左-右-根。输出左孩子简单，使用一个子循环就可以找到最左边孩子，重点是从右节点到根节点之后，需要判断它是否从右孩子回溯而来，如果是，则表示它的右孩子已经处理，可以处理根节点，如果不是回溯而来，则需要先处理它的右子树。</li><li>使用一个遍历 pre 来记录上一次访问的节点，这样就可以容易的判断当前节点是不是由右孩子回溯而来。</li><li>第一次循环：当前节点是根节点，pre 为空节点。使用一个子循环将当前节点 cur 的左孩子节点，左孩子的左孩子入栈，知道 cur 为空。</li><li>弹出栈顶元素到 cur，此时判断 cur 是否为回溯而来，只需判断 cur 的右孩子是否是 pre，不是则将 cur 再次入栈，并将 cur 的右孩子入栈，执行相同的操作。如果 cur 的右孩子为 pre，则表示 cur 是由 pre 回溯而来，当前 cur 作为当前子树的根节点，将 pre 设置为 cur，将 cur 设置为 空。在下一次循环中，就来到了上一层节点，实现了回溯的功能。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span></span></span><br><span class="line"><span class="function"><span class="title">BinaryTree::postIteration</span><span class="params">(TreeNode *root)</span></span>&#123;</span><br><span class="line">    stack&lt;TreeNode *&gt; s;</span><br><span class="line">    TreeNode *cur = root;</span><br><span class="line">    TreeNode *pre = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span>(cur || !s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">        <span class="keyword">while</span>(cur)&#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur);</span><br><span class="line">            cur = cur-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            cur = s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(cur-&gt;right==<span class="literal">nullptr</span> || pre == cur-&gt;right)&#123;</span><br><span class="line">                cout&lt;&lt;cur-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">                pre = cur;</span><br><span class="line">                cur = <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                s.<span class="built_in">push</span>(cur);</span><br><span class="line">                cur = cur-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>测试代码</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; pre&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="number">3</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>,<span class="number">5</span>,<span class="literal">NULL</span>,<span class="literal">NULL</span>&#125;;   <span class="comment">// 中序遍历，未用到</span></span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;tab &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    BinaryTree b;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> x:tab)&#123;</span><br><span class="line">        TreeNode *node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(x);</span><br><span class="line">        b.<span class="built_in">insert</span>(node);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;前序遍历(递归): &quot;</span>;</span><br><span class="line">    b.<span class="built_in">preOrder</span>(b.root);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;前序遍历(迭代): &quot;</span>;</span><br><span class="line">    b.<span class="built_in">preIteration</span>(b.root);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;中序遍历(递归): &quot;</span>;</span><br><span class="line">    b.<span class="built_in">inOrder</span>(b.root);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;中序遍历(迭代): &quot;</span>;</span><br><span class="line">    b.<span class="built_in">inIteration</span>(b.root);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;后序遍历(递归): &quot;</span>;</span><br><span class="line">    b.<span class="built_in">postOrder</span>(b.root);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;后续遍历(迭代): &quot;</span>;</span><br><span class="line">    b.<span class="built_in">postIteration</span>(b.root);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">前序遍历(递归): 1 3 2 6 4 5 </span><br><span class="line">前序遍历(迭代): 1 3 2 6 4 5 </span><br><span class="line">中序遍历(递归): 1 2 3 4 5 6 </span><br><span class="line">中序遍历(迭代): 1 2 3 4 5 6 </span><br><span class="line">后序遍历(递归): 2 5 4 6 3 1 </span><br><span class="line">后续遍历(迭代): 2 5 4 6 3 1 </span><br></pre></td></tr></table></figure><h1>编程练习</h1><p>学习完二叉树遍历方法，可以做题巩固一下，建议把递归和迭代都实现一遍。</p><ul><li><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal/">二叉树的前序遍历</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/">二叉树的中序遍历</a></li><li><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal/">二叉树的后序遍历</a></li></ul><h1>参考</h1><p><a href="http://icejoywoo.github.io/2020/03/31/binary-tree-traversal.html">http://icejoywoo.github.io/2020/03/31/binary-tree-traversal.html</a></p><p><a href="https://zhuanlan.zhihu.com/p/80578741">https://zhuanlan.zhihu.com/p/80578741</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 二叉树遍历 </tag>
            
            <tag> 迭代 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树的基本概念和实现</title>
      <link href="/2021/09/07/c-shi-xian-er-cha-sou-suo-shu-he-hong-hei-shu/"/>
      <url>/2021/09/07/c-shi-xian-er-cha-sou-suo-shu-he-hong-hei-shu/</url>
      
        <content type="html"><![CDATA[<p>本文包含以下内容：</p><ul><li><strong>二叉树概念</strong></li><li><strong>使用 C 语言 实现的二叉查找树的动态集合操作：</strong><ul><li><strong>构造：使用二叉树的前序遍历构造二叉树。</strong></li><li><strong>插入，删除，查询</strong></li><li><strong>前驱和后继</strong></li><li><strong>最大值和最小值</strong></li></ul></li><li><strong>红黑树的概念</strong></li></ul><span id="more"></span><ul><li><strong>使用 C++ 面向对象思想 实现的红黑树的动态集合操作：</strong><ul><li><strong>构造：使用二叉树的前序遍历构造二叉树。</strong></li><li><strong>左旋和右旋</strong></li><li><strong>插入</strong></li><li><strong>颜色修复</strong></li><li><strong>删除</strong><br>由于本文较长，可按目录选择自己需要的章节。因为用到初始化列表。 g++ 版本确保支持 c++11，所有代码在以下环境中调试通过。</li></ul></li></ul><p><code>系统 : ubuntu 18.04 64位</code></p><p><code>编程语言: c++</code></p><p><code>g++ 版本: g++ 8.4.0</code></p><h1>1、前言</h1><p>二叉查找树是最核心的数据结构之一，是程序员必须了解的数据结构，基于二叉搜索树改进的的 AVL树(自平衡二叉树)和红黑树具有更好的平均性能，更加广泛地被用于从数据结构到数据库等系统，c++ 中的 map、set、multimap、multiset 的底层实现基于红黑树。可以说，理解了二叉查找树，红黑树后，将对数据结构有更深入的理解，也能加深对 c++ 的理解。本博客将从二叉查找树开始讲起，然后过度到红黑树。红黑树也是二叉查找树，只是后者具有更好的性能。具体的差异，听我娓娓道来。</p><p>一棵二叉树可以为空，当它不为空时，若它的左子树不为空，它的所有左子树节点都小于根节点，若它的右子树不为空，则它的所有右子树节点值都大于根节点值，它的左子树和右子树分别都是二叉排序树。<strong>二叉搜索树可以快速地进行插入和删除操作，又具有快速查找的能力</strong>，被广泛地用在文件系统或数据库系统，因为这些系统需要高效的检索能力。</p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E4%B8%8B%E8%BD%BD.png" alt="下载"  /><p>二叉搜索树可以存储一组有序的序列，如上图所示。通过二叉树的前序遍历，可以从小到大输出所有数据元素。二叉查找树能高效地完成许多动态集合操作，例如：<strong>查找，获取最大值，获取最小值，获取元素的前驱和后继，插入，删除</strong>等。二叉查找树的这些操作和它的高度成正比，对于含有 n 个节点的完全二叉树来说，这些操作的时间复杂度为 O($lg n$​)，最坏情况下，n 个节点的二叉搜索树的深度为 n 时行成了一个单链表，因为需要遍历所有节点，此时这些操作的时间复杂度为 O(n)。</p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-09-02%20%E4%B8%8B%E5%8D%8811.57.56.png" alt="截屏2021-09-02 下午11.57.56" style="zoom: 50%;" /><p>为了克服二叉搜索树的最坏情况，即为单链表的情况，下图为 AVL树(自平衡二叉查找树树)，它的任何节点的两个子树的高度差最大为1。二叉查找树的性能和二叉树的深度成正比，平衡二叉树的深度为 O(lg n)级别，它的查找时间复杂度为 O(lg n)。接下来讲解红黑树，它实现的功能和二叉搜索树一样，但它确有更好的平均性能，因为它近乎平衡二叉树，它的<strong>查找，获取最大值，获取最小值，插入，删除</strong>等操作都能在 O(lg n) 能完成。</p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-09-03%20%E4%B8%8A%E5%8D%8812.07.07.png" alt="截屏2021-09-03 上午12.07.07" style="zoom:50%;" /><h1>2、二叉搜索树</h1><p>以下代码，使用 c++ 实现。</p><p>二叉树节点的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">     <span class="type">int</span> val;</span><br><span class="line">     TreeNode *left;</span><br><span class="line">     TreeNode *right;</span><br><span class="line">     TreeNode *parent;</span><br><span class="line">     <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>),<span class="built_in">parent</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="comment">// 下面是一些初始化函数，有些可能不常用</span></span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>),<span class="built_in">parent</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right),<span class="built_in">parent</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">     <span class="built_in">TreeNode</span>(<span class="type">int</span> x, TreeNode *left, TreeNode *right,TreeNode * parent) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(left), <span class="built_in">right</span>(right),<span class="built_in">parent</span>(parent) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BinaryTree</span>   <span class="comment">// 二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode *root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>二叉树的遍历常见的有以下 3 种，统称为深度优先遍历。</p><p>前序遍历：根结点 —&gt; 左子树 —&gt; 右子树</p><p>中序遍历：左子树—&gt; 根结点 —&gt; 右子树</p><p>后序遍历：左子树 —&gt; 右子树 —&gt; 根结点</p><p>除了上述 3 种方法外，还有层次遍历方法，称为广度优先遍历。</p><p>二叉查找树的 3 种遍历方法，可以使用简单递归思想来实现。</p><h2 id="2-1-二叉树构造">2.1 二叉树构造</h2><p>注意：使用前序遍历可以唯一确定一棵二叉树，但前序和后序遍历不行，因为前序无法确定根节点，后续遍历无法确定左子树节点，但是前序和后续结合起来就可以唯一确定一棵二叉树。</p><p>根据前序遍历构造二叉树代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">treeBuild</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;tab, <span class="type">int</span> &amp;index, TreeNode *parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *root = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;tab.<span class="built_in">size</span>() &amp;&amp; tab[index]!=<span class="number">0</span>)&#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(tab[index]);</span><br><span class="line">        root-&gt;parent = parent;</span><br><span class="line">        root-&gt;left = <span class="built_in">treeBuild</span>(tab, ++index,root);</span><br><span class="line">        root-&gt;right = <span class="built_in">treeBuild</span>(tab, ++index,root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用中序遍历可以从小到大打印所有元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉查找树的中序遍历 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* tree)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(tree!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(tree-&gt;left);</span><br><span class="line">    cout&lt;&lt;tree-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(tree-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过改变输出节点值代码的位置，可以得到前序遍历和后序列遍历。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉查找树的前序遍历 </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* tree)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(tree!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    cout&lt;&lt;tree-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(tree-&gt;left);</span><br><span class="line">    <span class="built_in">dfs</span>(tree-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二叉查找树的后序遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* tree)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(tree!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(tree-&gt;left);</span><br><span class="line">    <span class="built_in">dfs</span>(tree-&gt;right);</span><br><span class="line">    cout&lt;&lt;tree-&gt;val&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-2-查询二叉搜索树">2.2 查询二叉搜索树</h2><p>我们有时需要查找一个存储在二叉搜索树的关键字，除了查找外，二叉查找树还支持获取最大值，获取最小值，获取元素的前驱和后继，插入，删除的操作。假设二叉查找树的高度为 h，那么它能在 O(h) 的时间内执行完每个操作。</p><h3 id="查找">查找</h3><p>输入一个指向树根的的指针和一个关键字 k，如果这个节点存在，则返回指向关键字为 k 的节点的指针，否则返回 NULL。</p><p>以下是递归实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">treeSearch</span><span class="params">(TreeNode *tree, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(tree-&gt;val==k || tree-&gt;val==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> tree-&gt;val;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(k&lt;tree-&gt;val)&#123;  <span class="comment">// k 小于根节点，说明 k 只可能在左子树上，递归搜索左子树</span></span><br><span class="line">    <span class="keyword">return</span> tree-<span class="built_in">search</span>(tree-&gt;left,k);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> tree-<span class="built_in">search</span>(tree-&gt;right,k);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还可以使用循环，即迭代的思想来解决，对于大多数计算机，迭代版本的效率要高得多。通过这个例子，体会一下怎么把递归改为迭代。因为递归层次太多，可能会造成栈溢出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">treeSearch</span><span class="params">(TreeNode *tree, <span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(tree!=<span class="literal">nullptr</span> &amp;&amp; tree-&gt;val!=k)&#123;</span><br><span class="line">    <span class="keyword">if</span>(k &lt; tree-&gt;val)&#123;</span><br><span class="line">      tree = tree-&gt;left;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">      tree = tree-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大关键字元素和最小关键字元素">最大关键字元素和最小关键字元素</h3><p>通过从根开始沿着左孩子指针(左子树)，直到遇到一个 nullptr，我们总能够找到一个元素，这个元素就是这棵二叉查找树的最小元素。同理，从根开始沿着右孩子指针(左子树)，直到遇到一个 nullptr，我们总能够找到一个元素，这个元素就是这棵二叉查找树的最大元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取二叉查找树最小值</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">treeMinimum</span><span class="params">(TreeNode *tree)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(tree-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">  tree = tree-&gt;left;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同理获得最大值如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">treeMaxmum</span><span class="params">(TreeNode *tree)</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(tree-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">  tree = tree-&gt;right;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="前驱">前驱</h3><p>在一棵高度为 h 的树上，treeSuccessor 的运行时间为 O(h)，因为该过程只是简单地沿树向上或沿树向下。求前驱过程treePredecessor是对称的，运行时间也是O(h)。</p><p>给定一棵二叉搜索树中的一个节点 tree，按中序遍历的次序查找它的前驱，如果所有的关键字都不相同，则一个节点的前驱是小于tree-&gt;val 的最大关键字节点。<strong>使用前序遍历</strong></p><p>当二叉树的中序遍历为2 3 4 6 7 9 13 15 17 18 20 ，元素 <code>7</code>的前驱为6，后继为9</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">treePredecessor</span><span class="params">(TreeNode *tree)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(tree-&gt;left!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">treeMaxmum</span>(tree-&gt;left);</span><br><span class="line">  &#125;</span><br><span class="line">  TreeNode *y = tree-&gt;parent;</span><br><span class="line">  <span class="keyword">while</span>(y!=<span class="literal">nullptr</span> &amp;&amp; y-&gt;left!=tree)&#123;</span><br><span class="line">    tree = y;</span><br><span class="line">    y = y-&gt;parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码也分两种情况：</p><ul><li>左子树不为空，那么该节点的前驱就是左子树的最大节点。</li><li>左子树为空，此时 tree 沿树而上，直到遇到一个双亲有右孩子的节点。</li></ul><h3 id="后继">后继</h3><p>给定一棵二叉搜索树中的一个节点 tree，有时候需要按中序遍历的次序查找它的后继，如果所有的关键字都不相同，则一个节点的后继是大于tree-&gt;val 的最小关键字节点。</p><p>例如当</p><p>下例函数返回二叉查找树某节点的后继：<strong>使用中序遍历</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">treeSuccessor</span><span class="params">(TreeNode *tree)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(tree-&gt;right!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">treeMinimum</span>(tree-&gt;right);</span><br><span class="line">  &#125;</span><br><span class="line">  TreeNode *y = tree-&gt;parent;</span><br><span class="line">  <span class="keyword">while</span>(y!=<span class="literal">nullptr</span> &amp;&amp; tree==y-&gt;right)&#123;</span><br><span class="line">    tree = y;</span><br><span class="line">    y = y-&gt;parent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码分别处理两种情况：</p><ul><li>右子树不为空，此时 tree 的后继就是右子树中最小节点，调用 treeMinimum(tree-&gt;right)即可获得</li><li>右子树为空，此时 tree 沿树而上，直到遇到一个双亲有左孩子的节点。</li></ul><p>用下列二叉搜索树来测试代码</p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-09-03%20%E4%B8%8B%E5%8D%885.21.27.png" alt="截屏2021-09-03 下午5.21.27" style="zoom:50%;" /><h3 id="测试代码">测试代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode *parent;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">parent</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">parent</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">treeBuild</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;tab, <span class="type">int</span> &amp;index, TreeNode *parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *root = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;tab.<span class="built_in">size</span>() &amp;&amp; tab[index]!=<span class="number">0</span>)&#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(tab[index]);</span><br><span class="line">        root-&gt;parent = parent;</span><br><span class="line">        root-&gt;left = <span class="built_in">treeBuild</span>(tab, ++index,root);</span><br><span class="line">        root-&gt;right = <span class="built_in">treeBuild</span>(tab, ++index,root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">treeSearch</span><span class="params">(TreeNode *tree, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;val == k || tree == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; tree-&gt;val)</span><br><span class="line">    &#123; <span class="comment">// k 小于根节点，说明 k 只可能在左子树上，递归搜索左子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">treeSearch</span>(tree-&gt;left, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">treeSearch</span>(tree-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(TreeNode *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">inOrder</span>(tree-&gt;left);</span><br><span class="line">    cout &lt;&lt; tree-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">inOrder</span>(tree-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取二叉查找树最小值</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">treeMinimum</span><span class="params">(TreeNode *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (tree-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tree = tree-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">treeMaxmum</span><span class="params">(TreeNode *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (tree-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tree = tree-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">treeSuccessor</span><span class="params">(TreeNode *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">treeMinimum</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *y = tree-&gt;parent;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;y-&gt;val: &quot; &lt;&lt; y-&gt;val &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">while</span> (y != <span class="literal">nullptr</span> &amp;&amp; tree == y-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        tree = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">        <span class="comment">//cout &lt;&lt;&quot;y-&gt;val: &quot;&lt;&lt;y-&gt;val&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">treePredecessor</span><span class="params">(TreeNode *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">treeMaxmum</span>(tree-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *y = tree-&gt;parent;</span><br><span class="line">    <span class="keyword">while</span> (y != <span class="literal">nullptr</span> &amp;&amp; y-&gt;left != tree)</span><br><span class="line">    &#123;</span><br><span class="line">        tree = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;tab&#123;<span class="number">15</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">18</span>,<span class="number">17</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">20</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">  BinaryTree *T = <span class="keyword">new</span> BinaryTree;</span><br><span class="line">    T-&gt;root = <span class="built_in">treeBuild</span>(tab,index,<span class="literal">nullptr</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;中序遍历：&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">inOrder</span>(root);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;maxmum: &quot;</span>&lt;&lt;<span class="built_in">treeMaxmum</span>(T-&gt;root)-&gt;val&lt;&lt;endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;minimum: &quot;</span> &lt;&lt; <span class="built_in">treeMinimum</span>(T-&gt;root)-&gt;val &lt;&lt; endl;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">15</span>;</span><br><span class="line">    TreeNode *p = <span class="built_in">treeSearch</span>(T-&gt;root,num);</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">&quot; 的前驱: &quot;</span> &lt;&lt; <span class="built_in">treePredecessor</span>(p)-&gt;val &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; num &lt;&lt; <span class="string">&quot; 的后继: &quot;</span> &lt;&lt; <span class="built_in">treeSuccessor</span>(p)-&gt;val&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./tree</span></span><br><span class="line">中序遍历：</span><br><span class="line">2 3 4 6 7 9 13 15 17 18 20 </span><br><span class="line">maxmum: 20</span><br><span class="line">minimum: 2</span><br><span class="line">15的前驱: 13</span><br><span class="line">15的后继: 17</span><br></pre></td></tr></table></figure><h3 id="总结">总结</h3><p>在一棵高度为 h 的二叉搜索树上，动态集合的操作：treeSearch,treeMinimum,treeMaxmum,treeSuccessor,treePredecessor 的时间复杂度为 O(h)</p><h2 id="2-3-插入和删除">2.3 插入和删除</h2><p>插入和删除会引起由二叉树表示的动态集合的变化。一定要修改数据结构来反应这个变化，该修改要保持二叉搜索树性质的成立。插入一个新节点带来的树修改要简单些，而删除的处理要复杂一些。</p><h3 id="插入">插入</h3><p>将一个新值 v 插入到一棵二叉搜索树 T 中，需要调用 treeInsert，该过程以节点 z 作为输入。其中 <code>z.val=v，z.left=nullptr, z.right=nullptr,z.parent=nullptr</code>，这个过程要修改 T 和 z 的某些属性来把 z 插入到树中相应的位置。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">treeInsert</span><span class="params">(TreeNode *root, TreeNode *z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *y = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode *x = root;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;val &lt; x-&gt;val)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;parent = y;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="literal">nullptr</span>) <span class="comment">// 如果树为空树</span></span><br><span class="line">        root = z;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;val &lt; y-&gt;val)</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;right = z;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与其他搜索树上的原始操作一样，过程treeInsert在一棵高度为 h 的树上的运行时间为 O(h)</p><h3 id="删除">删除</h3><p>从一棵二叉树 T 中删除一个节点 z 需要考虑以下 3 种情况，但只有一种最棘手。</p><ol><li><p>如果 z 没有孩子节点，那么只需简单地将它删除，并需改它的父节点，用<code>nullptr</code>作为孩子节点来替换 z</p></li><li><p>如果 z 只有一个孩子，那么将这个孩子提升到树中 z 的位置，并修改 z 的父节点，用 z 的孩子来替换 z</p></li></ol><p>如果 z 有两个孩子，那么找 z 的后继y(一定在 z 的右子树中，且没有左孩子)，并让 y 占据树中 z 的位置。z 的原来右子树的部分成为新的右子树，并且 z 的左子树成为 y 的新的左子树</p><p><strong>注意：如果一棵二叉搜索树的一个节点有两个孩子，那么它的后继没有左孩子，它的前驱没有右孩子。</strong></p><ol start="3"><li><p>如果 y 是 z 的右孩子，那么用 y 替换 z，并留下 y 的右孩子，y 没有左孩子</p></li><li><p>如果 y 不是 z 的右孩子，y 位于 z 的右子树但并不是 z 的右孩子。在这种情况下，先用 y 的右孩子替换 y，然后再用 y 替换 z。</p></li></ol><p>针对上述 4 种情况，下面依次用图片讲解：</p><p>从以下二叉树中，删除节点 z</p><p>图(a) 和 图(b) 为 第 2 种情况：</p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-09-03%20%E4%B8%8B%E5%8D%884.31.57.png" alt="截屏2021-09-03 下午4.31.57" style="zoom:50%;" /><img src="/Users/wangjun/Library/Application Support/typora-user-images/截屏2021-09-03 下午4.33.19.png" alt="截屏2021-09-03 下午4.33.19" style="zoom:50%;" /><p>图© 为第 3 种情况：</p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-09-03%20%E4%B8%8B%E5%8D%884.35.06.png" alt="截屏2021-09-03 下午4.35.06" style="zoom: 67%;" /><p>图(d) 为第 4 种情况：</p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-09-03%20%E4%B8%8B%E5%8D%884.36.07.png" alt="截屏2021-09-03 下午4.36.07" style="zoom: 67%;" /><h3 id="子树替换">子树替换</h3><p>为了在二叉搜索树内移动子树，定义一个子过程 transplant，它是用另一棵子树替换一棵子树并成为其双亲的孩子节点。例如：当 transplant用一棵以 v 为根的子树来替换一棵以 u 为根的子树时，节点 u 的双亲就变为节点 v 的双亲，并且最后 v 成为 u的双亲的相应孩子。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用 v 子树替换 u 子树，不能改变 u 子树</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transplant</span><span class="params">(BinaryTree *T, TreeNode *u, TreeNode *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 用 v 子树来替换 u 子树，该函数允许 v 为空的情况</span></span><br><span class="line">    <span class="keyword">if</span> (u-&gt;parent == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="comment">// 处理 u 是 T 的树根的情况</span></span><br><span class="line">        <span class="comment">// 注：如果参数传递的是 TreeNode *root,root = v，并不能工作，因为此时root为局部变量</span></span><br><span class="line">        T-&gt;root =v;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u == u-&gt;parent-&gt;left)</span><br><span class="line">    &#123; </span><br><span class="line">      <span class="comment">// 如果 u 为右孩子</span></span><br><span class="line">        u-&gt;parent-&gt;left = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        u-&gt;parent-&gt;right = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        v-&gt;parent = u-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">treeDelete</span><span class="params">(BinaryTree *T, TreeNode *z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *y = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(z-&gt;left==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="built_in">transplant</span>(T,z,z-&gt;right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="built_in">transplant</span>(T,z,z-&gt;left);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        y = <span class="built_in">treeMinimum</span>(z-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(y-&gt;parent!=z)&#123;</span><br><span class="line">            <span class="built_in">transplant</span>(T,y,y-&gt;right);</span><br><span class="line">            y-&gt;right = z-&gt;right;</span><br><span class="line">            y-&gt;right-&gt;parent = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">transplant</span>(T,z, y);</span><br><span class="line">        y-&gt;left = z-&gt;left;</span><br><span class="line">        y-&gt;left-&gt;parent = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-09-03%20%E4%B8%8B%E5%8D%885.21.271.png" alt="截屏2021-09-03 下午5.21.27" style="zoom:50%;" /><p>下面用上图所示二叉搜索树来测试二叉树的插入和删除。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode *parent;</span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">val</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">parent</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">parent</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">BinaryTree</span>   <span class="comment">// 二叉树</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode *root;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">treeBuild</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;tab, <span class="type">int</span> &amp;index, TreeNode *parent)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *root = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;tab.<span class="built_in">size</span>() &amp;&amp; tab[index]!=<span class="number">0</span>)&#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(tab[index]);</span><br><span class="line">        root-&gt;parent = parent;</span><br><span class="line">        root-&gt;left = <span class="built_in">treeBuild</span>(tab, ++index,root);</span><br><span class="line">        root-&gt;right = <span class="built_in">treeBuild</span>(tab, ++index,root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">treeSearch</span><span class="params">(TreeNode *tree, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;val == k || tree == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; tree-&gt;val)</span><br><span class="line">    &#123; <span class="comment">// k 小于根节点，说明 k 只可能在左子树上，递归搜索左子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">treeSearch</span>(tree-&gt;left, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">treeSearch</span>(tree-&gt;right, k);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(tree-&gt;left);</span><br><span class="line">    cout &lt;&lt; tree-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(tree-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取二叉查找树最小值</span></span><br><span class="line"><span class="function">TreeNode *<span class="title">treeMinimum</span><span class="params">(TreeNode *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (tree-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tree = tree-&gt;left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">treeMaxmum</span><span class="params">(TreeNode *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (tree-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tree = tree-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">treeSuccessor</span><span class="params">(TreeNode *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;right != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">treeMinimum</span>(tree-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *y = tree-&gt;parent;</span><br><span class="line">    <span class="comment">//cout &lt;&lt; &quot;y-&gt;val: &quot; &lt;&lt; y-&gt;val &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">while</span> (y != <span class="literal">nullptr</span> &amp;&amp; tree == y-&gt;right)</span><br><span class="line">    &#123;</span><br><span class="line">        tree = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">        <span class="comment">//cout &lt;&lt;&quot;y-&gt;val: &quot;&lt;&lt;y-&gt;val&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">treePredecessor</span><span class="params">(TreeNode *tree)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree-&gt;left != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">treeMaxmum</span>(tree-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode *y = tree-&gt;parent;</span><br><span class="line">    <span class="keyword">while</span> (y != <span class="literal">nullptr</span> &amp;&amp; y-&gt;left != tree)</span><br><span class="line">    &#123;</span><br><span class="line">        tree = y;</span><br><span class="line">        y = y-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">treeInsert</span><span class="params">(TreeNode *root, TreeNode *z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *y = <span class="literal">nullptr</span>;</span><br><span class="line">    TreeNode *x = root;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        y = x;</span><br><span class="line">        <span class="keyword">if</span> (z-&gt;val &lt; x-&gt;val)</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;parent = y;</span><br><span class="line">    <span class="keyword">if</span> (y == <span class="literal">nullptr</span>) <span class="comment">// 如果树为空树</span></span><br><span class="line">        root = z;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;val &lt; y-&gt;val)</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        y-&gt;right = z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">transplant</span><span class="params">(BinaryTree *T, TreeNode *u, TreeNode *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 用 v 子树来替换 u 子树，该函数允许 v 为空的情况</span></span><br><span class="line">    <span class="keyword">if</span> (u-&gt;parent == <span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="comment">// 处理 u 是 T 的树根的情况</span></span><br><span class="line">        <span class="comment">//root = v;</span></span><br><span class="line">        T-&gt;root =v;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (u == u-&gt;parent-&gt;left)</span><br><span class="line">    &#123; <span class="comment">// 如果 u 为右孩子</span></span><br><span class="line">        u-&gt;parent-&gt;left = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        u-&gt;parent-&gt;right = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (v != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        v-&gt;parent = u-&gt;parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">treeDelete</span><span class="params">(BinaryTree *T, TreeNode *z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *y = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span>(z-&gt;left==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="built_in">transplant</span>(T,z,z-&gt;right);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(z-&gt;right==<span class="literal">nullptr</span>)</span><br><span class="line">        <span class="built_in">transplant</span>(T,z,z-&gt;left);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        y = <span class="built_in">treeMinimum</span>(z-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(y-&gt;parent!=z)&#123;</span><br><span class="line">            <span class="built_in">transplant</span>(T,y,y-&gt;right);</span><br><span class="line">            y-&gt;right = z-&gt;right;</span><br><span class="line">            y-&gt;right-&gt;parent = y;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">transplant</span>(T,z, y);</span><br><span class="line">        y-&gt;left = z-&gt;left;</span><br><span class="line">        y-&gt;left-&gt;parent = y;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;left=<span class="literal">nullptr</span>;</span><br><span class="line">    z-&gt;right=<span class="literal">nullptr</span>;</span><br><span class="line">    z-&gt;parent=<span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;tab&#123;<span class="number">15</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">0</span>,<span class="number">13</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">18</span>,<span class="number">17</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">20</span>,<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">    BinaryTree *T = <span class="keyword">new</span> BinaryTree;</span><br><span class="line">    T-&gt;root = <span class="built_in">treeBuild</span>(tab,index,<span class="literal">nullptr</span>);</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;原二叉搜索树(中序遍历)：&quot;</span>;</span><br><span class="line">    <span class="built_in">inOrder</span>(T-&gt;root);</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">    TreeNode *pdel1 = <span class="built_in">treeSearch</span>(T-&gt;root, <span class="number">6</span>);</span><br><span class="line">    TreeNode *pdel2 = <span class="built_in">treeSearch</span>(T-&gt;root, <span class="number">18</span>);</span><br><span class="line">    TreeNode *pdel3 = <span class="built_in">treeSearch</span>(T-&gt;root, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除节点6 &quot;</span>;</span><br><span class="line">    <span class="built_in">treeDelete</span>(T,pdel1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;中序遍历：&quot;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(T-&gt;root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除节点18 &quot;</span> ;</span><br><span class="line">    <span class="built_in">treeDelete</span>(T, pdel2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;中序遍历：&quot;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(T-&gt;root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;删除节点15 &quot;</span>;</span><br><span class="line">    <span class="built_in">treeDelete</span>(T, pdel3);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;中序遍历：&quot;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(T-&gt;root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;插入节点15 &quot;</span>;</span><br><span class="line">    <span class="built_in">treeInsert</span>(T-&gt;root, pdel3);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;中序遍历：&quot;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(T-&gt;root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;插入节点18 &quot;</span>;</span><br><span class="line">    <span class="built_in">treeInsert</span>(T-&gt;root, pdel2);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;中序遍历：&quot;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(T-&gt;root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;插入节点6 &quot;</span>;</span><br><span class="line">    <span class="built_in">treeInsert</span>(T-&gt;root, pdel1);</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;中序遍历：&quot;</span>;</span><br><span class="line">    <span class="built_in">dfs</span>(T-&gt;root);</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./tree</span></span><br><span class="line">原二叉搜索树(中序遍历)：2 3 4 6 7 9 13 15 17 18 20 </span><br><span class="line">删除节点6 中序遍历：2 3 4 7 9 13 15 17 18 20 </span><br><span class="line">删除节点18 中序遍历：2 3 4 7 9 13 15 17 20 </span><br><span class="line">删除节点15 中序遍历：2 3 4 7 9 13 17 20 </span><br><span class="line">插入节点15 中序遍历：2 3 4 7 9 13 15 17 20 </span><br><span class="line">插入节点18 中序遍历：2 3 4 7 9 13 15 17 18 20 </span><br><span class="line">插入节点6 中序遍历：2 3 4 6 7 9 13 15 17 18 20 </span><br></pre></td></tr></table></figure><p>二叉查找树的插入和删除时间复杂度都为 O(h)，h 为树的高度。</p><h2 id="2-4-随机构建二叉搜索树">2.4 随机构建二叉搜索树</h2><p>上述内容已经说明，二叉搜索树上的每个基本操作都能在O(h)时间内完成，其中 h 是这棵树的高度。随着元素的插入和删除，二叉搜索树的高度是变化的。例如，当 n 个关键子按严格递增的次序被插入，则这棵树的高度为 n-1 的一条链子，这是二叉搜索树性能最低的情况。<strong>但是，和快速排序一样，我们可以证明平均情形更接近最好情况，而不是最坏情况。</strong></p><p><strong>一棵有 n 个不同关键字的随机构建二叉搜索树的期望高度为 O(lg n)</strong></p><h1>3、红黑树</h1><p>通过上面的讲解，我们知道二叉搜索树支持任何一种基本动态集合操作。例如查找(search)，前驱(predecessor)，后继(successor)，最小值(minimum)，最大值(maxmum)，插入(insert)，删除(delete)等。其时间复杂度都是 O(h)，h 为树的高度</p><p>。红黑树是许多“平衡”搜索树的一种，可以保证在最坏情况下基本动态集合的时间复杂度为O(ln n)。</p><h2 id="3-1-红黑树的性质">3.1 红黑树的性质</h2><p>红黑树每个节点包含 5 个属性: color, key, left, right 和 p。分别表示颜色，节点值，左孩子，右孩子和父亲节点。如果一个节点没有子节点和父节点，则该节点称为外部节点，该节点只作标记，不存储实际值。我们把存储实际值的节点称为内部节点。</p><p>一棵红黑树是满足下面<strong>红黑性质</strong>的二叉搜索树：</p><ol><li><p><strong>每个节点或是红色，或是黑色的。</strong></p></li><li><p><strong>根节点是黑色的</strong></p></li><li><p><strong>每个叶节点(NIL)是黑色的。</strong></p></li><li><p><strong>如果一个节点是红色的，则它的两个子节点都是黑色的。</strong></p></li><li><p><strong>对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。</strong></p></li></ol><p>为了便于处理红黑树代码中的边界条件，使用一个哨兵来代表 NIL。哨兵和内部节点一样，都具有 5 个属性，不同的是它的 color 为黑色，其他属性为随机值。入下图所示：</p><p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-09-03%20%E4%B8%8B%E5%8D%889.45.06.png" alt="截屏2021-09-03 下午9.45.06"></p><p>上面 3 幅都表示同一棵红黑树，图(b) 表示所有NIL节点用同一个节点表示，更节省空间。图© 省略了 NIL 节点。</p><p><strong>从某个节点 x 出发(不含该节点)到达一个叶节点的任意一条简单路径上的黑色节点个数称为该节点的黑高(black-height)，记作bh(x)。</strong></p><p>记住一个结论：<strong>一棵有 n 个内部节点的红黑树树的高度至多为 2lg(n+1)</strong>，更多请参考《算法导论》原书第 3 版 308页。</p><p>设 h 为树的高度，根据性质 4 ，从根到叶节点(不包括根节点)的任何一条简单路径上都至少有一半的节点为黑色。因此，根的黑高至少是 h/2。于是有 n &gt;= 2<sup>k/2</sup>-1，把 1 移到不等式的左边，再对两边取对数得到 lg(n+1) &gt;=h/2，或者h&lt;=2lg(n+1)。由此可知**(search)，前驱(predecessor)，后继(successor)，最小值(minimum)，最大值(maxmum)，插入(insert)，删除(delete)等动态集合操作的时间复杂度为 O(lgn)**</p><p>因为涉及到代码，二叉搜索树用的是 c 语言代码，为了使代码结构更加清晰，下面红黑树使用 c++ 面向对象思想来编写：</p><p>下面为红黑树类 及 红黑树对象的结构定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _RBTree_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _RBTree_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">E_COLOR</span></span><br><span class="line">&#123;</span><br><span class="line">    BLACK,</span><br><span class="line">    RED</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TreeNode</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> key;</span><br><span class="line">    E_COLOR color;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode *p;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">TreeNode</span>() : <span class="built_in">key</span>(<span class="number">0</span>), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">p</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> key) : <span class="built_in">key</span>(key), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">p</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(E_COLOR c) : <span class="built_in">key</span>(<span class="number">0</span>),<span class="built_in">color</span>(c),<span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, E_COLOR c) : <span class="built_in">key</span>(x), <span class="built_in">left</span>(<span class="literal">nullptr</span>), <span class="built_in">right</span>(<span class="literal">nullptr</span>), <span class="built_in">p</span>(<span class="literal">nullptr</span>), <span class="built_in">color</span>(c) &#123;&#125;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="type">int</span> x, E_COLOR c, TreeNode *left, TreeNode *right, TreeNode *p) : <span class="built_in">key</span>(x), <span class="built_in">color</span>(c),<span class="built_in">left</span>(left), <span class="built_in">right</span>(right), <span class="built_in">p</span>(p) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">RBTREE</span></span><br><span class="line">&#123;</span><br><span class="line">    TreeNode *root; <span class="comment">// 红黑树头节点</span></span><br><span class="line">    TreeNode *NIL;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RBTree</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    RBTREE *rbtree;                  <span class="comment">// 红黑树对象</span></span><br><span class="line">    <span class="built_in">RBTree</span>():<span class="built_in">rbtree</span>(<span class="literal">nullptr</span>)&#123;&#125;;      <span class="comment">// 默认构造函数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用中序遍历构造红黑树，vector的元素为 pair 类型（键值对），key 为元素值，value 为 红黑值</span></span><br><span class="line">    <span class="built_in">RBTree</span>(vector&lt;pair&lt;<span class="type">int</span>,E_COLOR&gt;&gt; &amp;inorder); </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">preOrder</span><span class="params">(TreeNode *root)</span></span>;                  <span class="comment">// 前序遍历二叉树</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">inOrder</span><span class="params">(TreeNode *root)</span></span>;                   <span class="comment">// 中序遍历二叉树</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">search</span><span class="params">(TreeNode *tree, <span class="type">int</span> k)</span></span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">minimum</span><span class="params">(TreeNode *tree)</span></span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">maximum</span><span class="params">(TreeNode *tree)</span></span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">successor</span><span class="params">(TreeNode *tree)</span></span>;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">predecessor</span><span class="params">(TreeNode *tree)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">leftRotate</span><span class="params">(RBTREE *T, TreeNode *x)</span></span>;        <span class="comment">// 左旋</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rightRotate</span><span class="params">(RBTREE *T, TreeNode *x)</span></span>;       <span class="comment">// 右旋</span></span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">RBTree</span>()&#123;&#125;;</span><br><span class="line"><span class="keyword">private</span>: </span><br><span class="line">    <span class="function">TreeNode *<span class="title">rbBuild</span><span class="params">(vector&lt;pair&lt;<span class="type">int</span>, E_COLOR&gt;&gt; &amp;inorder, <span class="type">int</span> &amp;index, TreeNode *p)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="3-2-旋转">3.2 旋转</h2><p>在插入和删除节点之后，可能会破坏红黑性质，为了维护这些性质，必须改变某些节点的颜色和指针结构。</p><p>指针结构的修改是通过<code>旋转</code>来完成的，这是一种能保持二叉搜索树性质的搜索树局部操作。分为左旋和右旋。</p><p>如下图所示：从右到走称为左旋，其中 x 为其右孩子不是 T.NIL 节点树内任意节点。</p><p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-09-03%20%E4%B8%8B%E5%8D%8810.18.13.png" alt="截屏2021-09-03 下午10.18.13"></p><p>左旋和右旋是互为对称的操作。</p><p>下面演示左旋，假设 <code>x-&gt;right!=T.nil 且根节点的父节点为 T.nil</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">RBTree::leftRotate</span><span class="params">(RBTREE *T, TreeNode *x)</span></span>&#123;</span><br><span class="line">  <span class="comment">// T 为红黑树对象 </span></span><br><span class="line">    <span class="comment">// 假设 x.right != NIL 且根节点的父节点为 NIL</span></span><br><span class="line">    TreeNode *y = x-&gt;right;  </span><br><span class="line">    x-&gt;right = y-&gt;left;           <span class="comment">// 将 y 的左子树作为 x 的右子树</span></span><br><span class="line">    <span class="keyword">if</span>(y-&gt;left!=T-&gt;NIL)&#123;          </span><br><span class="line">        y-&gt;left-&gt;p = x;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;p = x-&gt;p;                  <span class="comment">// 设置 y 的父节点</span></span><br><span class="line">    <span class="keyword">if</span>(x-&gt;p==T-&gt;NIL)              <span class="comment">// 如果 x 为根节点，则将 y 作为根节点</span></span><br><span class="line">        T-&gt;root = y;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (x==x-&gt;p-&gt;left)       <span class="comment">// 否则的话，判断 x 为左节点还是右节点</span></span><br><span class="line">        x-&gt;p-&gt;left = y;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        x-&gt;p-&gt;right = y;</span><br><span class="line">    y-&gt;left = x;                  <span class="comment">// 将 x 作为 y 的 左孩子</span></span><br><span class="line">    x-&gt;p = y;                     <span class="comment">// 这样就完成了 左旋转，二叉树搜索树的性质不变</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>右旋：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">RBTree::rightRotate</span><span class="params">(RBTREE *T, TreeNode *x)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 假设 x 的左节点不等于 NIL</span></span><br><span class="line">    TreeNode *y =  x-&gt;left;    <span class="comment">// y-&gt;left 可以作为空节点使用</span></span><br><span class="line">    x-&gt;left = y-&gt;right;        <span class="comment">// 用 x 的右孩子替代 y 的左孩子</span></span><br><span class="line">    <span class="keyword">if</span>(y-&gt;right!=T-&gt;NIL)&#123;</span><br><span class="line">        y-&gt;right-&gt;p = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(x-&gt;p==T-&gt;NIL)&#123;</span><br><span class="line">        T-&gt;root = y;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(x-&gt;p-&gt;left==x)&#123;</span><br><span class="line">        x-&gt;p-&gt;left = y;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        x-&gt;p-&gt;right = y;</span><br><span class="line">    &#125;</span><br><span class="line">    y-&gt;right = x;</span><br><span class="line">    x-&gt;p = y;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-插入">3.3 插入</h2><p>插入一个节点后，将该节点的左孩子，和右孩子设置为 NIL，颜色设置为红色。因为该节点可能会破坏红黑特性，还需要一个函数来对红黑树进行调整，以满足该二叉搜索树的红黑特性。</p><p>首先看插入函数：插入函数和二叉排序树的插入差不多，唯一的区别是所有叶子节点的左右孩子指针指向 NIL，根节点的父指针指向 NIL，最后 4 行代码给新添加的节点上色</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">RBTree::insert</span><span class="params">(RBTREE *T, TreeNode *z)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *y = T-&gt;NIL;</span><br><span class="line">    TreeNode *x = T-&gt;root;</span><br><span class="line">    <span class="keyword">while</span> (x != T-&gt;NIL)</span><br><span class="line">    &#123;</span><br><span class="line">        y = x; <span class="comment">// 记录父节点</span></span><br><span class="line">        <span class="keyword">if</span> (z-&gt;key &lt; x-&gt;key)</span><br><span class="line">        &#123;</span><br><span class="line">            x = x-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            x = x-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;p = y;</span><br><span class="line">    <span class="keyword">if</span> (y == T-&gt;NIL)</span><br><span class="line">    &#123;</span><br><span class="line">        T-&gt;root = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (z-&gt;key &lt; y-&gt;key)</span><br><span class="line">    &#123;</span><br><span class="line">        y-&gt;left = z;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        y-&gt;right = z;</span><br><span class="line">    &#125;</span><br><span class="line">    z-&gt;color = RED;</span><br><span class="line">    z-&gt;left = T-&gt;NIL;</span><br><span class="line">    z-&gt;right = T-&gt;NIL;</span><br><span class="line">    <span class="built_in">insertFixup</span>(T,z);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>void  RBTree::insertFixup(RBTREE *T, TreeNode *z)</code></p><p>新插入的节点可能会破坏某些红黑性质，根据出现的情况需要进行不同的操作。在写代码之前，我们需要知道在调用 insertFixup 时哪些红黑性质可能会被破坏。性质1 和性质3 成立，因为新插入的红节点的两个子节点都是哨兵 NIL，性质 5 也成立，因为即使为空树，因为根节点的父节点为 NIL，NIL 为黑色节点。</p><p>综上所述：可能被破坏的只有性质 2 和性质 4，即根节点需要为黑色，以及一个红节点不能有红孩子。这两个性质被破坏是因为 z 被着为红色，</p><p>如果 z 是根节点，则破坏了性质2；</p><p>如果 z 的父节点是红节点，则破坏了性质 4；</p><p>循环的结束条件为 z 的父节点为黑色，如果 z 的父节点一直为红，则一直循环。在循环体内，我们根据不同的情况作相应的调整：<strong>记住只要在循环体内，z 和 z 的父节点都为红色</strong></p><p>根据 z 的父节点作为左子树还是右子树分为两大类</p><p>（1）z 的父节点作为左子树</p><h3 id="情况1">情况1</h3><p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-09-04%20%E4%B8%8B%E5%8D%889.31.48.png" alt="截屏2021-09-04 下午9.31.48"></p><p>在情况1下，<strong>z为红色，z 的父节点为红色，z 的叔节点为红色时</strong>，此时为第 1 种情况，如上图所示。需要要z 的父节点和叔节点调整为黑色，z 的祖父节点调整为红色，并让 z 想上移动两层。如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">z-&gt;p-&gt;color = BLACK;</span><br><span class="line">y-&gt;color = BLACK;</span><br><span class="line">z-&gt;p-&gt;color=RED;</span><br><span class="line">z = z-&gt;p-&gt;p;</span><br></pre></td></tr></table></figure><p>z 向上爬两层。得到下图：</p><h3 id="情况2">情况2</h3><p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-09-04%20%E4%B8%8B%E5%8D%889.37.48.png" alt="截屏2021-09-04 下午9.37.48"></p><p>在情况 2 下， **z 为红色 ，z 的父节点为红色，z 的叔节点为黑色，z 此时为右节点，**将 z 上爬一层，然后将 z 左旋转，这样就可以让 z 满足性质4了。左旋之后得到下图：</p><p>操作代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">z = z-&gt;p;</span><br><span class="line"><span class="built_in">leftRotate</span>(T,z);</span><br></pre></td></tr></table></figure><h3 id="情况3">情况3</h3><p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-09-04%20%E4%B8%8B%E5%8D%889.44.06.png" alt="截屏2021-09-04 下午9.44.06"></p><p>在情况3下，<strong>z 为红色，z的父节点为红色，z的叔节点为黑色，z 此时为左节点</strong></p><p>将 z 的父节点改为黑色，将 z 的祖辈节点 改为红色，本次修改破坏了性质5，因为此时z 所在子树的黑节点多了一个，而 z 的叔节点所在子树黑节点少了一个，此时将 z 的祖父节点右旋，就能让 z 所在子树的黑节点变少一个，因为计算黑高并不包括根节点。</p><p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-09-04%20%E4%B8%8B%E5%8D%889.55.46.png" alt="截屏2021-09-04 下午9.55.46"></p><p>此时 z 的父节点已经为黑色，故推出循环。且整棵树符合红黑树的所有性质。</p><p>**注意：情况2和情况3的唯一区别就是，z 作为右子树还是作为左子树，如果位于右子树，就需要多一步旋转的操作，让 z 位于左子树上。最终还是来到情况3。 **</p><p>z 的父节点作为右子树</p><p>此时和（1）是对称的，只需将(1) 中的相应的左和右进行交换即可：</p><p>完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">RBTree::insertFixup</span><span class="params">(RBTREE *T, TreeNode *z)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(z-&gt;p-&gt;color == RED)&#123;</span><br><span class="line">        <span class="comment">// 第一大类 z 的父节点作为左孩子</span></span><br><span class="line">        <span class="keyword">if</span>(z-&gt;p == z-&gt;p-&gt;p-&gt;left)&#123;        </span><br><span class="line">            TreeNode *y = z-&gt;p-&gt;p-&gt;right;   <span class="comment">// z 的叔节点</span></span><br><span class="line">            <span class="keyword">if</span>(y-&gt;color==RED)&#123;</span><br><span class="line">                <span class="comment">// case1: 叔叔节点是红色</span></span><br><span class="line">                z-&gt;p-&gt;color = BLACK;</span><br><span class="line">                y-&gt;color = BLACK;</span><br><span class="line">                z-&gt;p-&gt;p-&gt;color=RED;</span><br><span class="line">                z = z-&gt;p-&gt;p;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// case2: 叔叔是黑色 且当且节点是右孩子</span></span><br><span class="line">            <span class="keyword">if</span>(z==z-&gt;p-&gt;right)&#123;</span><br><span class="line">                </span><br><span class="line">                z = z-&gt;p;</span><br><span class="line">                <span class="built_in">leftRotate</span>(T,z);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// case3: 叔叔是黑色，且当亲节点是左孩子</span></span><br><span class="line">            z-&gt;p-&gt;color = BLACK;</span><br><span class="line">            z-&gt;p-&gt;p-&gt;color = RED;</span><br><span class="line">            <span class="built_in">rightRotate</span>(T,z-&gt;p-&gt;p);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123; <span class="comment">// 第二大类 z 的父节点作为右孩子</span></span><br><span class="line">            TreeNode *y = z-&gt;p-&gt;p-&gt;left;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// case1: 叔叔节点为红色</span></span><br><span class="line">            <span class="keyword">if</span> (y-&gt;color == RED)</span><br><span class="line">            &#123;</span><br><span class="line">                z-&gt;p-&gt;color = BLACK;</span><br><span class="line">                y-&gt;color = BLACK;</span><br><span class="line">                z-&gt;p-&gt;p-&gt;color = RED;</span><br><span class="line">                z = z-&gt;p-&gt;p;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// case2: 叔叔节点为黑色 且当前节点是左孩子</span></span><br><span class="line">            <span class="keyword">if</span>(z==z-&gt;p-&gt;left)&#123;</span><br><span class="line">                z = z-&gt;p;</span><br><span class="line">                <span class="built_in">rightRotate</span>(T,z);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// case3: 叔叔节点为黑色 且当前节点是右孩子</span></span><br><span class="line">            z-&gt;p-&gt;color = BLACK;</span><br><span class="line">            z-&gt;p-&gt;p-&gt;color = RED;</span><br><span class="line">            <span class="built_in">leftRotate</span>(T, z-&gt;p-&gt;p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    T-&gt;root-&gt;color = BLACK;     <span class="comment">// 将根节点设置为黑色。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="时间复杂度分析">时间复杂度分析</h3><p>含有 n 个节点的红黑树的高度为O(lg n)，因此<strong>红黑树的插入部分<code>insert</code>时间复杂度为 O(lg n)<strong>时间，在颜色修正部分，仅当情况 1 发生，然后指针沿树上升 2 层，while 循环才会重复执行，所以 while 循环被执行的总次数为 O(lg n)，因此</strong><code>insertFixup</code>的时间复杂度为 O(lg n)</strong>。注意：该程序所做的旋转操作不会超过两次，因为只要执行了情况2 或 情况3，while 循环就结束了。</p><h2 id="3-4-删除">3.4 删除</h2><p>红黑树的删除会比插入更复杂一些，因为删除一个节点可能会破坏某些红黑性质。红黑树的删除代码和二叉搜索树的删除代码差不多，主要的区别稍后给出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">RBTree::remove</span><span class="params">(RBTREE *T, TreeNode *del)</span></span>&#123;</span><br><span class="line">    TreeNode *orig = del;               <span class="comment">// del 为需要移除的节点  orig 记录 del 的节点，或即将取代 del 的节点信息</span></span><br><span class="line">    E_COLOR orig_color = del-&gt;color;    <span class="comment">// orig_color del 的颜色 或 取代 del 的节点颜色</span></span><br><span class="line">    TreeNode *replace = <span class="literal">nullptr</span>;        <span class="comment">// replace 为删除 del 之后，取代它的点 或者 orig 节点仅有的的右孩子</span></span><br><span class="line">    <span class="keyword">if</span>(del-&gt;left==T-&gt;NIL)&#123;</span><br><span class="line">        replace = del-&gt;right;</span><br><span class="line">        <span class="built_in">transplant</span>(T,del,del-&gt;right);</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(del-&gt;right==T-&gt;NIL)&#123;</span><br><span class="line">        replace = del-&gt;left;</span><br><span class="line">        <span class="built_in">transplant</span>(T,del,del-&gt;left);</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        orig = <span class="built_in">minimum</span>(del-&gt;right);    <span class="comment">// 获取 del 右子树最小节点，该节点一定无左子树，删除 del 节点，用 orig 节点取代</span></span><br><span class="line">        orig_color = orig-&gt;color;</span><br><span class="line">        replace = orig-&gt;right;         <span class="comment">// 记录 orig  节点仅有的的右孩子</span></span><br><span class="line">        <span class="keyword">if</span> (orig-&gt;p != del)            <span class="comment">// orig 并不是 del 的直接孩子节点，否则直接取代</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">transplant</span>(T, orig, orig-&gt;right);      <span class="comment">// 用 orig 的右子树替代 orig</span></span><br><span class="line">            orig-&gt;right = del-&gt;right;              <span class="comment">// del 的右子树赋值给 origin 的右子树</span></span><br><span class="line">            orig-&gt;right-&gt;p = orig;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">transplant</span>(T, del, orig);                  <span class="comment">// 用 origin 替换 del</span></span><br><span class="line">        orig-&gt;left = del-&gt;left;                    <span class="comment">// 将 del 的左子树替代 ori 的左子树</span></span><br><span class="line">        orig-&gt;left-&gt;p = orig;</span><br><span class="line">        orig-&gt;color = del-&gt;color;                  <span class="comment">// 将已经删除节点的颜色 del 赋值给 orig</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (orig_color == BLACK)         </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">removeFixup</span>(T,replace);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主要区别：</p><ul><li>始终维持 orig 从树中删除的节点或者移到树内的节点。当 del 只有一个子节点时是前者，当  del 有两个子节点时为后者。</li><li>因为最终要让 orig 的节点颜色等于 del。orig_color 记录 orig 发生改变前的颜色。如果 orig_color 是黑色，则删除或移动 orig 会引起红黑性质的破坏。</li><li>replace 则保存 orig 的唯一子节点，或 NIL(orig 没有子节点)</li></ul><p><strong>如果orig_color 为红色，红黑性质仍然保存，原因如下：</strong></p><ol><li><p>树中黑高没有变化</p></li><li><p>不会存在两个相邻的红节点。如果 orig_color 为红色，则 orig 的子节点 replace 都为黑色， replace 用于替换 原 orig 位置。</p></li><li><p>如果 orig_color 为红色，其不可能是黑节点。</p></li></ol><p>**相反如果orig_color是黑色，则会导致以下问题 **</p><ol><li>如果 orig 为原来的根节点，而 orig 的一个红色的孩子成为了新的根节点，违反了性质2。</li><li>如果 orig 和 orig 的父节点都是红色，则违反了性质4。</li><li>在树中移动 orig 将导致先前包含 y 的任何简单路径上黑节点个数少1，在这种假设下性质 5 成立。</li></ol><p><code>orig_color 为黑色，会导致所有含有 orig 节点的简单路径少了一个黑色节点。orig 的替代节点为 replace，如果 replace 为红色，则把replace 设置为黑色即可。如果 replace 为黑色，则需要为含有orig节点的简单路径增加一个黑色节点，而且不能破坏红黑性质。   </code></p><p>当被删除元素为黑色或后继为黑色时，需要调用<code>removeFixup</code>来修复红黑树的颜色。</p><p>修复颜色，总共有 4 种情况，额外的 4 种是对称的。</p><p><code>removeFixup(T,replace);</code>该函数调用中，replace 在 removeFixup 用 x 来表示，x 的兄弟节点用 w 表示。</p><p>现在讨论的是 x 作为左节点的情况：</p><p><strong>orig_color为黑色，x 也为黑色，需要将 x 看作一个双重黑色看待，需要一步步往上找到一个红色节点，并将其置为红色。如下图：</strong></p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-09-07%20%E4%B8%8A%E5%8D%8812.11.38.png" alt="截屏2021-09-07 上午12.11.38" style="zoom:50%;" /><p><strong>如果orig 为黑， x 为红色，则它作为 红黑色看待，只需将其置为红色即可</strong></p><p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-09-07%20%E4%B8%8A%E5%8D%8812.20.58.png" alt="截屏2021-09-07 上午12.20.58"></p><h3 id="情况1-2">情况1</h3><p>x 的兄弟节点 w 为红色，此时 w 的两个子节点都为黑色(性质4)，如下图所示：</p><p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-09-07%20%E4%B8%8A%E5%8D%8812.03.01.png" alt="截屏2021-09-07 上午12.03.01"></p><p>操作：将 w 置为黑色，x 的父节点置为红色，这样 w 所在子树的黑色节点就和左子树的黑色节点个数相等。但 x 的父节点所在的子树少了一个黑色节点，将 x 向上移动一层，并将它作为双重黑色看待。通过情况1，就转换为情况2，3，4了。</p><p><strong>以下情况都表示 x的兄弟节点 w 为黑色：</strong></p><h3 id="情况2-2">情况2</h3><p>w 的两个孩子节点都为黑色，如下图所示：</p><p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-09-07%20%E4%B8%8A%E5%8D%8812.24.02.png" alt="截屏2021-09-07 上午12.24.02"></p><p>需要从 x 和 w 上去掉一层黑色，使得 x 只有一层黑色， w 为红色。为了补偿从 x 和 w 上去掉的一重黑色，在原来是红色或黑色的 x 的父节点上新增一重黑色。然后让 x = x-&gt;p，来循环 x，直到不满足情况 2 的条件，就进入情况3 和 4</p><h3 id="情况-3">情况 3</h3><p>x 的兄弟节点是黑色的，w 的左孩子是红色的，w 的右孩子是黑色的。如下图所示：</p><p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-09-07%20%E4%B8%8A%E5%8D%8812.30.54.png" alt="截屏2021-09-07 上午12.30.54"></p><p>交换 w 和其左孩子的颜色，然后对 w 进行右旋转，从而不违反任何红黑性质。现在 x 的新兄弟节点 w 是黑色节点，并且 w 的右孩子是红色的，这样我们就由情况 3 进入情况 4。</p><h3 id="情况-4">情况 4</h3><p>x 的兄弟节点 w 是黑色的，且 w 的右孩子是红色的。如下图所示：</p><p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-09-07%20%E4%B8%8A%E5%8D%8812.36.24.png" alt="截屏2021-09-07 上午12.36.24"></p><p>将 w 的颜色 置为  x 的父节点的颜色，将 x 的父节点置为黑色，将 w 的右孩子节点置为黑色，对 x 的父节点进行左旋转。这样就去掉了 x 的额外一重黑色。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> </span></span><br><span class="line"><span class="function"><span class="title">RBTree::removeFixup</span><span class="params">(RBTREE *T, TreeNode *x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x!=T-&gt;NIL &amp;&amp; T-&gt;root &amp;&amp; x-&gt;color==BLACK)&#123;</span><br><span class="line">        <span class="keyword">if</span>(x == x-&gt;p-&gt;left)&#123;</span><br><span class="line">            TreeNode *w = x-&gt;p-&gt;right;</span><br><span class="line">            <span class="keyword">if</span>(w-&gt;color==RED)&#123;</span><br><span class="line">                <span class="comment">// 情况1 x 的兄弟节点为红色</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 交换 w 和 w 的父节点的颜色</span></span><br><span class="line">                w-&gt;color = BLACK;</span><br><span class="line">                x-&gt;p-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 左旋，为保持红黑平衡</span></span><br><span class="line">                <span class="built_in">leftRotate</span>(T,x-&gt;p);</span><br><span class="line">                w = w-&gt;p-&gt;right;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(w-&gt;left-&gt;color==BLACK &amp;&amp; w-&gt;right-&gt;color==BLACK)&#123;</span><br><span class="line">                <span class="comment">// 情况2 w 的左右孩子都为黑色</span></span><br><span class="line">                w-&gt;color = RED;</span><br><span class="line">                x =x-&gt;p;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(w-&gt;right-&gt;color == BLACK)&#123;</span><br><span class="line">                <span class="comment">// 情况 3 w 的右孩子为黑色，则 w 的左孩子为红色</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 交换 w 和 其左孩子的颜色</span></span><br><span class="line">                w-&gt;left-&gt;color = BLACK;</span><br><span class="line">                w-&gt;color = RED;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 右旋，保证 w 子树的每条简单路径的黑色节点数相同</span></span><br><span class="line">                <span class="built_in">rightRotate</span>(T,w);</span><br><span class="line">                w = x-&gt;p-&gt;right;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 经过了情况3 必然来到 情况 4，</span></span><br><span class="line">                w-&gt;color = x-&gt;p-&gt;color;</span><br><span class="line">                x-&gt;p-&gt;color = BLACK;</span><br><span class="line">                w-&gt;right-&gt;color = BLACK;</span><br><span class="line">                <span class="built_in">leftRotate</span>(T,x-&gt;p);</span><br><span class="line">                x = T-&gt;root;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            TreeNode *w = x-&gt;p-&gt;left;</span><br><span class="line">            <span class="keyword">if</span>(w-&gt;color == RED)&#123;</span><br><span class="line">                <span class="comment">// 情况1 x 的兄弟节点为红色</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">// 改变 w 和 w 的节点</span></span><br><span class="line">                w-&gt;color = BLACK;</span><br><span class="line">                x-&gt;p-&gt;color = RED;</span><br><span class="line">                <span class="comment">// 左旋，为保持红黑平衡</span></span><br><span class="line">                <span class="built_in">rightRotate</span>(T, x-&gt;p);</span><br><span class="line">                w = x-&gt;p-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(w-&gt;left-&gt;color==BLACK &amp;&amp; w-&gt;right-&gt;color == BLACK)&#123;</span><br><span class="line">                <span class="comment">// 情况2 w 的左右孩子都为黑</span></span><br><span class="line">                w-&gt;color = RED;</span><br><span class="line">                x = x-&gt;p;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(w-&gt;left-&gt;color==BLACK)&#123;</span><br><span class="line">                    <span class="comment">// 情况3 w 左孩子为红，右孩子为黑</span></span><br><span class="line">                    w-&gt;right-&gt;color = BLACK;</span><br><span class="line">                    w-&gt;color = RED;</span><br><span class="line">                    <span class="built_in">leftRotate</span>(T,w);</span><br><span class="line">                    w = x-&gt;p-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                w-&gt;color = x-&gt;p-&gt;color;</span><br><span class="line">                x-&gt;p-&gt;color = BLACK;</span><br><span class="line">                w-&gt;left-&gt;color = BLACK;</span><br><span class="line">                <span class="built_in">rightRotate</span>(T,x-&gt;p);</span><br><span class="line">                x==T-&gt;root;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    x-&gt;color = BLACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完整代码实现：<a href="https://github.com/wangjunstf/Data-Structure/tree/main/Red%E2%80%93Black-Tree">https://github.com/wangjunstf/Data-Structure/tree/main/Red–Black-Tree</a></p><p>下图作为测试图：</p><p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/IMG_4C19A2C5EF65-1.jpeg" alt="IMG_4C19A2C5EF65-1"></p><p><a href="https://github.com/wangjunstf/Data-Structure/blob/main/Red%E2%80%93Black-Tree/RedBlack.cpp">测试代码</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">$ ./rbtree </span><br><span class="line">中序遍历:3 7 10 12 14 15 16 17 19 20 21 23 26 28 30 35 38 39 41 47 </span><br><span class="line">最小值: 3 最大值: 47</span><br><span class="line"></span><br><span class="line">根节点的前驱23</span><br><span class="line">根节点的前驱28</span><br><span class="line"></span><br><span class="line">插入:40后结果：</span><br><span class="line">中序遍历:3 7 10 12 14 15 16 17 19 20 21 23 26 28 30 35 38 39 40 41 47 </span><br><span class="line"></span><br><span class="line">删除21</span><br><span class="line">中序遍历:3 7 10 12 14 15 16 17 19 20 23 26 28 30 35 38 39 40 41 47 </span><br><span class="line"></span><br><span class="line">注：以下测试可能不符合红黑性质但符合二叉搜索树性质</span><br><span class="line">将节点 14 左旋后的结果:</span><br><span class="line">中序遍历:3 7 10 12 14 15 16 17 19 20 23 26 28 30 35 38 39 40 41 47 </span><br><span class="line"></span><br><span class="line">将节点 41右旋后的结果:</span><br><span class="line">中序遍历:3 7 10 12 14 15 16 17 19 20 23 26 28 30 35 38 39 40 41 47 </span><br><span class="line"></span><br><span class="line">注：以下测试可能不符合红黑性质及二叉搜索树性质</span><br><span class="line">用 10 取代了 26 之后: </span><br><span class="line">中序遍历:3 7 10 12 </span><br></pre></td></tr></table></figure><h3 id="时间复杂度分析-2">时间复杂度分析</h3><p>一棵含有 n 个节点的红黑树的高度至多为 O(lg n) ，不进行颜色修复时，删除元素的时间复杂度为O(lg n)，进行颜色修复的过程 removeFixup ，情况 1，3，4各执行常数次的颜色改变和3次旋转便终止了，情况 2 是唯一会循环多次的情况，至多沿树上升 O(lg n) 次。所以过程 removeFixup需要花费时间是 O(lg n)。因此 删除元素总的时间复杂度为 O(lg n)。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 红黑树 </tag>
            
            <tag> 二叉搜索树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>快速排序分析及优化</title>
      <link href="/2021/09/02/kuai-su-pai-xu-yuan-li-ji-shi-jian-fu-za-du/"/>
      <url>/2021/09/02/kuai-su-pai-xu-yuan-li-ji-shi-jian-fu-za-du/</url>
      
        <content type="html"><![CDATA[<p>快速排序使用分治法实现，即一个一个复杂的问题分解为一系列容易解决的小问题，最终得到问题的解。</p><h1>算法步骤</h1><p>快速排序的三步分治过程：例如对 A[p…r] 进行快速排序</p><ol><li>分解：数组 A[p…r] 被划分为两个(可能为空)子数组 A[p…q-1] 和 A[p+1…r]，使得A[p…q-1] 中的每一个元素都小于 A[q]，而 A[q] 也小于等于 A[q+1…r]中的每个元素。其中，计算下标 q 也是划分过程的一部分。</li><li>解决：通过递归调用快速排序，对子数组A[p…q-1] 和  A[p+1…r] 进行排序。</li><li>合并：因为子数组都是原址排序，所以不需要合并操作，数组A[p…r]已经有序</li></ol><span id="more"></span><h1>c++ 代码实现</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="comment">// 将 q 作为基准，小于 q 的移到左边，大于 q 移动右边</span></span><br><span class="line">    <span class="type">int</span> q = A[low];   <span class="comment">//  A[low] 的值现在保存在 q 中，所以A[low] 可以作为空位   </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; A[high]&gt;=q)&#123;</span><br><span class="line">            <span class="comment">// 从右往左找，找到一个小于等于 q 的值</span></span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        A[low] = A[high];  <span class="comment">// 将找到的值移动到 A[low], A[high] 移动到了A[low]，此时A[high] 可以作为空位</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从左往右找，找到一个大于等于 q 的值 </span></span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        A[high] = A[low];  <span class="comment">// 将找到的值移动到 A[high]，此时A[low] 可以作为空位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当 low==high 时退出循环，A[low]作为空值，存储 q</span></span><br><span class="line">    A[low] = q;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="type">int</span> q = <span class="built_in">partition</span>(A, low, high); </span><br><span class="line">        <span class="built_in">qsort</span>(A,low,q<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">qsort</span>(A,q<span class="number">+1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="type">int</span> q = <span class="built_in">partition</span>(A, low, high);  <span class="comment">// 将数组划分为 左右两个子数组，满足左边数组的每个元素都小于等于右边数组元素</span></span><br><span class="line">        <span class="built_in">qsort</span>(A,low,q<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">qsort</span>(A,q<span class="number">+1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;vec = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">qsort</span>(vec,<span class="number">0</span>,vec.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:vec)&#123;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>时间复杂度分析</h1><p>快速排序的运行时间依赖于划分是否平衡，而平衡与否又依赖于划分的元素。如果划分是平衡的，那么快速排序算法性能与归并排序一样。如果划分是不平衡的，那么快速排序的性能就接近于插入排序。</p><h2 id="最坏情况划分">最坏情况划分</h2><p>当划分产生的两个子问题分别包含了 n-1 个元素和 0 个元素时，便是快速排序的最坏情况。</p><p>算法运行时间的递归式可以表示为: T(n) = T(n-1)+T(0)+Θ(n)，每一层递归的代价可以被累加起来，从而得到一个前n项和(或称级数)，其结果为 Θ(n<sup>2</sup>)。实际上，利用带入法可以直接得到递归式 T(n) = T(n-1)+Θ(n)的解为 T(n) = Θ(n<sup>2</sup>)。</p><p>因此，如果在算法的每一层递归上，划分都是最大程度不平衡，那么算法的时间复杂度就是 Θ(n<sup>2</sup>)。也就是说，在最坏情况下，快速排序的运行时间并不比插入排序更好。此外，当输入数组已经完全有序时，快速排序的时间复杂度仍然为 Θ(n<sup>2</sup>)。而在同样的情况下，插入排序的时间复杂度为 O(n)。</p><h2 id="最好情况划分">最好情况划分</h2><p>在可能的最平衡的划分中，partition 得到的两个子问题的规模都不大于 n/2。在这种情况下，快速排序的性能非常好。此时，算法运行时间的递归式为：T(n) = T(n-1) + Θ(n)，该递归式的解为 Θ(nlgn)。通过在每一层中都平衡划分子数组，我们得到了一个渐近时间更快的算法。</p><h2 id="平衡的划分">平衡的划分</h2><p>快速排序的平均运行时间更接近于其最好情况，而非最坏情况。</p><p>例如：假如划分算法总是产生9:1的划分，乍一看，划分很不平衡。此时，我们得到的快速排序时间复杂度的递归式为：T(n) = T(9n/10) + T(n/10) + cn。下图显示了这一递归调用所对应的递归树。注意，树中每一层的代价都是 cn，直到深度 $lg n$ =  Θ(lg n)处到达递归的边界条件为止。快速排序的总代价为 O(nlgn)</p><img src="https://raw.githubusercontent.com/wangjunstf/pics/main/uPic/%E6%88%AA%E5%B1%8F2021-08-28%20%E4%B8%8A%E5%8D%881.43.54.png" alt="截屏2021-08-28 上午1.43.54" style="zoom:50%;" /><h2 id="总结">总结</h2><p>快速排序时间复杂度：</p><ul><li>平均情况 O(nlgn)</li><li>最优情况 O(nlgn)</li><li>最坏情况 O(n<sup>2</sup>)</li></ul><p>空间复杂度 O(lg(n))</p><p>使用随机数来确定一个基准数，可以使划分左右序列更加合理。</p><h1>随机优化版本</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;A, <span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    random_device rd;                <span class="comment">// 随机数种子，每次运行都会生成不同的随机bit流</span></span><br><span class="line">    <span class="function">default_random_engine <span class="title">eng</span><span class="params">(rd())</span></span>; <span class="comment">// 生成随机的bit流</span></span><br><span class="line">    <span class="function">uniform_int_distribution&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(low, high)</span></span>; <span class="comment">// 通过调用产生dis(eng) 产生[low,high] 之间的随机数，包括边界low,high</span></span><br><span class="line">    <span class="type">int</span> id = <span class="built_in">dis</span>(eng);</span><br><span class="line">    <span class="built_in">swap</span>(A[low], A[id]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 q 作为基准，小于 q 的移到左边，大于 q 移动右边</span></span><br><span class="line">    <span class="type">int</span> q = A[low];   <span class="comment">//  A[low] 的值现在保存在 q 中，所以A[low] 可以作为空位   </span></span><br><span class="line">   </span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; A[high]&gt;=q)&#123;</span><br><span class="line">            <span class="comment">// 从右往左找，找到一个小于等于 q 的值</span></span><br><span class="line">            --high;</span><br><span class="line">        &#125;</span><br><span class="line">        A[low] = A[high];  <span class="comment">// 将找到的值移动到 A[low], A[high] 移动到了A[low]，此时A[high] 可以作为空位</span></span><br><span class="line">        <span class="keyword">while</span> (low &lt; high &amp;&amp; A[low] &lt;= q)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从左往右找，找到一个大于等于 q 的值 </span></span><br><span class="line">            ++low;</span><br><span class="line">        &#125;</span><br><span class="line">        A[high] = A[low];  <span class="comment">// 将找到的值移动到 A[high]，此时A[low] 可以作为空位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当 low==high 时退出循环，A[low]作为空值，存储 q</span></span><br><span class="line">    A[low] = q;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp;A,<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)&#123;</span><br><span class="line">        <span class="type">int</span> q = <span class="built_in">partition</span>(A, low, high); </span><br><span class="line">        <span class="built_in">qsort</span>(A,low,q<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">qsort</span>(A,q<span class="number">+1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt;vec = &#123;<span class="number">2</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">-2</span>,<span class="number">3</span>,<span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">qsort</span>(vec,<span class="number">0</span>,vec.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;x:vec)&#123;</span><br><span class="line">        cout&lt;&lt;x&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>参考</h1><p>《算法导论》</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 快速排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux umask chown chgrp</title>
      <link href="/2021/08/25/linux-umask-chown-chgrp/"/>
      <url>/2021/08/25/linux-umask-chown-chgrp/</url>
      
        <content type="html"><![CDATA[<h2 id="umask命令">umask命令</h2><h3 id="说明">说明</h3><p>umask命令指定在建立文件时预设的权限掩码。由3位八进制数字组成。<br>查看当前系统的文件掩码：<code>umask -S</code></p><span id="more"></span><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mygit@ubuntu:~/code$ umask</span><br><span class="line">0002  #第一位保留</span><br><span class="line">mygit@ubuntu:~/code$ umask -S</span><br><span class="line">u=rwx,g=rwx,o=rx</span><br><span class="line">mygit@ubuntu:~/code$ </span><br></pre></td></tr></table></figure><blockquote><p>Ubuntu 18.04.5 LTS 的默认掩码为：</p><p>u=rwx,g=rwx,o=rx</p></blockquote><h3 id="umask命令使用方式">umask命令使用方式</h3><p>umask [-S] maskcode</p><p>-S：用字符显示权限掩码</p><p>默认文件权限：666-umask</p><p>默认目录权限：777-umask</p><blockquote><p>666为普通文件最高权限，777为目录最高权限</p></blockquote><p>这里我有个疑问，为什么普通文件最高权限是666，目录最高权限是777？</p><p>通过查阅资料，总算知道了其中的奥秘。</p><blockquote><p><strong>读权限</strong></p><p>对文件：可以读取文件内容    对目录：可以浏览目录。</p><p><strong>写权限</strong></p><p>对文件：可以新增，修改，删除文件内容    对目录：可以新建，删除，修改，移动目录内文件。</p><p><strong>执行</strong></p><p>对文件：可以执行    对目录：可以进入该目录。</p><p>目录最高权限777，表示默认创建的目录，其所属用户和所属组除了读写外，还有进入目录的权限。</p><p>普通文件最高权限666，除了编译程序生成的可执行文件，通过其它方式创建的普通文件其所属用户和所属组默认只具有读和写权限，而没有执行权限。==通常情况下普通文件并不需要可执行权限，只有在必要时，可以给.sh等脚本文件赋予可执行权限==。</p><p>通常只有编译程序可以创建默认就可执行的文件，例如gcc。</p></blockquote><p>应为系统默认umask为 0002，第1位为保留位</p><p>因此，默认创建的普通文件权限为664，即u=rw-，g=rw-，o=r–； 默认创建的目录权限为：775，即u=rwx，g=rwx，o=r-x</p><blockquote><p>==默认创建的普通文件指的是由open(), creat(), mkdir(), mkfifo()函数创建的文件==。</p></blockquote><h2 id="chown命令">chown命令</h2><h3 id="说明-2">说明</h3><p>chown(change own)命令用于更改文件的所属用户和所属组</p><h3 id="使用方法">使用方法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chown mygit:mac t.txt   #将文件t.txt的拥有者改为mygit，所属组改为mac</span><br><span class="line">chown mygit t.txt #将文件t.txt的拥有者改为mygit,所属组不变</span><br><span class="line">chown :mac t.txt   #将文件t.txt的所属组改为mac，拥有者不变</span><br></pre></td></tr></table></figure><h3 id="chown命令参数">chown命令参数</h3><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-R</td><td>递归改变所有子目录和文件</td></tr><tr><td>-v</td><td>显示更改信息</td></tr></tbody></table><p>例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown -R -v root:root t   #递归改变目录t及其子目录内所有文件的所属用户和所属组，并显示更改信息</span><br></pre></td></tr></table></figure><h2 id="chgrp命令">chgrp命令</h2><h3 id="说明-3">说明</h3><p>chgrp(change group)命令用于改变文件所属组</p><h3 id="用法">用法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp root t.txt. #将t.txt的所属组改为bin</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> umask </tag>
            
            <tag> chown </tag>
            
            <tag> chgrp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 函数定义和调用</title>
      <link href="/2021/08/25/js-han-shu-ding-yi-he-diao-yong/"/>
      <url>/2021/08/25/js-han-shu-ding-yi-he-diao-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="函数定义">函数定义</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">abs</span>(<span class="params">x</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> -x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><p><strong>function</strong>表示函数定义，本质上是一个函数对象</p><p><strong>abs</strong>表示函数名字</p><p><strong>x</strong>为函数形参，其作用域仅为函数体内</p><p>{…}为函数体</p><p><strong>return</strong> 函数返回，表示函数执行完毕</p><blockquote><p><strong>return</strong>显式返回<strong>值</strong></p><p><strong>省略return</strong>时返回<strong>undefined</strong></p></blockquote><h2 id="函数调用">函数调用</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">abs</span>(-<span class="number">10</span>);  <span class="comment">//返回10</span></span><br><span class="line"><span class="title function_">abs</span>(<span class="number">9</span>);    <span class="comment">//返回9</span></span><br><span class="line"><span class="title function_">abs</span>(<span class="number">4</span>,<span class="string">&#x27;hel&#x27;</span>,<span class="string">&#x27;wor&#x27;</span>)  <span class="comment">//返回4</span></span><br><span class="line"><span class="title function_">abs</span>(-<span class="number">3</span>,<span class="string">&#x27;sdf&#x27;</span>,<span class="string">&#x27;12&#x27;</span>)  <span class="comment">//返回3</span></span><br><span class="line"><span class="title function_">abs</span>();     <span class="comment">//返回NaN</span></span><br></pre></td></tr></table></figure><p>函数实参(调用时传入的变量)个数，可以<strong>小于等于大于</strong>函数形参(函数定义的参数)个数：</p><p><strong>大于等于</strong>时：用函数实参依次初始化函数形参，多余的不作处理。<code>abs(4,'hel','wor') </code>，用4初始化abs，其余的忽略。</p><p><strong>小于</strong>时：未初始化的函数形参，则该参数为undefined。<code>abs()</code>，未初始化abs，其值为undefined，此时返回的结果为<strong>NaN</strong>，表示不是一个数字。</p><h2 id="传递多个参数">传递多个参数</h2><p>可以给函数传递多个参数，事先不确定，可能是1个，2个或多个。</p><h3 id="获取参数个数">获取参数个数</h3><p>利用arguments可以获取实际调用时传递的参数个数：<code>arguments.length</code></p><p>利用下标值获取参数的实际值：<code>arguments[i]</code></p><h3 id="传递任意个参数">传递任意个参数</h3><p>使用rest参数可以接收任意个形参，可以像使用数组一样使用它。</p><p><strong>任意参数个数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">//该函数求任意个数字的和</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">getSum</span>(<span class="params">...rest</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="variable language_">arguments</span>.<span class="property">length</span>; i++)&#123;</span><br><span class="line">                sum+=<span class="variable language_">arguments</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getSum</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>固定参数个数+rest的形式，但rest必须放在最后面。</p><p><strong>固定参数个数+任意参数个数</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">        <span class="comment">//求a和b的和，若传递外数字，则一并加上</span></span><br><span class="line">  <span class="comment">//若传递的参数小于2个，则返回NaN</span></span><br><span class="line">        <span class="keyword">function</span> <span class="title function_">getTwoSum</span>(<span class="params">a,b,...rest</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> sum = a+b;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">2</span>; i&lt;<span class="variable language_">arguments</span>.<span class="property">length</span>; i++)&#123;</span><br><span class="line">                sum+=<span class="variable language_">arguments</span>[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getTwoSum</span>(<span class="number">1</span>));</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getTwoSum</span>(<span class="number">1</span>,<span class="number">2</span>));</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getTwoSum</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="抛出异常">抛出异常</h2><p>有时函数需要传入一个整数，但调用者却传入一个字符串怎么办？</p><p>这时可以抛出一个异常，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">abs</span>(<span class="params">x</span>)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(<span class="keyword">typeof</span> x !== <span class="string">&#x27;number&#x27;</span>)&#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="string">&#x27;Not a number&#x27;</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span>(x&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">                       <span class="keyword">return</span> x;</span><br><span class="line">                   &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                       <span class="keyword">return</span> -x;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数 </tag>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 换行符 行结束符 文件结束符区别</title>
      <link href="/2021/08/24/linux-huan-xing-fu-xing-jie-shu-fu-wen-jian-jie-shu-fu-qu-bie/"/>
      <url>/2021/08/24/linux-huan-xing-fu-xing-jie-shu-fu-wen-jian-jie-shu-fu-qu-bie/</url>
      
        <content type="html"><![CDATA[<table><thead><tr><th>文件标记</th><th>Ascii</th><th>含义</th></tr></thead><tbody><tr><td>‘\n’</td><td>10</td><td>换行</td></tr><tr><td>‘\0’</td><td>0</td><td>c语言中表示字符串结束符</td></tr><tr><td>EOT</td><td>4</td><td>传输结束符</td></tr></tbody></table><p>**EOF（End of File）**是一个宏定义，其真实值根据不同平台有差异，通常为-1。表示操作系统无法从数据源获取更多数据的情况，数据源一般为文件或流。</p><p>**EOT（End-of-Transmission）**传输结束字符，是一个控制字符，表示传输的结束。ascii码为04</p><p><strong>‘\n’</strong> 在文本文件中，除了最后一行，其余的每一行行尾都有一个换行符，即’\n’，ascii码为10</p><p><strong>‘\0’</strong> 等价于NULL，在c语言中，并不存在真正的字符串类型。c语言中的字符串其实是char*指向的地址到’\0’前的字符，字符串的长度并不包括’\0’。例如:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *s = <span class="string">&quot;hello\0world&quot;</span>;<span class="comment">//表示字符串 hello \0位字符串结束符      </span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>,s);   <span class="comment">//输出hello</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 换行符 </tag>
            
            <tag> 行结束符号 </tag>
            
            <tag> 文件结束符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 简介</title>
      <link href="/2021/08/24/javascript-jian-jie/"/>
      <url>/2021/08/24/javascript-jian-jie/</url>
      
        <content type="html"><![CDATA[<h1>JavaScript 简介</h1><p>JavaScript （也称为JS）是一种高级的，解释型的编程语言。</p><h2 id="简洁性">简洁性</h2><p>其语法简洁，具有很高的抽象层次，只需很少量的代码就可实现复杂的逻辑交互，支持面向对象，命令式，函数式等编程思想。在JS中，函数也是一种类型，可以作为参数传递给某个函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="comment">//定义一个匿名求和函数，并将其存放到f变量中</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">function</span> (<span class="params">a, b</span>) &#123; <span class="keyword">return</span> a + b &#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">f</span>(<span class="number">12</span>,<span class="number">12</span>));   <span class="comment">//输出24</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><h2 id="安全性">安全性</h2><p>为了保证足够的安全性，语言本身不支持文件I/O，例如读取，修改本地文件等。但可以通过宿主环境实现文件I/O功能，如通过FileReader对象可以实现文件读取。</p><h2 id="通用性">通用性</h2><p>目前JS已经被世界主流浏览器所支持，比如：Chrome, Firefox, Safari, Opera，IE 等。</p><p>越来越多的网站采用了JS来实现复杂的网页交互，数据验证等。</p><h2 id="发展前景">发展前景</h2><p>Google开发的V8引擎，直接将JS代码翻译为及机器代码，极大地提高了JS的运行速度，运行缓慢已不在是JS的短板。</p><p>Node.js，使JS可以用于服务器端开发。</p><p>Electron，是GitHub开发的开源框架，采用Node.js作为后端，Chromium作为前端，是开发跨平台应用的的利器。</p><p>使用Electron开发的跨平台应用由：微软的Visual Studio Codd (VScode)</p><p>Atom</p>]]></content>
      
      
      <categories>
          
          <category> js </category>
          
      </categories>
      
      
        <tags>
            
            <tag> javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言数组作为函数参数</title>
      <link href="/2021/08/13/c-yu-yan-shu-zu-zuo-wei-han-shu-can-shu/"/>
      <url>/2021/08/13/c-yu-yan-shu-zu-zuo-wei-han-shu-can-shu/</url>
      
        <content type="html"><![CDATA[<h1>C语言数组作为函数参数</h1><h1>指针传递</h1><p><strong>传递的指针只包含数组的起始地址，要使用数组还应传出数组长度信息</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">arraySum</span><span class="params">(<span class="type">int</span> *p,<span class="type">int</span> length)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,arraySum(num,<span class="number">5</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">arraySum</span><span class="params">(<span class="type">int</span> *p,<span class="type">int</span> length)</span>&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        sum+=p[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;p[%d]=%d\n&quot;</span>,i,p[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum/length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>数组名传递</h1><p><strong>测试数组名称依旧是一个指针，和方法1本质是一样的，只是书写形式不一样。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">arrayPrint</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> num[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">    arrayPrint(num,<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">arrayPrint</span><span class="params">(<span class="type">int</span> arr[],<span class="type">int</span> len)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt; len; i++)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>二维数组传参</h1><p><strong>二维数组的本质是一维数组的数组，即多个一维数组组成的数组，在函数定义中，形参数组必须给出低维数组元素的个数</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">arrayPrint</span><span class="params">(<span class="type">int</span> arr[][<span class="number">3</span>],<span class="type">int</span> row,<span class="type">int</span> column)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="built_in">array</span>[<span class="number">3</span>][<span class="number">3</span>] = &#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;;</span><br><span class="line">    arrayPrint(<span class="built_in">array</span>,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">arrayPrint</span><span class="params">(<span class="type">int</span> arr[][<span class="number">3</span>],<span class="type">int</span> row,<span class="type">int</span> column)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;column;j++)&#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr[i][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>多维数组传参</h1><p><strong>多维数组的本质是多个次低维数组组成的数组。类比方法3，多维数组传参要给出次低维数组的所有信息。</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">arrayprint3</span><span class="params">(<span class="type">int</span> arr[][<span class="number">3</span>][<span class="number">3</span>],<span class="type">int</span> count,<span class="type">int</span> row,<span class="type">int</span> column)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">int</span> arrays[<span class="number">3</span>][<span class="number">3</span>][<span class="number">3</span>] = &#123;&#123;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;,&#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;,&#123;<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;&#125;,&#123;&#123;<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>&#125;,&#123;<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;,&#123;<span class="number">16</span>,<span class="number">17</span>,<span class="number">18</span>&#125;&#125;,&#123;&#123;<span class="number">19</span>,<span class="number">20</span>,<span class="number">21</span>&#125;,&#123;<span class="number">22</span>,<span class="number">23</span>,<span class="number">24</span>&#125;,&#123;<span class="number">25</span>,<span class="number">26</span>,<span class="number">27</span>&#125;&#125;&#125;;</span><br><span class="line">    arrayprint3(arrays,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">arrayprint3</span><span class="params">(<span class="type">int</span> arr[][<span class="number">3</span>][<span class="number">3</span>],<span class="type">int</span> count,<span class="type">int</span> row,<span class="type">int</span> column)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;count;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;row; j++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;column; k++)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,arr[i][j][k]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c </tag>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多级反馈队列</title>
      <link href="/2021/07/18/duo-ji-fan-kui-dui-lie/"/>
      <url>/2021/07/18/duo-ji-fan-kui-dui-lie/</url>
      
        <content type="html"><![CDATA[<p>1962 年，Corbato 首次提出多级反馈队列(Multi-level Feedback Queue, MLFQ)，应用于兼容时分共享系统(CTSS)。</p><p>多级反馈队列需要解决两方面的问题：</p><ol><li>优化周转时间，这通过先执行短工作来实现。</li><li>降低响应时间，像轮转这样的算法降低了响应时间，但周转时间很差。</li></ol><span id="more"></span><p>以下是多级反馈队列（MLFQ）规则：</p><ul><li>规则 1: 如果 A 的优先级 &gt; B 的优先级，运行 A(不运行B)。</li><li>规则 2: 如果 A 的优先级 = B 的优先级，轮转运行 A 和 B。</li><li>规则 3: 工作进入系统时，放在最高优先级(最上层队列)。</li><li>规则 4: 一旦工作用完了其在某一层中的时间配额(无论中间主动放弃了多少次 CPU)，就降低其优先级(移入低一级队列)。</li><li>规则 5: 经过一段时间 S，就将系统中所有工作重新加入最高优先级队列。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程 </tag>
            
            <tag> 调度算法 </tag>
            
            <tag> 多级反馈队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多处理器调度</title>
      <link href="/2021/07/18/duo-chu-li-qi-diao-du/"/>
      <url>/2021/07/18/duo-chu-li-qi-diao-du/</url>
      
        <content type="html"><![CDATA[<h1>早期系统</h1><p>操作系统曾经是一组函数(实际上是一个库)，在内存中(在本例中，从物理地址0开始)，然后有一个正在运行的程序(进程)，在目前物理内存中(本例中，从物理地址 64KB 开始)，并使用剩余内存。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-07-17%20%E4%B8%8B%E5%8D%886.22.05.png" alt="截屏2021-07-17 下午6.22.05" style="zoom:67%;" /><span id="more"></span><h1>多道程序和时分共享</h1><p>由于机器昂贵，人们开始更有效地共享机器，因此，多道程序系统时代开启。其中有多个进程在给定时间准备运行，比如当有一个进程在等待 I/O 操作的时候，操作系统会切换这些进程，这样增加了 CPU 的利用率。</p><p>一种实现时分共享的方法，是让一个进程单独占用全部内存运行一段时间，然后停止，并将它的所有状态信息保存在磁盘上(包含所有的物理内存)，加载其他进程的状态信息，再运行一段时间，这就实现了比较粗糙的机器共享。遗憾的是，这种方式太慢了。</p><p>因此，我们仍然将进程信息放在内存中，这样操作系统可以更有效率低实现时分共享。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-07-17%20%E4%B8%8B%E5%8D%886.36.15.png" alt="截屏2021-07-17 下午6.36.15" style="zoom: 50%;" /><p>如上图所示，每个进程拥有一部分内存，假定只有一个 CPU ，操作系统选择运行其中一个进程(比如 A)，同时其他进程(B 和 C)则在队列中等待运行。</p><p>随着时分共享变得流行，人们对操作系统有了新的要求，特别是多个程序同时驻留在内存中，使保护(protection)成为重要问题。</p><h1>地址空间</h1><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-07-17%20%E4%B8%8B%E5%8D%886.42.51.png" alt="截屏2021-07-17 下午6.42.51" style="zoom:50%;" /><p>上图中，当我们描述地址空间时，所描述的是操作系统提供给运行程序的抽象(abstract)。程序并不在物理地址0~16KB 的内存中，而是加载到任意的物理地址。</p><p>运行的程序认为它被加载到特定的地址(例如 0)的内存中，并且具有非常大的地址空间。如图 13-2中的进程 A 尝试在地址0(虚拟地址)执行加载操作时，然而操作系统在硬件支持下，出于某种原因，必须确保不是加载到物理地址 0，而是物理地址 320KB(这是 A 载入内存的地址)。这是虚拟化的关键，这是世界上每一个现代计算机系统的基础。</p><blockquote><p>微内核：通过将内核隔离，操作系统进一步确保运行程序不会影响底层操作系统的操作。一些现代操作系统通过将某些部分与操作系统的其他部分分离，实现进一步的隔离。这样的微内核(microkernel)可以比整体内核提供更大的可靠性。</p></blockquote><h1>目标</h1><p>虚拟内存(VM)系统的主要目标是：</p><ol><li><p>透明(transparency)。操作系统实现虚拟内存的方式，应该让运行的程序看不见，因此，程序不应该感知到内存被虚拟化的事实，相反，程序的行为就好像它拥有自己的私有物理内存。</p></li><li><p>效率(efficient)。包括时间和空间。</p></li><li><p>保护(protection)。操作系统应该确保进程受到保护，不会受到其他进程的影响，操作系统本身也不会受到进程的影响。每个进程都应该在独立环境中运行，避免其他出错或恶意进程的影响。</p></li></ol><p>关于虚拟化内存，需要清楚以下内容：如何管理可用空间，以及在空间不足时哪些页面该释放。</p><h1>小结</h1><p>虚拟内存系统负责为程序提供一个巨大的，稀疏的，私有的地址空间的假象，其中保存了程序的所有指令和数据。操作系统在专门的硬件的帮助下，通过每一个虚拟内存的索引，将其转化为物理地址，物理内存根据获得的物理地址去获取所需的信息。操作系统同时对许多进程执行此操作，并且确保程序之间不会受到影响，也不会影响操作系统。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> 处理器调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>比例份额调度</title>
      <link href="/2021/07/17/bi-li-fen-e-diao-du/"/>
      <url>/2021/07/17/bi-li-fen-e-diao-du/</url>
      
        <content type="html"><![CDATA[<p>比例份额(proportional-share)调度程序，也称公平份额(fair-share)调度程序。比例份额算法基于一个简单的想法：调度程序的最终目标是，确保每个工作获得一定比例的 CPU 时间，而不是优化周转时间和响应时间。</p><p><strong>彩票调度</strong>是一个非常优秀的比例调度程序。</p><h1>基本概念：彩票数表示份额</h1><p>彩票数(ticket)代表了进程(或用户或其他)占用了某个资源的份额。例如：假设两个进程 A 和 B，A 拥有 75 张彩票，B 拥有 25 张。因此我们希望 A 占用 75% 的 CPU 时间，而 B 占用 25%。</p><span id="more"></span><p>我们可以将彩票进行编号，例如：进程 A 拥有 0 到 74 共 75 张彩票，而进程 B 拥有 75 到 99 共 25 张，然后使用随机数来决定运行哪个进程。</p><h1>彩票机制</h1><p>彩票货币(ticket currency):</p><p>运行拥有一组彩票的用户以它们喜欢的某种货币，将彩票分给自己的不同工作，之后操作系统自动将这些货币兑换为正确的全局彩票。</p><p>彩票转让(ticket transfer)</p><p>通过转让，一个进程可以临时将自己的彩票交给另一个进程。适用于客户端/服务端。</p><p>彩票通胀(ticket inflation)</p><p>利用通胀，一个进程可以临时提升或降低自己拥有的彩票数量。如果一个进程知道它需要更多 CPU 时间，可以将自己的需求告诉 操作系统，就可以增加自己的彩票。</p><h1>实现</h1><p>假定我们用列表记录进程。下面的例子中有 A，B，C 这 3 个进程，每个进程有一定数量的彩票。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-07-17%20%E4%B8%8B%E5%8D%885.03.40.png" alt="截屏2021-07-17 下午5.03.40" style="zoom:67%;" /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int counter = 0;          </span><br><span class="line"></span><br><span class="line">int winner = getrandom(0,totaltickets);</span><br><span class="line"></span><br><span class="line">node_t *current = head;</span><br><span class="line"></span><br><span class="line">while(current)&#123;</span><br><span class="line">counter = counter + cuttent-&gt;tickets;</span><br><span class="line">if(counter &gt; winner)</span><br><span class="line">break;</span><br><span class="line">current = current-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>一个例子</h1><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-07-17%20%E4%B8%8B%E5%8D%885.17.22.png" alt="截屏2021-07-17 下午5.17.22" style="zoom: 33%;" /><p>只有当工作执行非常多的时间片，彩票调度算法才得到期望的结果。</p><h1>为什么是不确定的</h1><p>随机性并不总是产生正确的比例。基于这个原因，之后 Waldspurger 提出了步长调度(stride scheduling)，一个确定性的公平分配算法。</p><p>在步长调度中，每个工作都有自己的步长，这个值与票数成反比。在上面的例子中，A，B，C这 3 个工作的票数分别是 100，50和 250，我们通过使用一个大数分别除以它们的票数来获得每个进程的步长。比如用 10000 除以票数值，得到 3 个进程的步长分别为 100，200和40。</p><p>每次进程运行后，我们让它的计数器[称为形成(pass)值]增加它的步长，记录它的总体进展。当需要进行调度时，选择目前拥有最小行程值的进程，并且在运行后将该进程的行程值增加一个步长。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">current = remove_min(queue);</span><br><span class="line">schedule(current);</span><br><span class="line">current-&gt;pass += current-&gt;stride;</span><br><span class="line">insert(queue,current);</span><br></pre></td></tr></table></figure><h1>小结</h1><p>比例份额调度有两种实现：彩票调度和步长调度。</p><p>两者没有得到广泛运行，一方面是不能很好地适合 I/O，另一个原因是最难的票数分配问题没有确定的解决方式。</p><p>比例份额调度程序适用于：容易确定份额比例的场合。例如：在虚拟机(virtualized) 数据中心中，比例分配的方式可以更简单高效。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 调度算法 </tag>
            
            <tag> 比例份额调度 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C语言文件打开模式</title>
      <link href="/2021/07/16/c-yu-yan-wen-jian-da-kai-mo-shi/"/>
      <url>/2021/07/16/c-yu-yan-wen-jian-da-kai-mo-shi/</url>
      
        <content type="html"><![CDATA[<h1>c语言文件打开模式</h1><h2 id="以c-string-方式打开">以c string 方式打开</h2><table><thead><tr><th>文件打开模式</th><th style="text-align:center">含义</th></tr></thead><tbody><tr><td>“r”</td><td style="text-align:center">以只读方式打开文件，该文件必须存在</td></tr><tr><td>”w“</td><td style="text-align:center">只写方式创建并打开一个空文件，若存在同名文件，则丢弃全部数据，作为一个空文件</td></tr><tr><td>“a”</td><td style="text-align:center">附加模式(append)，只写打开文件，在文件末尾写入数据，若文件不存在，则创建该文件。重定位操作（<a href="http://www.cplusplus.com/fseek">fseek</a>，<a href="http://www.cplusplus.com/fsetpos">fsetpos</a>，<a href="http://www.cplusplus.com/rewind">rewind</a>）将被忽略。</td></tr><tr><td>“r+”</td><td style="text-align:center">读或修改：打开的文件可读可写，但该文件必须存在。</td></tr><tr><td>“w+”</td><td style="text-align:center">写或修改：创建一个空文件进行读取或写入。如果已经存在同名文件，则将其内容丢弃，作为一个空文件。</td></tr><tr><td>“a+“</td><td style="text-align:center">附加或修改：打开文件进行读或写，所有输出操作均在文件末尾写入数据。重新定位操作（<a href="http://www.cplusplus.com/fseek">fseek</a>，<a href="http://www.cplusplus.com/fsetpos">fsetpos</a>，<a href="http://www.cplusplus.com/rewind">rewind</a>）会影响下一次读取。如果文件不存在，则创建该文件。</td></tr></tbody></table><span id="more"></span><h2 id="以二进制方式打开文件">以二进制方式打开文件</h2><p>如果需要作为二进制打开文件，则在相应的模式名后加’b’字符即可，例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rb wb ab r+b w+b a+b</span><br><span class="line">或者 rb+ wb+ ab+</span><br></pre></td></tr></table></figure><p><strong>新的c标准(c11)</strong></p><p>从上述内容可以知道，写相关操作(w)，当存在同名文件时，会丢弃该文件的所有数据，如果错误使用该模式可能会丢失数据。</p><p>c11定义了新的<strong>子说明符’x’</strong>，当<strong>文件存在</strong>时，则<strong>终止该函数</strong>。例如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">”wx“, “wbx”</span><br><span class="line">“w+x” 或 “w+bx”/“wb+x”</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cpp </tag>
            
            <tag> 文件打开模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>进程调度</title>
      <link href="/2021/07/15/jin-cheng-diao-du/"/>
      <url>/2021/07/15/jin-cheng-diao-du/</url>
      
        <content type="html"><![CDATA[<h2 id="调度指标">调度指标</h2><p>周转时间</p><p>T<sub>周转时间</sub>=T<sub>完成时间</sub>-T<sub>到达时间</sub></p><p>如果所有任务在同一时间到达，那么 T<sub>完成时间</sub> = 0，T<sub>周转时间</sub> = T<sub>完成时间</sub></p><h2 id="先进先出-FIFO">先进先出(FIFO)</h2><p>(1) 假设有 3 个工作 A，B和C在大致在同一时间到达，A 比 B 早一点，B 比 C 早一点，假设每个工作的运行 10s，计算周转时间？</p><span id="more"></span><p>(10+20+30)/3=20</p><p>(2) 同(1)，不过这次 A 运行 100s，B和C运行10秒，计算周转时间？</p><p>(100+110+120)/3=110</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-07-15%20%E4%B8%8A%E5%8D%8810.51.35.png" alt="截屏2021-07-15 上午10.51.35"></p><p>在 (2) 中，周转时间显著增长，这种问题称为护航效应(convoy effect)，一些耗时较少的潜在资源消费者被排在耗时较长的重量级资源消费者之后。</p><h2 id="最短任务优先-SJF">最短任务优先(SJF)</h2><p>先运行最短的任务，然后是次短的任务。</p><p>(1) 假设有 3 个工作 A，B和C在大致在同一时间到达，A 比 B 早一点，B 比 C 早一点，假设每个工作的运行 10s，计算周转时间？</p><p>(10+20+120)/3=50s</p><p>(2) 还是(1)中例子，不过此时A先到达，B和C在 t=10 到达。</p><p>(100+(110-10)+(120-10))/3= 103.33</p><p>这里还是会遭遇护航问题。</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-07-15%20%E4%B8%8A%E5%8D%8811.27.10.png" alt="截屏2021-07-15 上午11.27.10"></p><h2 id="最短完成时间优先-STCF">最短完成时间优先(STCF)</h2><p>将 SJF 添加抢占特性，成为最短完成时间优先(Shortest Time-to-Completion First, STCF)或抢占式最短作业优先(Preemptive Shortest Job First, PSJF)。这种调度程序称为抢占式调度程序。</p><p>3.1 假设有 3 个工作 A，B和C在大致在同一时间到达，A先到达，B和C在 t=10 到达，计算周转时间？</p><p>((20-10)+(30-10)+120)/3=50s，可见平均周转时间大大提高了。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-07-15%20%E4%B8%8A%E5%8D%8811.28.19.png" alt="截屏2021-07-15 上午11.28.19" style="zoom:67%;" /><p>假设工作必须保持运行直到完成，这时STCF是最优的，如果考虑所有工作同时到达，SJF 是最优的。</p><h2 id="新度量指标：响应时间">新度量指标：响应时间</h2><p>自从引入了分时系统，现在，用户将会坐在终端前面，这时要求系统的交互性好，即能在最短时间内获得响应。因此，一个新的度量标准诞生了：响应时间(response time)</p><p>T<sub>响应时间</sub>=T<sub>首次运行时间</sub>-T<sub>到达时间</sub></p><p>例如： 使用 3.1 的作业，A 在时间 0 到达，B 和 C 在时间 10 到达。每个作业的响应时间如下：作业 A 为 0，作业 B 为 0，作业 C 为10(平均: 3.33)</p><p>STCF 和相关方法在响应时间上并不是很好，例如，如果 3 个工作同时到达，第 3 个工做必须等待前两个工作全部运行后才能运行。</p><h2 id="轮转">轮转</h2><p>通常称为轮转(Round-Robin，RR)调度。其基本思想是：RR 在一个时间片(time slice)内运行一个工作，然后切换到运行队列的下一个任务，而不是运行一个任务直到结束。它反复执行，直到所有任务完成。RR 有时被称为时间片(time-slicing)。时间片长度必须是时钟中断周期的倍数。如果时钟中断是每 10ms 中断一次，则时间片可以是 10ms，20ms或者 10ms。</p><p>例如：现有 3 个任务 A，B和C在系统中同时到达，并且它们都希望运行 5s。SJF 调度程序必须完成当前任务才可以运行下一个任务。1s 时间片的 RR 可以快速地循环工作。</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-07-15%20%E4%B8%8B%E5%8D%885.08.17.png" alt="截屏2021-07-15 下午5.08.17"></p><p>RR 的平均响应时间：(0+1+2)/3=1</p><p>SJF 的平均响应时间：(0+5+10)/3=5</p><p>时间片越短，RR 在响应时间上表现越好，然后短也会造成上下文切换的成本过大。</p><blockquote><p>摊销可以减少成本，时间片越大，上下文切换的成本就越低。</p></blockquote><p>如果响应是唯一指标，那么带有合理时间片的 RR 就会使非常好的调度程序。</p><p>如果考虑周转时间，那么 RR 会是糟糕的策略。</p><h2 id="结合-I-O">结合 I/O</h2><p>假设两项工作 A 和 B，每项工作都需要 50 ms的 CPU 时间，A 运行 10 ms，然后发出 I/O 请求，假设每个 I/O 请求都需要 10 ms，而 B 只使用 CPU 50 ms，不执行 I/O。调度程序先运行 A，然后运行B。</p><p>一种常见的方法是将 A 的每个 10ms 的子工作视为一项独立工作。因此，当系统启动时，它的选择是调度 10ms 的A，还是 50ms 的B。使用STCF，选择是明确的。</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-07-15%20%E4%B8%8B%E5%8D%885.42.28.png" alt="截屏2021-07-15 下午5.42.28"></p><h2 id="无法预知">无法预知</h2><p>前面的讨论都基于这样一个假设，就是作业的运行时间已知。但实际情况是操作系统对每个作业的运行时间知之甚少。因此，我们如何建立一个没有这种先验知识的 SJF/STCF？更进一步，我们如何将已经看到的一些想法与 RR 调度程序结合起来，以便响应时间也变得相当不错。</p><h2 id="小结">小结</h2><p>我们介绍了调度的基本思想，并开发了两类方法。第一类是运行最短的工作，从而优化周转时间。第二类是交替运行所有工作，从而优化响应时间。很难做到“鱼和熊掌兼得”，这是系统中常见的，固有的折中。我们也看到了如何将 I/O 结合到场景中，但仍未解决操作系统根本无法看到未来的问题。稍后，我们将看到如何通过构建一个调度程序，利用最近的历史预测未来，从而解决这个问题。这个调度程序称为多级反馈队列。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 进程调度 </tag>
            
            <tag> 最短任务优先 </tag>
            
            <tag> 时间片轮转 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh配置免密登录</title>
      <link href="/2021/07/14/ssh-pei-zhi-mian-mi-deng-lu/"/>
      <url>/2021/07/14/ssh-pei-zhi-mian-mi-deng-lu/</url>
      
        <content type="html"><![CDATA[<p>通过配置密钥，可以免密登录远程主机。</p><p>在需要登录远程主机的终端输入命令：</p><span id="more"></span><h2 id="第一步：生成本机密钥">第一步：生成本机密钥</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa   #rsa指定加密类型</span><br></pre></td></tr></table></figure><p>会有几个选项，回车即可<br>看到该图案，代表配置成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">+---[RSA 3072]----+</span><br><span class="line">|        o=+      |</span><br><span class="line">|         o.     .|</span><br><span class="line">|        .  .  o +|</span><br><span class="line">|       . ... . +=|</span><br><span class="line">|        S +..o=++|</span><br><span class="line">|         o =++.=*|</span><br><span class="line">|          * o..*+|</span><br><span class="line">|         + + .=o=|</span><br><span class="line">|        .Eoo*oo=+|</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/ssh-keygen.png" alt=""></p><p>进入密钥所在目录:</p><h2 id="第二步：复制公钥">第二步：复制公钥</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── config</span><br><span class="line">├── id_rsa</span><br><span class="line">├── id_rsa.pub</span><br><span class="line">├── known_hosts</span><br><span class="line">└── known_hosts.old</span><br></pre></td></tr></table></figure><p>id_rsa为私钥，只能自己所有，不能分享给别人<br>id_rsa.pub为公钥，部署到其它主机就可以与本机安全通信。</p><p>公钥和私钥的区别：<strong>私钥加密，公钥解密</strong></p><blockquote><ol><li><strong>Bob将他的公开密钥传送给Alice</strong>。</li><li><strong>Alice用Bob的公开密钥加密她的消息，然后传送给<br>Bob</strong>。</li><li><strong>Bob用他的私人密钥解密Alice的消息</strong>。</li></ol></blockquote><p>打开id_rsa.pub，复制其内容</p><h2 id="第三步：服务器配置">第三步：服务器配置</h2><p>执行和本机一样的命令，并按回车：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa   #rsa指定加密类型</span><br></pre></td></tr></table></figure><p>生成了.ssh文件，进入该目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/.ssh</span><br><span class="line">vim authorized_keys</span><br></pre></td></tr></table></figure><p>将第二步复制的公钥粘贴进authorized_keys，注意不要粘贴多余的字符，比如空格或者回车。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> ssh </tag>
            
            <tag> 免密登录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统虚拟化技术的机制——受限直接执行</title>
      <link href="/2021/07/14/cao-zuo-xi-tong-xu-ni-hua-ji-zhu-de-ji-zhi-shou-xian-zhi-jie-zhi-xing/"/>
      <url>/2021/07/14/cao-zuo-xi-tong-xu-ni-hua-ji-zhu-de-ji-zhi-shou-xian-zhi-jie-zhi-xing/</url>
      
        <content type="html"><![CDATA[<h1>基本技巧：受限直接执行</h1><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-07-14%20%E4%B8%8A%E5%8D%8811.54.34.png" alt="截屏2021-07-14 上午11.54.34" style="zoom: 50%;" /><p>上述方式产生的问题：</p><ul><li>操作系统如何确保程序不做任何我们不希望它做的事，同时仍然高效地运行它。</li><li>当运行一个进程时，操作系统如何让它停下来并切换到另一个进程。</li></ul><span id="more"></span><h1>问题1：受限制的操作</h1><p>硬件通过提供不同的执行模式来协助操作系统。例如：</p><ol><li>在用户模式下，应用程序不能完全访问硬件资源，不能发出 I/O 请求，这样做会导致处理器引发异常，操作系统可能会终止进程。</li><li>在内核模式下，操作系统可以访问机器的全部资源</li></ol><p>那么当用户模式下进程想要执行某些特权操作该怎么办？</p><p>为了实现这一点，几乎所有的现代硬件都提供了用户程序执行系统调用的能力，它允许内核小心地向用户程序暴露某些关键功能，例如访问文件系统，创建和销毁进程，与其他进程通信，以及分配更大的内存。</p><p><strong>要执行系统调用，程序必须执行特殊的陷阱(trap)指令，该指令同时调入内核并将特权级别提升到内核模式。进入内核后，就可以执行某些特权操作。执行完成后，该指令返回到发起调用的用户程序中，同时将特权级别降低，回到用户模式。</strong></p><p>执行陷阱(trap)指令时，硬件需要确保存储足够的调用者寄存器，以便在操作系统发出从陷阱返回指令时能够正确返回。例如：<strong>在 x86 上，处理器会将程序计数器，标志和其他一些寄存器推送到每个进程的内核栈(kernel stack)上。从陷阱返回将从内核栈弹出这些值，并恢复执行用户模式程序。</strong></p><p>问题：陷阱如何知道在 os 内运行哪些代码？显然，发起系统调用的过程不能指定要跳转的地址。内核通过在启动时设置陷阱表(trap table) 来实现。当机器启动时，它在特权(内核)模式下执行，因此可以根据需要自由配置机器硬件。操作系统做的第一件事，就是告诉硬件在发生某些异常事件时需要运行哪些代码。例如：当发生硬盘中断，发生键盘中断或程序进行系统调用时，应该执行哪些代码。<strong>当进程进行系统调用时，使用与内核一致的系统调用约定来将参数放在一个众所周知的位置(例如，在栈中或特定的寄存器中)，将系统调用号也放入一个众所周知的位置(同样，放在栈或寄存器中)，然后执行陷阱(trap)指令。库中陷阱之后的的代码准备好返回值，并将控制权返回给发出系统调用的程序。</strong></p><p>能够执行指令来告诉硬件陷阱表的位置是一个非常强大的功能，它是一项特权操作，用户模式下执行这个指令会产生异常。</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-07-14%20%E4%B8%8B%E5%8D%881.08.14.png" alt="截屏2021-07-14 下午1.08.14"></p><p>LDE 协议有 2 个阶段：</p><p>第 1 阶段：系统引导时，内核初始化陷阱表，并且 CPU 记住它的位置以供随后使用。</p><p>第 2 阶段：(1) 程序运行时，在使用从陷阱指令返回指令开始执行进程之前，内核设置一些内容(例如：分配内存)，然后将 CPU 切换到用户模式并开始运行该进程。当进程发出系统调用时，它会重新陷入操作系统，然后再次通过从陷阱返回，将控制权还给进程。(2) 当该进程完成它的工作，并从 main() 返回。这通常会返回到一些存根代码，它将正确退出该程序(例如，通过 exit() 系统调用，这将陷入 OS 中)。最后，OS 清理干净，任务完成了。</p><h1>问题2：在进程之间切换</h1><blockquote><p>关键问题？</p><p>操作系统如何重新获得 CPU 的控制权(regain control)，以便它可以在进程之间切换？</p></blockquote><p>协作方式：等待系统调用。这种方式相信进程会合理利用 CPU，并在适当时候将控制权移交给操作系统。但也可能存在恶意程序或者程序出现错误而导致无限循环。</p><p>非协作方式：操作系统进行控制</p><p>如何在没有协作的情况下获得控制权？答案很简单，许多年前构建计算机系统的许多人都发现了：时钟中断(timer interrupt)。时钟设备可以编程为每隔几毫秒产生一次中断。产生中断时，当前正在运行的进程停止，操作系统中预先配置的中断处理处理程序(interrupt handler) 会运行。此时，操作系统重新获得 CPU 的控制权，因此可以做它想做的事：停止当前进程，并启动另一个进程。</p><p>操作系统必须通知硬件哪些代码在发生时钟中断时运行。当然，硬件在发生中断时有一定责任，要为正在运行的程序保存足够的状态，以便随后从陷阱返回指令能够正确恢复正在运行的程序，以便随后从陷阱返回指令能够正确恢复正在运行的程序。</p><p>保存和恢复上下文</p><p>操作系统获得控制权，需要决定是继续运行当前正在运行的进程，还是切换到另一个进程。这个决策由 调用程序(scheduler) 做出的，它是操作系统的一部分。</p><p>如果决定进行切换，OS 就会执行一些底层代码，即所谓的上下文切换(context switch)。上下文切换在概念上很简单：操作系统要做的就是为当前正在执行的进程保存一些寄存器的值到它的内核栈，并为即将执行的进程恢复一些寄存器的值(从它的内核栈)。这样一来，操作系统就可以确保最后执行从陷阱返回指令时，不是返回到之前运行的进程，而是继续执行另一个进程。</p><p>为了保存当前正在执行的进程的上下文，操作系统会执行一些底层汇编代码，来保存通用寄存器，程序计数器，以及当前正在运行的进程的内核栈指针，然后恢复寄存器，程序计数器，并切换内核栈，供即将运行的进程使用。通过切换栈，内核在进入切换代码调用时，是一个进程(被中断的进程)的上下文，在返回时，是另一个进程(即将执行的进程)的上下文。当操作系统最终执行从陷阱返回指令时，即将执行的进程变成了当前运行的进程。至此上下文切换完毕。</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-07-14%20%E4%B8%8B%E5%8D%885.55.02.png" alt="截屏2021-07-14 下午5.55.02"></p><p>在此协议中，有两种类型的寄存器保存/恢复。第 1 次是发生在时钟中断的时候。在这种情况下，运行进程的用户寄存器由硬件隐式保存，使用该进程的内核栈。第 2 种是当操作系统决定从 A 切换到 B。在这种情况下，内核寄存器被软件(即 OS)明确保存，但这次被存储在该进程的进程结构的内存中。后一个操作让系统从好像刚刚由 A 陷入内核，变为好像刚刚由 B 陷入内核。。</p><p>下列代码是 xv6 的上下文切换代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># Context switch</span><br><span class="line">#</span><br><span class="line">#   void swtch(struct context **old, struct context *new);</span><br><span class="line"># </span><br><span class="line"># Save the current registers on the stack, creating</span><br><span class="line"># a struct context, and save its address in *old.</span><br><span class="line"># Switch stacks to new and pop previously-saved registers.</span><br><span class="line"></span><br><span class="line">.globl swtch</span><br><span class="line">swtch:</span><br><span class="line">  movl 4(%esp), %eax      # eax 为 old     </span><br><span class="line">  movl 8(%esp), %edx      # edx 为 new</span><br><span class="line"></span><br><span class="line">  # Save old callee-saved registers</span><br><span class="line">  pushl %ebp</span><br><span class="line">  pushl %ebx</span><br><span class="line">  pushl %esi</span><br><span class="line">  pushl %edi</span><br><span class="line"></span><br><span class="line">  # Switch stacks</span><br><span class="line">  movl %esp, (%eax)      # 保存当前进程的栈基址。将当前栈基址保存到 old 指针的值</span><br><span class="line">  movl %edx, %esp        # 切换栈基址。将 new 保存到 esp</span><br><span class="line"></span><br><span class="line">  # Load new callee-saved registers</span><br><span class="line">  popl %edi</span><br><span class="line">  popl %esi</span><br><span class="line">  popl %ebx</span><br><span class="line">  popl %ebp</span><br><span class="line">  ret</span><br></pre></td></tr></table></figure><p>上述功能实现交换两个进程栈基址的交换。</p><h1>担心并发吗</h1><p>如果在中断或陷阱处理过程中发生另一个中断，那么操作系统确实需要关心发生了什么。具体内容将在第 2 部分并发讲解。</p><h1>小节</h1><p>重新启动很有用，因为它让软件回到已知状态，很可能是回到经过更多测试的状态。重新启动还可以回收旧或泄露的资源(例如内存)，否则这些资源可能很难处理。</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 虚拟化 </tag>
            
            <tag> 受限直接执行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB 入门教程</title>
      <link href="/2021/06/12/gdb-ru-men-jiao-cheng/"/>
      <url>/2021/06/12/gdb-ru-men-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<p>假设当前目录下共有以下3个文件，接下来会利用以下代码来演示GDB的调试过程。</p><p>├── main.cpp</p><p>├── tool.h</p><p>└── tools.cpp</p><p>文件内容分别为：</p><p>tools.h：函数声明</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _TOOLS_H_</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _TOOLS_H_</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">greeting</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* tools.h */</span></span></span><br></pre></td></tr></table></figure><p>tools.cpp：函数定义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tools.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">greeting</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">sum</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cpp：主函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;tool.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">greeting</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span>* argv[])</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> m=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> n=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=<span class="built_in">atoi</span>(argv[<span class="number">1</span>]); i++)&#123;</span><br><span class="line">        s+=i;</span><br><span class="line">        m++;</span><br><span class="line">        n++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;sum=%d\n&quot;</span>,s);</span><br><span class="line">    <span class="built_in">greeting</span>();</span><br><span class="line">    cout&lt;&lt;<span class="built_in">sum</span>(<span class="number">12</span>,<span class="number">12</span>)&lt;&lt;endl;</span><br><span class="line">    <span class="built_in">print_num</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码只是为了演示之用，并无特别之处。</p><p>编译方式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// -g 添加调试信息    -Wall 输出所有警告信息，例如定义了从未使用过的变量</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">gcc main.cpp -o main -g -Wall</span>  </span><br></pre></td></tr></table></figure><h2 id="启动">启动</h2><p>调试可执行程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gdb main</span></span><br></pre></td></tr></table></figure><p>调试 core 文件，core 文件是程序运行过程中出现Segmentation fault (core dumped)错误时，程序停止运行时产生的。core文件是程序运行状态的内存映象。使用gdb调试core文件，可以帮助我们快速定位程序出现段错误的位置。可执行程序编译时应加上-g编译选项，生成调试信息。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$</span><span class="language-bash">gdb &lt;program&gt; &lt;core dump file&gt;</span></span><br></pre></td></tr></table></figure><p>调试服务程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$gdb &lt;program&gt; &lt;PID&gt;</span><br></pre></td></tr></table></figure><h2 id="设置和获取参数">设置和获取参数</h2><p>有时需要在执行程序时输入额外的参数，例如：像下面这样执行程序test</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">./main 5</span></span><br></pre></td></tr></table></figure><p>调试时，往往直接执行<code>$ gdb main</code></p><p>那么怎么在gdb中输入该程序的参数呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) set args 5</span><br></pre></td></tr></table></figure><p>还可以查看程序的参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show args</span><br><span class="line">Argument list to give program being debugged when it is started is &quot;5&quot;.</span><br></pre></td></tr></table></figure><h2 id="查看代码">查看代码</h2><p>GDB提供了两种查看源码的方式，分别是<strong>根据行号</strong>和<strong>函数名</strong>查看。除了可以查看本文件源码，还可以查看其他文件的源码。</p><h3 id="本文件">本文件</h3><p>本文件指的是该程序对应的main函数所在文件，即main.cpp</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l        # 每执行1次显示10行，再执行1次显示次10行</span><br><span class="line">(gdb) l 15     # 显示第15行，此时会将15行显示在屏幕窗口中央，方便查看前后的代码</span><br><span class="line">(gdb) l main   # 显示本文件的main函数</span><br></pre></td></tr></table></figure><h3 id="其他文件">其他文件</h3><p>共同编译的所有文件中，除了main函数所在文件的其它文件。在这里，除了main.cpp即tools.cpp</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) l tools.cpp:15       # 在tools.cpp中，显示第15行附近的代码</span><br><span class="line">(gdb) l tools.cpp:sum      # 在tools.cpp中，查看sum函数的代码</span><br></pre></td></tr></table></figure><h3 id="设置和获取显示行数">设置和获取显示行数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) show list    # 显示行数</span><br><span class="line">(gdb) set list 20  # 设置行数</span><br></pre></td></tr></table></figure><h2 id="断点">断点</h2><p>可以在一次调试中设置1个或多个断点，下一次只需让程序自动运行到设置断点位置，便可在上次设置断点的位置中断下来，极大的方便了操作，同时节省了时间。</p><p>可以根据行号，函数名设置断点，还可根据条件设置断点(一般用于循环中)</p><h3 id="本文件-2">本文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b 10              # 将第10行设置为断点</span><br><span class="line">(gdb) b main            # 将main函数入口处设置为断点</span><br><span class="line">(gdb) l                 # 可以看到在main.cpp中含有greeting函数的声明</span><br><span class="line">11</span><br><span class="line">12void greeting();</span><br><span class="line">13int main(int argc, char* argv[])&#123;</span><br><span class="line">14    int s = 0;</span><br><span class="line">15    int m=0;</span><br><span class="line">16    int n=0;</span><br><span class="line">17    for(int i=1; i&lt;=atoi(argv[1]); i++)&#123;</span><br><span class="line">18        s+=i;</span><br><span class="line">19        m++;</span><br><span class="line">20        n++;</span><br><span class="line">(gdb) b greeting        # 此时设置的断点并不是函数的声明处，而是函数的定义处，greeting函数定义在tools.cpp文件中</span><br><span class="line">Breakpoint 1 at 0xaa2: file tools.cpp, line 13.</span><br></pre></td></tr></table></figure><h3 id="其他文件-2">其他文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b tools.cpp:12            # 将tools.cpp的第12行设置为断点</span><br><span class="line">b tools.cpp:sum           # 将tools.cpp的sum函数设置为断点</span><br></pre></td></tr></table></figure><h3 id="设置条件断点">设置条件断点</h3><p>条件断点一般用于循环中</p><p>本文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置i==2时，第18行为断点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">行号必须在变量的作用域范围内</span></span><br><span class="line">(gdb) b 18 if i==2                              </span><br><span class="line">Breakpoint 1 at 0x9d8: file main.cpp, line 18.</span><br></pre></td></tr></table></figure><p>其他文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">设置tools.cpp文件内，i==5时，第22行为断点</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">22必须在i的作用域范围</span></span><br><span class="line">(gdb) b tools.cpp:22 if i==5                  </span><br><span class="line">Breakpoint 2 at 0xafb: file tools.cpp, line 22.</span><br></pre></td></tr></table></figure><h3 id="查看和删除断点">查看和删除断点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(gdb) i b            # 显示所有断点</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x00000000000009a4 in main(int, char**) at main.cpp:14</span><br><span class="line">2       breakpoint     keep y   0x00000000000009ec in main(int, char**) at main.cpp:22</span><br><span class="line">3       breakpoint     keep y   0x0000000000000a39 in main(int, char**) at main.cpp:25</span><br><span class="line"></span><br><span class="line">d 1                  # 删除第1个断点                               </span><br></pre></td></tr></table></figure><h3 id="设置断点无效和有效">设置断点无效和有效</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">clear n# 清除第n行的断点</span><br><span class="line">dis 2               # 将第2个断点设置为无效</span><br><span class="line">ena 2               # 将第2个断点设置有效 </span><br><span class="line">delete breakpoints  # 删除所有断点</span><br></pre></td></tr></table></figure><h2 id="运行">运行</h2><p>有两种运行方式，一种是从主函数开始运行，一种是运行到第1个断点处</p><h3 id="从主函数运行">从主函数运行</h3><p>程序从main函数开始</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) run</span><br></pre></td></tr></table></figure><h3 id="运行到第1个断点处">运行到第1个断点处</h3><p>程序停在第一个断点处</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb) start</span><br></pre></td></tr></table></figure><h3 id="执行流控制">执行流控制</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c/continue         # 向下运行到下一个断点处</span><br><span class="line">n/next             # 执行下一行代码，不进入调用的函数，直接返回结果</span><br><span class="line">s/step             # 执行下一行代码，进入调用的函数</span><br><span class="line">finish             # 跳出函数体</span><br><span class="line">until     # 跳出当前循环 在执行完循环体内的最后一条语句之后执行 until，才可以跳出循环</span><br><span class="line">until+行号          # 运行至某行，不仅仅用来跳出循环</span><br><span class="line">call 函数名称(参数)      # 调用程序中可见的函数，并传递参数，如：call gdb_test(67)</span><br></pre></td></tr></table></figure><h3 id="打印变量">打印变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p  变量名                      # 打印变量值，可以答应在当前作用域之内的变量名</span><br><span class="line">ptype 变量名                   # 打印变量类型</span><br></pre></td></tr></table></figure><h2 id="查询">查询</h2><h3 id="自动变量操作">自动变量操作</h3><p>可以在每次执行时都打印该变量的值，常用于循环体中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">display 变量名                 # 自动打印指定变量的值</span><br><span class="line">i display         # 查看所有设置自动打印的变量值</span><br><span class="line">undisplay 编号      # 取消自动打印变量值</span><br><span class="line">print 表达式                   # 打印表达式的值，可以是任何有效表达式</span><br><span class="line">print num                     # 打印整数num</span><br><span class="line">print ++num                   # 打印num+1 后的值</span><br><span class="line">print gdb_test(1024)          # 以整数 22 作为参数调用 gdb_test()函数</span><br><span class="line">print gdb_test(num)           # 以变量 num 作为参数调用 gdb_test() 函数</span><br><span class="line">watch 表达式 # 设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch num</span><br><span class="line">whatis 变量名                  # 显示某个变量的类型</span><br><span class="line">info function              # 查询函数信息</span><br><span class="line">info locals# 显示当前堆栈页的所有变量</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="运行时信息">运行时信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">where/bt # 当前运行的堆栈列表；</span><br><span class="line">bt backtrace        # 显示当前调用堆栈</span><br><span class="line">up/down             # 改变堆栈显示的深度</span><br><span class="line">info program        # 查看程序的是否在运行，进程号，被暂停的原因。</span><br></pre></td></tr></table></figure><h3 id="设置变量值">设置变量值</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set var 变量名=变量值           # 可以临时改变该变量的值               </span><br></pre></td></tr></table></figure><h2 id="多窗口调试">多窗口调试</h2><p>使用 layout 可以同时在多个窗口调试代码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">layout src        # 显示源代码窗口</span><br><span class="line">layout asm        # 显示反汇编窗口</span><br><span class="line">layout regs       # 显示源代码/反汇编和CPU寄存器窗口</span><br><span class="line">layout split      # 显示源代码和反汇编窗口</span><br><span class="line">Ctrl + L# 刷新窗口</span><br></pre></td></tr></table></figure><h2 id="多进程调试">多进程调试</h2><p>GDB 默认调试的是父进程，使用以下命令切换调试的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set follow-fork-mode child      # 调试子进程</span><br><span class="line">set follow-fork-mode parent     # 调试父进程</span><br><span class="line">show follow-fork-mode           # 显示设置信息</span><br></pre></td></tr></table></figure><p>GDB 可以同时调试一个进程，也可以同时调试多个进程，使用以下命令设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set detach-on-fork &lt;mode&gt;       # 当 mode 为 on 时，表示程序只调试一个进程（可以是父进程、子进程）。当 mode 为 off 时，父子进程都在gdb的控制之下，其中一个进程正常的调试，另一个会被设置为暂停状态。</span><br></pre></td></tr></table></figure><p>GDB 将每一个被调试程序的执行状态记录在一个名为 inferior 的结构中。一般情况下一个 inferior 对应一个进程，不同的 inferior 有不同的地址空间。inferior 有时候会在进程没有启动的时候就存在。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info inferiors                 # 显示所有的 inferior,当前调试的进程前有 &quot;*&quot;。</span><br></pre></td></tr></table></figure><p>切换进程使用命令 inferior</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">inferior &lt;num&gt;                 # 切换到 num 号进程</span><br></pre></td></tr></table></figure><p>设置捕获点中断，调用 fork 函数时将产生中断</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">catch fork</span><br></pre></td></tr></table></figure><h2 id="查看内存">查看内存</h2><p>命令格式：例如 <code>x/&lt;n/f/u&gt; &lt;addr&gt;</code></p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(gdb) x/3cb 0x8049098</span><br><span class="line">0x8049098 &lt;Snippet&gt;:75 &#x27;K&#x27;65 &#x27;A&#x27;78 &#x27;N&#x27;</span><br></pre></td></tr></table></figure><p>x(examine)为命令的简称，用于检查内存数据。</p><p>命令的意思是：查看从内存地址 0x8049098 开始的数据，每字节为单位(b)，以ASCII字母形式显示©，显示 3 个单位的数据(3)。</p><p>下面对 3cb 三个字符对应的含义进行讲解：</p><ol><li><p>3</p><p>表示显示的单位数据个数，可根据需要自定义，和第三个字符参数有关。</p></li><li><p>c</p><p>用什么格式来解析这些二进制位，因为内存本质上是二进制位，它可被解释为多种含义，例如：0111 0101，可表示十进制数 117，也可以表示十六进制数 75，也可以表示字符 K(ASCII 字母)</p><p>可用的格式字符如下：</p><p>c 按字符格式显示变量。</p><p>x 按十六进制格式显示变量。</p><p>d 按十进制格式显示变量。</p><p>u 按十进制格式显示无符号整型。</p><p>o 按八进制格式显示变量。</p><p>t 按二进制格式显示变量。</p><p>a 按十六进制格式显示地址，并显示距离前继符号的偏移量(offset)。常用于定位未知地址(变量)。</p><p>f 按浮点数格式显示变量。</p></li><li><p>b</p><p>表示从当前地址往后请求的位宽大小。如果不指定的话，GDB默认是4个bytes。也可以指定以下字符</p><p><strong>b</strong>表示单字节，<strong>h</strong>表示双字节，<strong>w</strong>表示四字 节，<strong>g</strong>表示八字节。</p></li></ol><h2 id="其它工具">其它工具</h2><h3 id="cgdb">cgdb</h3><p>cgdb可以看作gdb的界面增强版,用来替代gdb的 gdb -tui。cgdb主要功能是在调试时进行代码的同步显示。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gdb </tag>
            
            <tag> 调试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的性质和存储结构</title>
      <link href="/2021/05/23/er-cha-shu-de-xing-zhi-he-cun-chu-jie-gou/"/>
      <url>/2021/05/23/er-cha-shu-de-xing-zhi-he-cun-chu-jie-gou/</url>
      
        <content type="html"><![CDATA[<h2 id="二叉树的性质">二叉树的性质</h2><p><strong>性质1</strong>:  在二叉树的第i层上至多有2i-1个节点(i&gt;=1)</p><p><strong>性质2</strong>: 深度为k的二叉树至多有2k-1个节点(k&gt;=1)</p><p><strong>性质3</strong>: 对任何一棵二叉树T,如果其终端节点数为n0，度为2的节点数为n2,则n0=n2+1</p><p><strong>满二叉树</strong>：深度为k且含有2k-1个节点的二叉树</p><span id="more"></span><img src="/Users/wangjun/work/满二叉树.png" alt="满二叉树.png" style="zoom: 50%;" /><p><strong>完全二叉树</strong>：深度为k，有n个节点的二叉树，当且仅当其每一个节点都与深度为k的满二叉树中编号从1至n的节点一一对应，称之为完全二叉树</p><p><strong>完全二叉树的特点</strong>：</p><p>（1）叶子节点只可能出现在层次最大的两层出现</p><p>（2）对任一节点，若其右分支下的子孙的最大层数为l，则其左分支下的子孙的最大层数必为l或l+1</p><img src="/Users/wangjun/work/完全二叉树.png" alt="完全二叉树.png" style="zoom:50%;" /><p><strong>性质4</strong>:具有n个节点的完全二叉树的深度为⎣⎦+1</p><p><strong>性质5</strong>：如果对一棵有n个节点的完全二叉树的节点按层序编号，每层从左到右</p><p>(1) 如果i == 1，则节点i是二叉树的根；如果i &gt; 1, 则其双亲parent(i)是节点⎣i/2⎦</p><p>(2) 如果2i&gt;n，则节点i无左孩子(节点i为叶子节点)，否则其左孩子lchild(i)是节点2i</p><p>(3) 如果2i+1&gt;n，则节点i无右孩子；否则其右孩子rchild(i)是节点2i+1</p><img src="/Users/wangjun/work/树的双亲和孩子.png" alt="树节点.png" style="zoom:50%;" /><h2 id="二叉树的存储结构">二叉树的存储结构</h2><h3 id="顺序存储结构">顺序存储结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//------二叉树的顺序存储表示---------</span><br><span class="line">#define MAXSIZE 100  //存储100个元素</span><br><span class="line">typedef TElemType SqBiTree[MAXSIZE];  </span><br><span class="line">//含有MAXSIZE个元素，类型为TElemType的数组，并用SqBiTree来作为定义数组的别名</span><br><span class="line">SqBiTree bt;    //bt为含有MAXSIZE个元素，类型为TElemType的数组</span><br></pre></td></tr></table></figure><p>用数组实现：若数组元素大于0，则节点存在，等于0则代表节点不存在</p><p>满二叉树可表示为： 1 2 3 4 5 6 7 8 9 10 11 12</p><p>一般二叉树可表示为：1 2 3 4 5 0 0 0 0 6 7</p><p>以上两树分别对应以下a和b</p><img src="/Users/wangjun/work/满二叉树.png" alt="满二叉树和普通树.png" style="zoom:50%;" /><p>由此可见，顺序存储结构仅适用于完全二叉树。因为最坏情况下，一个深度为k且只有k个节点的单支树却需要长度为2k-1的一维数组。</p><h3 id="链式存储结构">链式存储结构</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//-------二叉树的二叉链表存储表示----------</span><br><span class="line">typedef struct BiTNode&#123;</span><br><span class="line">  TElemType data;                     //节点数据域</span><br><span class="line">  struct BiTNode *lchild,*rchild;     //左右孩子指针</span><br><span class="line">&#125;BiTNode,*Bitree;</span><br></pre></td></tr></table></figure><p>根据二叉树的定义，二叉树的节点由一个数据元素和分别指向其左，右子树的两个分支构成，则表示二叉树的链表中的节点至少包含三个域：数据域和左，右指针域。</p><p>有时为了方便找到双亲，会额外增加一个指向其双亲的指针域，此种链表称为三叉链表。</p><p>链表的头指针指向二叉树的根节点。根据数学计算，含有n个节点的二叉链表中有n+1个空链域，可以利用这些空链域存储一些有用信息，比如前驱和后继。</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
            <tag> 存储结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LR语法分析</title>
      <link href="/2021/05/15/lr-yu-fa-fen-xi/"/>
      <url>/2021/05/15/lr-yu-fa-fen-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="LR分析">LR分析</h2><h3 id="分析过程">分析过程</h3><ul><li><strong>三元式表示</strong><br>三元式子：（状态栈，符号栈，输入符号串）</li></ul><span id="more"></span><ul><li><p>初始时，将状态s<sub>0</sub>和#进分析栈，三元式为：</p><p>(S<sub>0</sub>，#，a<sub>1</sub>a<sub>2</sub>…a<sub>n</sub>#)</p></li><li><p>任意时刻三元式：</p><p>(S<sub>0</sub>S<sub>1</sub>…==S<sub>m</sub>==，#X<sub>1</sub>X<sub>2</sub>…X<sub>n</sub>，==a<sub>1</sub>==a<sub>2</sub>…a<sub>n</sub>#)</p><p>==分析器的下一步动作是由栈顶状态S<sub>m</sub>和输入符号串a<sub>i</sub>唯一确定==</p><p>通过查询action表可以确定下一个状态，之后会讨论怎么构建action表。</p></li></ul><h3 id="下一步动作有四种情况">下一步动作有四种情况</h3><p><strong>移进</strong>：将当前符号移进符号栈，相应的状态移进状态栈</p><p><strong>规约</strong>：满足产生式时，右端长度为r，则两个栈顶的r个元素同时出栈，将产生式左端符号进入符号栈，<strong>根据此时状态栈栈顶符号和符号栈栈顶符号确定下一步状态</strong></p><p><strong>接受</strong>：分析成功</p><p><strong>出错</strong>：报告出错信息</p><h3 id="LR文法">LR文法</h3><p>从给定的文法构造一个识别该文法前缀的确定有限状态自动机(DFA)，根据该DFA构造分析表。</p><h3 id="活前缀">活前缀</h3><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-20%20%E4%B8%8A%E5%8D%8811.26.36.png" alt="截屏2021-04-20 上午11.26.36" style="zoom: 33%;" /><p>从左到右为最左推导，其逆过程为最右规约。</p><p>从右到左为最右推导（==规范推导==），其逆过程为最左规约，也叫(==规范规约==)</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-20%20%E4%B8%8A%E5%8D%8811.36.22.png" alt="截屏2021-04-20 上午11.36.22" style="zoom: 33%;" /><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-20%20%E4%B8%8A%E5%8D%8811.17.41.png" alt="截屏2021-04-20 上午11.17.41" style="zoom: 33%;" /><p><strong>活前缀的作用：</strong></p><p>只要输入串已扫描部分保持可规约成一个活前缀，那就意味着所扫描过的部分没有错误。</p><h2 id="LR-0-项目及其项目集规范族">LR(0)项目及其项目集规范族</h2><h3 id="定义">定义</h3><p>对于文法G，分别为其产生式右部的每个字符的左右两边添加特殊符号&quot;.&quot;，就构成文法的一个LR(0)项目</p><p>例如，现有一个文法G：</p><p>S $\rightarrow$ aAcBe</p><p>其LR(0)项目共有6个，分别为：</p><p>S $\rightarrow$ .aAcBe</p><p>S $\rightarrow$ a.AcBe</p><p>S $\rightarrow$ aA.cBe</p><p>S $\rightarrow$ <a href="http://aAc.Be">aAc.Be</a></p><p>S $\rightarrow$ aAcB.e</p><p>S $\rightarrow$ aAcBe.</p><h3 id="项目分类">项目分类</h3><p>根据&quot;.&quot;所在的位置，可将项目分为：</p><ol><li><p>&quot;.&quot;之后为终结符，称为<strong>移进项目</strong>。</p></li><li><p>&quot;.&quot;之后为非终结符，称为<strong>待约项目</strong></p><p>意思是&quot;.&quot;之后的非终结符，将用于输入符号的规约</p></li><li><p>&quot;.&quot;之后没有符号，称为<strong>规约项目</strong></p></li><li><p>对于拓广文法S’ $\rightarrow$ S，若此时&quot;.&quot;位于S之后，则代表分析结束。该项目称为<strong>接受项目</strong></p></li></ol><h3 id="构造识别活前缀的NFA和DFA">构造识别活前缀的NFA和DFA</h3><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-20%20%E4%B8%8B%E5%8D%884.31.23.png" alt="截屏2021-04-20 下午4.31.23" style="zoom: 33%;" /><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-20%20%E4%B8%8B%E5%8D%884.33.05.png" alt="截屏2021-04-20 下午4.33.05" style="zoom: 33%;" /><p>状态1碰到ε可以跳转到状态3和状态11，因为其后为非终结符，可以直接跳到该终结符所对应的状态</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-20%20%E4%B8%8B%E5%8D%884.38.42.png" alt="截屏2021-04-20 下午4.38.42" style="zoom:33%;" /><h2 id="LR-0-文法">LR(0)文法</h2><p>若一个文法G的项目集规范族中的所有项目都是相容的，则称文法G为LR(0)文法</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-20%20%E4%B8%8B%E5%8D%884.41.32.png" alt="截屏2021-04-20 下午4.41.32" style="zoom:33%;" /><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-20%20%E4%B8%8B%E5%8D%884.42.23.png" alt="截屏2021-04-20 下午4.42.23" style="zoom:25%;" /><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-20%20%E4%B8%8B%E5%8D%884.41.32.png" alt="截屏2021-04-20 下午4.41.32" style="zoom: 25%;" /><h3 id="LR-0-文法示例">LR(0)文法示例</h3><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-20%20%E4%B8%8B%E5%8D%884.42.23.png" alt="截屏2021-04-20 下午4.42.23" style="zoom:25%;" /><p>1）</p><p>G[S]拓广为：<img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-20%20%E4%B8%8B%E5%8D%884.47.35.png" alt="截屏2021-04-20 下午4.47.35" style="zoom:33%;" /></p><p>画出识别活前缀的DFA</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-20%20%E4%B8%8B%E5%8D%884.48.18.png" alt="截屏2021-04-20 下午4.48.18" style="zoom: 25%;" /><p>2）</p><p>构造LR(0)分析表</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-20%20%E4%B8%8B%E5%8D%884.49.17.png" alt="截屏2021-04-20 下午4.49.17" style="zoom: 33%;" /><p>3）用LR分析法对对abbce进行分析</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-20%20%E4%B8%8B%E5%8D%884.50.37.png" alt="截屏2021-04-20 下午4.50.37" style="zoom:33%;" />]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
            <tag> LR分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形式语言与文法</title>
      <link href="/2021/05/12/xing-shi-yu-yan-yu-wen-fa/"/>
      <url>/2021/05/12/xing-shi-yu-yan-yu-wen-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="文法的直观概念和语言概述">文法的直观概念和语言概述</h2><p>当我们表述一种语言时，无非是说明这种语言的句子，如果语言只含有有穷多个句子，则只需列出句子的有穷集就行了，但对于含有无穷句子的语言来讲，存在着如何给出它的有穷表示的问题。</p><p>以自然语言为例，人们无法列出全部句子，但是人们可以给出一些规则，用这些规则来说明(或者定义)句子的组成结构，比如汉语句子可以是由主语后随谓语而成，构成谓语的是动词和直接宾语，我们采用第2章所介绍的EBNF来表示这种句子的构成规则：</p><span id="more"></span><p><strong>“我是大学生”。是汉语的一个句子</strong></p><p>我们可以定义一些规则来生成类似上述句子的语言，定义规则如下：</p><p>〈句子〉∷=〈主语〉〈谓语〉<br>〈主语〉∷=〈代词〉｜〈名词〉<br>〈代词〉∷= 我｜你｜他<br>〈名词〉∷= 王明｜大学生｜工人｜英语<br>〈谓语〉∷=〈动词〉〈直接宾语〉<br>〈动词〉∷= 是｜学习<br>〈直接宾语〉∷=〈代词〉｜〈名词〉</p><p>有了上述规则，按照如下方式用它们导出句子：找到::=左端带有&lt;句子&gt;的规则，并把它由::=右端的符号串代替，这个动作可以表示为：&lt;句子&gt;  =&gt; &lt;主语&gt; &lt;谓语&gt;</p><p>然后再得到的串&lt;主语&gt; &lt;谓语&gt;，选取〈主语〉或〈谓语〉，再用相应规则的::=右端代替，比如选取了〈主语〉，并采用规则〈主语〉::=〈代词〉，那么将得到：&lt;主语&gt;〈谓语〉=&gt; 〈代词〉〈谓语〉</p><p>重复上述过程：句子“我是大学生”的全部动作是：</p><p>&lt;句子&gt; =&gt; &lt;主语&gt;〈谓语〉=&gt;  &lt;代词&gt; 〈谓词〉=&gt;  &lt;代词&gt;〈动词〉〈直接宾语〉=&gt; 〈代词〉〈动词〉〈名词〉=&gt;我 〈动词〉〈名词〉=&gt; 我是〈名词〉=&gt; 我是大学生</p><p><strong>上述定义的规则就称为文法，能有该文法生成的句子，称为该文法的语言</strong></p><h2 id="字母表和符号串">字母表和符号串</h2><h3 id="字母表">字母表</h3><ul><li>符号的非空有限集合</li><li>典型的符号是字符，数字，各种标点符号和运算符等。</li></ul><h3 id="符号串">符号串</h3><ul><li><strong>定义在某一字母表上</strong></li><li>由该字母表中的符号组成的有限符号序列</li><li>同义词：句子，字</li></ul><h3 id="符号串的几个概念">符号串的几个概念</h3><ul><li><p>长度</p><ul><li>符号串α的长度是指a中出现的符号个数，记作|α|。</li><li>空串的长度为0，常用ε表示。</li></ul></li><li><p>前缀</p><p>符号串α的前缀是指从符号串α的末尾删除0个或多个符号后得到的符号串。如：stu是student的前缀</p></li><li><p>后缀</p><p>符号串α的后缀是指从符号串α的开头删除0个或多个符号后得到的符号串。如dent是student的后缀</p></li><li><p>子串</p><p>符号串α的子串是指删除了α的前缀或后缀后得到的符号串。如tud是student的子串</p></li><li><p>真前缀，真后缀，真子串</p><p>如果非空符号串β是α的前缀，后缀或子串，并且β≠α，则称β是α的真前缀，真后缀或真子串</p></li><li><p>子序列</p><p>符号串α的子序列是指从α中删除0个或多个符号（这些符号可以是不连续的）后得到的符号串。例如：sdt是student的子序列</p></li></ul><h2 id="符号串运算">符号串运算</h2><h3 id="连接">连接</h3><p>符号串α和符号串β的连接αβ是把符号串β加在符号串α之后得到的符号串</p><p>若α=ab，β=cd，则αβ=abcd，βα=cdba</p><p>对任何符号串α来说，都有εα=αε=α</p><h3 id="幂">幂</h3><p>若α是符号串，α的n次幂α<sup>n</sup>定义为：n个α连接</p><p>当n==0时，α<sup>0</sup>=ε。</p><p>假如α=ab，则有：α<sup>0</sup>=ε，α<sup>1</sup>=ab，α<sup>2</sup>=abab</p><h2 id="语言">语言</h2><h3 id="语言-2">语言</h3><p>在某一确定字母表上的符号串的集合。</p><p>空集φ，集合{ε}也是符合次定义的语言。</p><p>这个定义并没有把任何意义赋予语言中的符号串。</p><h3 id="语言的运算">语言的运算</h3><p>假设L和M表示两个语言</p><p>L和M的并记作L⋃M：L⋃M={s|s⋳L 或s⋳M}</p><p>L和M的连接记作LM：LM={st|s⋳L并且t⋳M}</p><p>L的闭包记作L<sup>*</sup>：即L的0次或若干次连接。</p><p>L的正闭包记作L<sup>+</sup>：即L的1次或若干次连接。</p><p>把幂运算推广到语言</p><p>L<sup>0</sup>={ε}，L<sup>n</sup>=L<sup>n-1</sup>L，于是L<sup>n</sup>是语言L与其自身的n-1次幂连接。</p><p>L={A,B,…,Z,a,b,…,z}，D={0,1,…,9}</p><ul><li>可以把L和D看作是字母表</li><li>可以把L和D看作是语言</li></ul><p><strong>语言运算举例：</strong></p><table><thead><tr><th>语言</th><th>描述</th></tr></thead><tbody><tr><td>L⋃D</td><td>全部字母和数字的集合</td></tr><tr><td>LD</td><td>由一个字母后跟一个数字组成的所有符号串的集合</td></tr><tr><td>L<sup>4</sup></td><td>由4个字母组成的所有符号串的集合</td></tr><tr><td>L<sup>*</sup></td><td>由字母组成的所有符号串（包括ε）的集合</td></tr><tr><td>L(L⋃D)<sup>*</sup></td><td>由字母开头，后跟字母，数字组成的所有符号串的集合</td></tr><tr><td>D<sup>+</sup></td><td>由一个或若干个数字组成的所有符号串的集合</td></tr></tbody></table><h2 id="文法及其形式定义">文法及其形式定义</h2><p><strong>文法</strong>：所谓文法就是描述语言的语法结构的形式规则。</p><p>任何一个文法都可以表示为一个四元组（V<sub>T</sub>，V<sub>N</sub>，S，φ）</p><blockquote><p>V<sub>T</sub>为非空的有限集合，它的每个元素称为终结符号。</p><p>V<sub>N</sub>是一个非空的有限集合，它的每个元素称为非终结符号</p><p>S是一个特殊的非终结符，称为文法的开始符号。</p><p>φ是一个非空的有限集合，它的每个元素称为产生式。</p></blockquote><p><strong>产生式的形式为：α -&gt; β</strong></p><p>“-&gt;” 表示 “定义为” 或 “由…组成”</p><p>α，β⋳(V<sub>T</sub>UV<sub>N</sub>)<sup>*</sup> α≠ε</p><p>左部相同的产生式α -&gt; β<sub>1</sub>，α -&gt; β<sub>2</sub>，α -&gt; β<sub>3</sub>，α -&gt; β<sub>n</sub>可以缩写</p><p>α -&gt; β<sub>1</sub>|β<sub>2</sub>|…|β<sub>n</sub></p><p>&quot;|&quot;表示“或”，每个β<sub>i</sub>(i=1,2,…,n)称为α的一个候选式</p><p>元符号：$\rightarrow$ ， ::=，  |，  &lt;&gt;</p><p><strong>习惯表示</strong></p><p>大写字母：终结符</p><p>小写字母：非终结符</p><p>A $\rightarrow$ AB</p><p>A $\rightarrow$ Ax｜ y</p><p>B $\rightarrow$ z</p><h2 id="文法的分类">文法的分类</h2><p>根据对产生式施加的限制不同，定义了四类文法和相应的四种形式语言类。</p><table><thead><tr><th>文法类型</th><th>产生式形式的限制</th><th>文法产生的语言类</th></tr></thead><tbody><tr><td>0型文法</td><td>α$\rightarrow$β，其中α,β∊(V<sub>T</sub>UV<sub>N</sub>)<sup>*</sup>，|a|≠0</td><td>0型语言</td></tr><tr><td>1型文法，即上下文有关文法</td><td>α$\rightarrow$β，其中α,β∊(V<sub>T</sub>UV<sub>N</sub>)<sup>*</sup>，|α|≤|β|</td><td>1型语言，即上下文有关语言</td></tr><tr><td>2型文法，即上下文无关文法</td><td>A$\rightarrow$β，其中A∈V<sub>N</sub>，β∈(V<sub>T</sub>UV<sub>N</sub>)<sup>*</sup></td><td>2型语言，即上下文无关语言</td></tr><tr><td>3型文法，即正规文法（线性文法）</td><td>A$\rightarrow$α或A$\rightarrow$αB（右线性），或A$\rightarrow$α或A$\rightarrow$Bα，其中A，B∈V<sub>N</sub>，α∈V<sub>T</sub>U{ε}</td><td>3型语言，即正规语言</td></tr></tbody></table><blockquote><p>什么是上下文无关文法？</p><p>所有产生式的左边只有一个非终结符，例如S -&gt; aSb，S -&gt; ab，这就是上下文无关文法，因为你只要找到符合产生式右边的串，就可以把它归约为对应的非终结符。</p><p>什么是上下文有关文法？</p><p>所有产生式的左边有不只一个符号，例如aSb -&gt; aaSbb，S -&gt; ab，这就是上下文有关文法，当你替换S的时候，如果想用第一条规则，就得确保其有正确的上下文，即左右两边分别为a,b。</p></blockquote><h3 id="文法举例：">文法举例：</h3><p><strong>1型文法</strong></p><p>G[S]:</p><p>S $\rightarrow$CD</p><p>C $\rightarrow$ aCA</p><p>AD $\rightarrow$aD</p><p>Aa $\rightarrow$bD</p><p><strong>2型文法</strong></p><p>G[S]:</p><p>S$\rightarrow$CD</p><p>C$\rightarrow$aCA</p><p>C$\rightarrow$bCB</p><p><strong>3型文法</strong></p><p>G[S]:右线性文法</p><p>S$\rightarrow$0A|1B|0</p><p>A$\rightarrow$0A|1B|0S</p><p>B$\rightarrow$1B|1|0</p><p>G[l]:左线性文法</p><p>l$\rightarrow$T1</p><p>l$\rightarrow$1</p><p>T$\rightarrow$T1</p><p>T$\rightarrow$1</p><h3 id="文法的包含关系">文法的包含关系</h3><p>四种文法之间的逐级“包含”</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-14%20%E4%B8%8A%E5%8D%8810.24.08r32Wp8.png" alt="文法包含关系"></p><h3 id="文法与语言">文法与语言</h3><p>0型文法产生的语言称为0型语言<br>1型文法或上下文有关文法（ CSG ）产生的语言称为1型语言或上下文有关语言（CSL）<br>2型文法或上下文无关文法（ CFG ）产生的语言称为2型语言或上下文无关语言（ CF L ）<br>3型文法或正则（正规）文法（ RG ）产生的语言称为3型语言正则（正规）语言（ RL ）</p><h2 id="上下文无关文法及相应的语言">上下文无关文法及相应的语言</h2><p>所定义的语法单位(或称语法实体)完全独立于这种语法单位可能出现的上下文环境</p><p>现有程序设计语言中，许多语法单位的结构可以用上下文无关文法来描述。</p><p>例：描述算术表达式的文法G：<br>G=({ i, +, -, *, /, (, ) }, {&lt;表达式&gt;, &lt;项&gt;, &lt;因子&gt;}, &lt;表达式&gt;， φ)</p><p>其中φ：&lt;表达式&gt;$\rightarrow$&lt;表达式&gt;+&lt;项&gt; | &lt;表达式&gt;-&lt;项&gt; | &lt;项&gt;<br>&lt;项&gt;$\rightarrow$&lt;项&gt;*&lt;因子&gt; | &lt;项&gt;/&lt;因子&gt; | &lt;因子&gt;<br>&lt;因子&gt;$\rightarrow$(&lt;表达式&gt;) | i</p><p>L(G)是所有包括加，减，乘，除四则运算的算术表达式的集合。</p><h3 id="BNF（Backus-Normal-Form）表示法">BNF（Backus-Normal Form）表示法</h3><p><strong>元语言</strong></p><p>::=        表示  “定义为” 或 “由……组成”<br>&lt;……&gt;     表示非终结符号<br>|          表示“或”</p><p><strong>算术表达式文法的BNF表示：</strong></p><p>&lt;表达式&gt; ::= &lt;表达式&gt;+&lt;项&gt; | &lt;表达式&gt;-&lt;项&gt; | &lt;项&gt;<br>&lt;项&gt; ::= &lt;项&gt;*&lt;因子&gt; | &lt;项&gt;/&lt;因子&gt; | &lt;因子&gt;<br>&lt;因子&gt; ::= (&lt;表达式&gt;) | i</p><h3 id="文法书写约定">文法书写约定</h3><p><strong>终结符</strong></p><ul><li><p>次序靠前的小写字母，如：a、b、c</p></li><li><p>运算符号，如：+、-、*、/</p></li><li><p>各种标点符号，如：括号、逗号、冒号、等于号</p></li><li><p>数字1、2、…、9</p></li><li><p>数字1、2、…、9</p></li></ul><p><strong>非终结符</strong></p><ul><li>次序靠前的大写字母，如：A、B、C</li><li>大写字母S常用作文法的开始符号</li><li>小写的斜体符号串，如：expr、term、factor、stmt</li></ul><p><strong>文法符号</strong></p><p>次序靠后的大写字母，如：X、Y、Z</p><p><strong>终结符号串</strong></p><p>次序靠后的小写字母，如：u、v、…、z</p><p><strong>文法符号串</strong></p><p>小写的希腊字母，如：α、β、γ、δ</p><p>可以直接用产生式的集合代替四元组来描述文法，</p><p>第一个产生式的左部符号是文法的开始符号。</p><h3 id="推导和短语">推导和短语</h3><p>例：考虑简单算术表达式的文法G：</p><p>G=({+, *, (, ), i}, {E, T, F}, E ,φ)</p><p>φ: E$\rightarrow$E+T | T</p><p>​     T$\rightarrow$T*F | F</p><p>​  F$\rightarrow$(E) | i</p><p><strong>文法所产生的语言</strong></p><p>从文法的开始符号出发，反复连续使用产生式对非终结符号进行替换和展开，就可以得到该文法定义的语言。</p><p><strong>推导</strong></p><p>假定A$\rightarrow$γ是一个产生式，α和β是任意的文法符号串，则有：</p><p>αAβ$\Rightarrow$αγβ</p><p>”$\Rightarrow$“表示 “一步推导”</p><p>即利用产生式对左边符号串中的一个非终结符号进行替换，得到右边的符号串。</p><p>称αAβ<strong>直接推导出</strong>αγβ</p><p>也可以说αγβ是αAβ的<strong>直接推导</strong></p><p>或者说αAβ直接规约到αγβ</p><p>如果有直接推导序列：α<sub>1</sub>$\Rightarrow$α<sub>2</sub>$\Rightarrow$α<sub>3</sub>$\Rightarrow$…$\Rightarrow$α<sub>n</sub></p><p>则说α<sub>1</sub>推导出α<sub>n</sub>，记作α<sub>1</sub>$\stackrel{*}{\Rightarrow}$α<sub>n</sub></p><p>称这个序列是从α<sub>1</sub>到α<sub>n</sub>的长度为n的推导</p><p>&quot;$\stackrel{*}{\Rightarrow}$&quot;表示0步或多步推导</p><h3 id="最左推导，最右推导">最左推导，最右推导</h3><p><strong>最左推导</strong></p><p>如果有α$\stackrel{<em>}{\Rightarrow}$β，并且在每“一步推导中”，都替换α<strong>最左边</strong>的非终结符，则称这样的推导为最左推导，记作α$\mathop{\stackrel{</em>}{\Rightarrow}}\limits_{lm}$β</p><p>E$\Rightarrow$E+T $\Rightarrow$T+T$\Rightarrow$F+T$\Rightarrow$i+T$\Rightarrow$i+F$\Rightarrow$i+i</p><p><strong>最右推导</strong></p><p>α$\stackrel{<em>}{\Rightarrow}$β，并且在每“一步推导”中，都替换α中<strong>最右边</strong>的非终结符，则称这样的推导为最右推导。记作α$\mathop{\stackrel{</em>}{\Rightarrow}}\limits_{rm}$β，最右推导也称为==规范推导==</p><p>E$\Rightarrow$E+T$\Rightarrow$E+F$\Rightarrow$E+i$\Rightarrow$T+i$\Rightarrow$F+i$\Rightarrow$i+i</p><p>例如：</p><p>G：S$\rightarrow$0S1，S$\rightarrow$01</p><p>S$\Rightarrow$0S1</p><p>0S1$\Rightarrow$00S11</p><p>00S11$\Rightarrow$000S111</p><p>000S111$\Rightarrow$00001111</p><p>S$\Rightarrow$0S1$\Rightarrow$00S11$\Rightarrow$000S111$\Rightarrow$00001111</p><h3 id="句型，句子和语言">句型，句子和语言</h3><p><strong>句型</strong></p><p>对于文法G=（V<sub>T</sub>，V<sub>N</sub>，S，φ）</p><p>如果有S$\stackrel{*}{\Rightarrow}$α，则称α是当前文法的一个句型</p><p>若S$\mathop{\stackrel{*}{\Rightarrow}}\limits_{lm}$α，则α是当前文法的一个<strong>左句型</strong></p><p>若S$\mathop{\stackrel{*}{\Rightarrow}}\limits_{rm}$α，则α是当前文法的一个<strong>右句型</strong></p><p><strong>句子</strong></p><p>仅含有终结符的句型是文法的一个句子</p><p><strong>语言</strong></p><p>文法G产生的所有句子组成的集合是文法G所定义的语言，记作L(G)</p><p>L(G) = {α | S $\stackrel{<em>}{\Rightarrow}$ α，S为文法开始符号，并且α∈V<sub>T</sub><sup></em></sup>}</p><p>例：G： S→0S1， S→01<br>S $\Rightarrow$0S1 $\Rightarrow$00S11 $\Rightarrow$000S111 $\Rightarrow$00001111<br>G的句型S,0S1 ,00S11 ,000S111,00001111<br>G的句子00001111, 01</p><p><strong>文法，语言的定义</strong></p><p>由文法G生成的语言记为L(G),它是文法G的一切句子的集合:</p><p>L(G) = {α | S $\stackrel{<em>}{\Rightarrow}$ α，S为文法开始符号，并且α∈V<sub>T</sub><sup></em></sup>}</p><p>例：G： S→0S1， S→01<br>L(G)={0<sup>n</sup>1<sup>n</sup>|n≥1}</p><h3 id="文法的等价">文法的等价</h3><p>若L(G<sub>1</sub>)=L(G<sub>2</sub>)，则称文法G<sub>1</sub>和G<sub>2</sub>是等价的。</p><p>如文法G<sub>1</sub>[A]：A→0R  A→01 A→A1 与文法G<sub>2</sub>[S]：S→0S1 S→01 等价</p><h3 id="短语，直接短语和句柄">短语，直接短语和句柄</h3><p>对于文法G=（V<sub>T</sub>，V<sub>N</sub>，S，φ），假定αβδ是文法G的一个句型，如果存在：</p><p>​S $\stackrel{*}{\Rightarrow}$ αAδ，并且A $\stackrel{+}{\Rightarrow}$ β，则称β是句型αβδ关于非终结符A的==短语==。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/IMG_91CD2FE503AE-1v5k3P0.jpeg" alt="IMG_91CD2FE503AE-1" style="zoom:25%;" /><p>如果存在：</p><p>​        S $\stackrel{*}{\Rightarrow}$ αAδ，并且A ${\Rightarrow}$ β，则称β是句型αβδ关于非终结符A的==直接短语==。</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-14%20%E4%B8%8B%E5%8D%885.32.44A6Wl2u.png" alt="截屏2021-04-14 下午5.32.44" style="zoom: 25%;" /><p>一个句型的最左直接短语称为该句型的==句柄==。</p><h2 id="分析树及二义性">分析树及二义性</h2><h3 id="分析树">分析树</h3><p>推导的图形表示，又称推导树</p><p>具有树的性质</p><p>分析树的特点：每一个节点都有标记。</p><ul><li>根节点由文法开始符号标记；</li><li>每个内部节点由非终结符标记，它的子节点由这个非终结符的这次推导所用产生式的右部各符号从左到右依次标记；</li><li>叶节点由非终结符或终结符号标记，它们从左到右排列起来，构成句型。</li></ul><p>例如：假如现有一文法G[E]</p><p>G[E]=({+, *, (, ), i}, {E, T, F}, E ,φ)</p><p>φ: E$\rightarrow$E+T | T</p><p>​     T$\rightarrow$T*F | F</p><p>​  F$\rightarrow$(E) | i</p><p>i*(i+T)的推导过程如下：</p><p>E  ${\Rightarrow}$ T  ${\Rightarrow}$ T*F  ${\Rightarrow}$ T*(E)  ${\Rightarrow}$ i*(E) ${\Rightarrow}$i*(E+T)  ${\Rightarrow}$ i*(T+T) ${\Rightarrow}$ i*(F+T) ${\Rightarrow}$i*(i+T)</p><p>上述推导过程可用分析树表示如下：</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-14%20%E4%B8%8B%E5%8D%885.53.39MBqKNU.png" alt="截屏2021-04-14 下午5.53.39" style="zoom: 50%;" /><h3 id="子树">子树</h3><p>分析树中一个特有==节点==，连同它的==全部后裔节点==，连结这些节点的==边==，以及这些节点的==标记==。</p><p>子树的根节点可能不是文法的开始符号。</p><p>如果子树的根节点标记为非终结符A，则称该子树为A-子树</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-14%20%E4%B8%8B%E5%8D%886.05.47Odq6y1.png" alt="截屏2021-04-14 下午6.05.47" style="zoom: 50%;" /><h3 id="子树与短语的关系">子树与短语的关系</h3><p>一棵==子树的所有叶节点==自左至右排列起来，形式次句型相对于该子树根的短语；</p><p>分析树中。</p><p>分析树中==只有父子两代==的子树的所有叶节点自左至右排列起来，形成此句型相对于子树根的直接短语</p><p>分析树中==最左边==的那棵只有父子两代的子树的所有叶节点自左至右排列起来，就是该句型的==句柄==</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-14%20%E4%B8%8B%E5%8D%886.16.45e86k69.png" alt="截屏2021-04-14 下午6.16.45" style="zoom:50%;" /><p>G[E]=({+, *, (, ), i}, {E, T, F}, E ,φ)</p><p>φ: E$\rightarrow$E+T | T</p><p>​     T$\rightarrow$T*F | F</p><p>​  F$\rightarrow$(E) | i</p><p>E  ${\Rightarrow}$ E+T ${\Rightarrow}$ T+T${\Rightarrow}$ F+T ${\Rightarrow}$ a+T ${\Rightarrow}$ a+T*F ${\Rightarrow}$ a+F*F ${\Rightarrow}$ a+a*F ${\Rightarrow}$ a+a*a</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-14%20%E4%B8%8B%E5%8D%886.22.287lGB4P.png" alt="截屏2021-04-14 下午6.22.28" style="zoom:50%;" /><p>==分析树看不出句型中符号被替代的顺序==</p><h2 id="上下文无关文法的语法树的用处">上下文无关文法的语法树的用处</h2><p>例：G[S]:</p><p>​S $\rightarrow$ aAS</p><p>​A $\rightarrow$ SbA</p><p>​A $\rightarrow$ SS</p><p>​S $\rightarrow$ a</p><p>​A $\rightarrow$ ba</p><p>句型aabbaa的语法树（推导树）</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-14%20%E4%B8%8B%E5%8D%886.43.5712U0Qw.png" alt="截屏2021-04-14 下午6.43.57" style="zoom:50%;" /><h2 id="二义性">二义性</h2><p>如果一个文法的某个句子有不止一棵分析树，则这个句子是==二义性的==。</p><p>例如：考虑文法</p><p>G = ({+,*,(,),i}, {E} , E, φ)</p><p>φ : E $\rightarrow$ E+E | E*E | (E) | id</p><p>句子 id+id*id 存在两个不同的最左推导：</p><p>有两棵不同的分析树</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-14%20%E4%B8%8B%E5%8D%886.56.09uVXZRW.png" alt="截屏2021-04-14 下午6.56.09" style="zoom:50%;" /><h3 id="文法二义性的消除">文法二义性的消除</h3><p>映射程序设计语言中IF语句的文法：</p><p>stmt $\rightarrow$ if expr then stmt<br>| if expr then stmt else stmt<br>| other</p><p>句子：if E1 then if E2 then S1 else S2有两棵不同的分析树：</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-14%20%E4%B8%8B%E5%8D%887.44.47bPRrKF.png" alt="截屏2021-04-14 下午7.44.47"></p><p>利用==“最近最后匹配原则”==</p><p>出现在then和else之间的语句必须是“匹配的”。</p><p>出现在then和else之间的语句必须是“匹配的”。</p><p>改写后的文法：</p><p>stmt $\rightarrow$  matched_stmt | unmatched_stmt<br>matched_stmt $\rightarrow$  if expr then matched_stmt else matched_stmt<br>| other<br>unmatched_stmt $\rightarrow$   if expr then stmt<br>| if expr then matched_stmt else unmatched_stmt</p><p>句子：if E1 then if E2 then S1 else S2的分析树</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-14%20%E4%B8%8B%E5%8D%887.49.57SiPH98.png" alt="截屏2021-04-14 下午7.49.57" style="zoom: 50%;" /><h3 id="文法的二义性和语言的二义性">文法的二义性和语言的二义性</h3><ul><li>如果两个文法产生的语言相同，即L(G)=L(G`)，则称这两个文法是等价的。</li><li>有时，一个二义性的文法可以变换为一个等价的、无二义性的文法。</li><li>有些语言，根本就不存在无二义性的文法，这样的语言称为二义性的语言。</li><li>二义性问题是不可判定的<ul><li>不存在一种算法，它能够在有限的步骤内确切地判定出一个文法是否是二义性的。</li><li>可以找出一些充分条件（未必是必要条件），当文法满足这些条件时，就可以确信该文法是无二义性的。</li></ul></li></ul><h2 id="句型的分析">句型的分析</h2><p>句型分析就是识别一个符号串是否为某文法的句型，是某个推导的构造过程</p><p>在语言的编译实现中，把完成句型分析的程序称为分析程序或识别程序。分析算法又称识别算法。</p><p>从左到右的分析算法，即总是从左到右地识别输入符号串，首先识别符号串中的最左符号，进而依次识别右边的一个符号，直到分析结束。</p><h3 id="句型的分析算法分类">句型的分析算法分类</h3><p>分析算法可分为：</p><ol><li><p>自上而下分析法：</p><p>从文法的开始符号出发，反复使用文法的产生式，寻找与输入符号串匹配的推导。</p></li><li><p>自下而上分析法：</p></li><li><p>从输入符号串开始，逐步进行==规约==，直至规约到文法的开始符号。</p></li></ol><p><strong>两种方法反映了两种语法树的构造过程</strong></p><p><strong>自上而下方法</strong>是从文法符号开始，将它做为语法树的根，向下逐步建立语法树，使语法树的结果正好是输入符号串</p><p><strong>自下而上方法</strong>则是从输入符号串开始，以它做为语法树的结果，自底向上地构造语法树</p><h3 id="自上而下的语法分析">自上而下的语法分析</h3><p>例：文法G：S $\rightarrow$ cAd ,  A $\rightarrow$ ab, A $\rightarrow$ a</p><p>识别输入串w=cabd是否为该文法的句子</p><p>推导过程：S  ${\Rightarrow}$ cAd         cAd  ${\Rightarrow}$  cabd</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-14%20%E4%B8%8B%E5%8D%888.02.15pJyNeb.png" alt="截屏2021-04-14 下午8.02.15"></p><h3 id="自下而上分析的语法分析">自下而上分析的语法分析</h3><p>例：文法G：S $\rightarrow$ cAd ,  A $\rightarrow$ ab, A $\rightarrow$ a</p><p>识别输入串w=cabd是否为该文法的句子</p><p>规约过程构造的推导： cAd${\Rightarrow}$ cabd      S ${\Rightarrow}$ cAd</p><p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-14%20%E4%B8%8B%E5%8D%888.05.08hLUG61.png" alt="截屏2021-04-14 下午8.05.08"></p><h3 id="句型分析的有关问题">句型分析的有关问题</h3><ol><li><p>在自上而下的分析方法中如何选择使用哪个产生式进行推导？</p><p>假定要被代换的最左非终结符号是B，且有n条规则：B$ \rightarrow$ A1|A2|…|An，那么如何确定用哪个右部去替代B？</p></li><li><p>在自下而上的分析方法中如何识别可归约的串？</p><p>在分析程序工作的每一步，都是从当前串中选择一个子串，将它归约到某个非终结符号，该子串称为“可归约串”</p></li></ol><h3 id="识别短语，直接短语和句柄">识别短语，直接短语和句柄</h3><p>G[E]：E $\rightarrow$ E+T|T      T$ \rightarrow$ T*F|F      F$ \rightarrow$ (E)|i</p><p>给定一个句型：i*i+i和它的分析树，识别它的短语，直接短语和句柄</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-14%20%E4%B8%8B%E5%8D%888.16.18NqSOKG.png" alt="截屏2021-04-14 下午8.16.18" style="zoom:50%;" /><p><strong>短语</strong>：i<sub>1</sub>，i<sub>2</sub>，i<sub>3</sub>，i<sub>1</sub>*i<sub>2</sub>，i<sub>1</sub>*i<sub>2</sub>+i<sub>3</sub></p><p><strong>直接短语</strong>：i<sub>1</sub>，i<sub>2</sub>，i<sub>3</sub></p><p><strong>句柄</strong>：i<sub>1</sub></p><blockquote><p>为什么i<sub>1</sub>*i<sub>2</sub>不是直接短语？</p><p>S $\stackrel{*}{\Rightarrow}$ T+i<sub>3</sub>，并且T ${\Rightarrow}$ T*F ${\Rightarrow}$F*F ${\Rightarrow}$ i<sub>1</sub>*F ${\Rightarrow}$  i<sub>1</sub>*i<sub>2</sub>， i<sub>1</sub>*i<sub>2</sub>是T经过多步推导得到，因而只是短语，而不是直接短语。</p></blockquote><h2 id="左递归">左递归</h2><h3 id="左递归-2">左递归</h3><p>假设某一文法：</p><p>G[S]：S $\rightarrow$ Sa，S $\rightarrow$ b  L(G) = {ba<sup>n</sup>|n⩾1}</p><p>w=baa</p><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-14%20%E4%B8%8B%E5%8D%888.51.514ZnNre.png" alt="截屏2021-04-14 下午8.51.51" style="zoom:50%;" /><h3 id="左递归的消除">左递归的消除</h3><p>一个文法是左递归的，如果它有非终结符号Α，对某个文法符号串α，存在推导：</p><p>Α ${\Rightarrow}$ Αα</p><p>如果存在某个α=ε，则称该文法是有<strong>环路</strong>的</p><p><strong>消除直接左递归的方法：</strong></p><p>简单情况：如果文法G有产生式：A $\rightarrow$ Aα| β</p><p>A</p><p>L(G) = {βa<sup>n</sup>| n≥1}</p><p>可以把A的这两个产生式改写为：</p><p>A $\rightarrow$ βA‘</p><p>A’ $\rightarrow$ αA‘ ｜ ε</p><p>此时L(G) =  {βa<sup>n</sup>| n≥1}</p><p><strong>说明这两组文法是等价的。</strong></p><p>示例：==消除直接左递归==</p><p>假如有一文法G[E]：</p><p>E  $\rightarrow$ E+T | T</p><p>T  $\rightarrow$ T*F | F</p><p>F  $\rightarrow$  (E) | id</p><p>上述文法存在两处左递归，分别是E  $\rightarrow$ E+T | T，T  $\rightarrow$ T*F | F，分别用上述方法消除左递归。</p><p>E $\rightarrow$ TE’</p><p>E’ $\rightarrow$ +TE’ | ε</p><p>T $\rightarrow$ FT’</p><p>T’ $\rightarrow$ *FT’ | ε</p><p>F $\rightarrow$ (E) | id</p><blockquote><p>该方法巧妙借助 ε实现一个环来消除左递归。</p><p>观察上述直接左递归，其生成的语句为：T+T+T+T+T+T+T，第一个T为递归结束符，后面+T+T为循环式。</p><p>解决方法：改变E的产生式</p><ul><li><p>实现一个产生式用来生成第一个T</p><p>E $\rightarrow$ TE’，此时生成的语句开头便是T。</p></li><li><p>实现一个环来生成后续+T，就可以消除左递归</p><p>E‘ $\rightarrow$ +TE’ ｜  ε，此时便能产生+T+T+T…循环式了，而且可以用ε来结束循环</p></li></ul></blockquote><h3 id="间接左递归的消除">间接左递归的消除</h3><p>例如以下文法存在间接左递归：</p><p>S $\rightarrow$ Aa|b</p><p>A $\rightarrow$ Ac|Sd|ε</p><p><strong>消除算法：</strong></p><p>输入：无环路、无-产生式的文法G<br>输出：不带有左递归的、与G等价的文法G’</p><p>(1)把文法G的所有<strong>非终结符</strong>号按某种顺序排列成A1,A2,…,An<br>(2)for (i=1; i&lt;=n; i++)<br>for (j=1; j&lt;=i-1; j++)<br>if (A<sub>j</sub>$\rightarrow$ δ<sub>1</sub>|δ<sub>2</sub>|…|δ<sub>3</sub>是关于当前A<sub>j</sub>的所有产生式) {<br>把每个形如A<sub>i</sub>$\rightarrow$A<sub>j</sub>的产生式改写为：A<sub>i</sub>$\rightarrow$ δ<sub>1</sub>γ|δ<sub>2</sub>γ|…|δ<sub>3</sub>γ<br>消除关于A<sub>i</sub>的产生式中的直接左递归;<br>}<br>(3)化简第(2)步得到的文法，即去除无用的非终结符号和产生式。<br>这种方法得到的非递归文法可能含有ε-产生式。</p><p><strong>示例：</strong></p><p>消除下面文法中的左递归</p><p>S $\rightarrow$ Aa | b</p><p>A $\rightarrow$ Ac | Sd | ε</p><p>首先，必须保证此文法中无环路、无ε-产生式。</p><p>改写为无ε-产生式的文法：<br>S $\rightarrow$ Aa|a|b<br>A $\rightarrow$ Ac|c|Sd</p><blockquote><p>因为A可能会产生ε，在所有的产生式中添加A为ε时能产生的结果</p><p>例如S $\rightarrow$ Aa|a|b ，当A为ε时，S可以产生a，合并起来就为S $\rightarrow$ Aa|a|b</p></blockquote><p>消除其中的左递归：</p><p>第一步，把文法的非终结符号排列为S、A；</p><p>第二步，由于S不存在直接左递归，所以算法第2步在i=1时不做工作；</p><p>在i=2时，把产生式S $\rightarrow$Aa|a|b代入A的有关产生式中，得到：<br>A $\rightarrow$Ac|c|Aad|ad|bd</p><p>消除A产生式中的直接左递归，得到文法</p><p>S $\rightarrow$Aa|a|b</p><p>A $\rightarrow$cA‘|adA’ |bdA‘</p><p>A’ $\rightarrow$cA’|adA‘|ε</p><h2 id="提取左公因子">提取左公因子</h2><p>如有产生式 A $\rightarrow$ αβ<sub>1</sub>|αβ<sub>2</sub></p><p>提取公因子α，则原产生式变为：</p><p>A $\rightarrow$ αA’</p><p>A’  $\rightarrow$ β<sub>1</sub>|β<sub>2</sub></p><p>若产生式 A $\rightarrow$ αβ<sub>1</sub>|αβ<sub>2</sub>｜…|αβ<sub>n</sub>|γ</p><p>可用如下的产生式代替：</p><p>A $\rightarrow$ αA’ ｜ γ</p><p>A’  $\rightarrow$ β<sub>1</sub>|β<sub>2</sub>｜…|β<sub>n</sub></p><p>例如：现有如下程序设计语言IF语句的文法</p><p>stmt $\rightarrow$ if expr then stmt</p><p>​| if expt then stmt else stmt</p><p>​| a</p><p>expt $\rightarrow$  b</p><p>左公因子为：if expr then stmt</p><p>提取左公因子，得到文法：</p><p>stmt $\rightarrow$ if expr then stmt S’ | a</p><p>S’  $\rightarrow$ else stmt |  ε</p><p>expt  $\rightarrow$ b</p><h2 id="构造不含ε-产生式的文法">构造不含ε-产生式的文法</h2><p>为含有ε-产生式的文法G=（V<sub>T</sub>，V<sub>N</sub>，S，φ）构造不含ε-产生式的文法G‘=（V<sub>T</sub><sup>‘</sup>，V<sub>N</sub><sup>’</sup>，S，φ<sup>'</sup>）</p><p>若产生式A$\rightarrow$X<sub>1</sub>X<sub>2</sub>…Xn⋳φ则把产生式A$\rightarrow$α<sub>1</sub>α<sub>2</sub>…α<sub>n</sub>加入φ’<br>其中：X<sub>i</sub>、α<sub>i</sub>为文法符号，即X<sub>i</sub>、α<sub>i</sub>⋳(V<sub>T</sub>UV<sub>N</sub>)</p><p>若X<sub>i</sub>不能产生ε，则α<sub>i</sub>=X<sub>i</sub></p><p>若X<sub>i</sub>能产生ε，则α<sub>i</sub>=X<sub>i</sub>或α<sub>i</sub>=ε</p><p>注意：不能所有的α<sub>i</sub>都取ε</p><p>文法G’满足：</p><p>L(G’) = L(G) - {ε}  L(G)中含有ε，或L(G) ，L(G)中不含有ε</p><p><strong>一个文法是ε-无关的，</strong></p><p>如果它没有ε-产生式（即形如A$\rightarrow$ε的产生式），或者</p><p>只有一个ε-产生式，即S$\rightarrow$ε并且文法的开始符号S不出现在任何产生式的右部。</p><p>十五、化简文法方法</p><p>文法中不含有有害规则和多余规则</p><p>有害规则：形如U→U的产生式。会引起文法的二义性</p><p>多余规则：指文法中任何句子的推导都不会用到的规则</p><p>文法中不含有不可到达和不可终止的非终结符</p><ul><li>文法中某些非终结符不在任何规则的右部出现，该非终结符称为不可到达。</li><li>文法中某些非终结符，由它不能推出终结符号串，该非终结符称为不可终止。</li></ul><p><strong>化简文法</strong></p><p>例如 G[S] ：</p><ol><li><p>S→Be</p></li><li><p>B → Ce</p></li><li><p>B → Af</p></li><li><p>A → Ae</p></li><li><p>A → e</p></li><li><p>C → Cf</p></li><li><p>D → f</p></li></ol><p>D 为不可到达，C为不可终止</p><p>产生式 2) , 6),  7)为多余规则</p>]]></content>
      
      
      <categories>
          
          <category> 编译原理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编译原理 </tag>
            
            <tag> 形式语言 </tag>
            
            <tag> 文法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GCC 基本使用教程</title>
      <link href="/2021/05/08/gcc-ji-ben-shi-yong-jiao-cheng/"/>
      <url>/2021/05/08/gcc-ji-ben-shi-yong-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<p>GCC全称GNU C Compiler，是以GPL协议发布的自由软件，其创始人理查德·马修·斯托曼是自由软件运动的精神领袖。</p><p>GNU 编译器套件包括 C、C++、Objective-C、Java、Ada 和 Go 语言前端，也包括了这些语言的库（如 libstdc++，libgcj等）</p><p>GCC 不仅支持 C 的许多“方言”，也可以区别不同的 C 语言标准；可以使用命令行选项来控制编译器在翻译源代码时应该遵循哪个 C 标准。例如，当使用命令行参数<code>-std=c99</code> 启动 GCC 时，编译器支持 C99 标准。</p><span id="more"></span><p>查看版本 gcc/g++ -v/–version</p><blockquote><p>g++相对gcc对代码书写规范更加严格，如果编译 c++ 语言,将其替换为 g++ 即可。</p></blockquote><h1>编译过程</h1><p>高级语言源代码 -&gt; 汇编语言 -&gt; 机器语言</p><h2 id="新建文件-t-c">新建文件 t.c</h2><p><code>vim t.c</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="预处理">预处理</h2><p>展开所有的include文件，包括头文件和宏定义，生成.i文件</p><p><code>g++ -E t.c -o t.i</code></p><h2 id="编译">编译</h2><p>把目标代码编译为汇编代码，生成.s文件</p><p><code>gcc -S t.cpp -o t.s</code></p><h2 id="汇编器">汇编器</h2><p>把指定源码编译为机器码.o文件包括（启动代码，目标代码，库代码，其它目标代码），但不进行链接</p><p><code>gcc -c t.c -o t.o</code></p><h2 id="链接器">链接器</h2><p>生成可执行 ELF 文件</p><p>gcc t.o -o t</p><h1>常用参数</h1><table><thead><tr><th>gcc编译选项</th><th>说明</th></tr></thead><tbody><tr><td>-E</td><td>预处理指定的源文件，不进行编译</td></tr><tr><td>-S</td><td>编译指定的源文件，但是不进行汇编</td></tr><tr><td>-c</td><td>编译、汇编指定的源文件，但是不进行链接</td></tr><tr><td>-o [file1] [file2] / [file2] -o [file1]</td><td>将文件 file2 编译成可执行文件 file1</td></tr><tr><td>-I directory</td><td>指定 include 包含文件的搜索目录</td></tr><tr><td>-g</td><td>在编译的时候，生成调试信息，该程序可以被调试器调试</td></tr><tr><td>-D</td><td>在程序编译的时候，指定一个宏</td></tr><tr><td>-w</td><td>不生成任何警告信息</td></tr><tr><td>-Wall</td><td>生成所有警告信息</td></tr><tr><td>-On</td><td>n的取值范围：0~3。编译器的优化选项的4个级别，-O0表示没有优化，-O1为缺省值，-O3优化级别最高</td></tr><tr><td>-l</td><td>在程序编译的时候，指定使用的库</td></tr><tr><td>-L</td><td>指定编译的时候，搜索的库的路径。</td></tr><tr><td>-fPIC/fpic</td><td>生成与位置无关的代码</td></tr><tr><td>-shared</td><td>生成共享目标文件，通常用在建立共享库时</td></tr><tr><td>-std</td><td>指定C方言，如:-std=c99，gcc默认的方言是GNU C</td></tr></tbody></table><h2 id="在程序中加入调试信息">在程序中加入调试信息</h2><p>新建源文件 t.c</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> DEBUG    </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;这是一条调试信息\n&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> b, c, d, f;</span><br><span class="line">    b = <span class="number">10</span>;</span><br><span class="line">    c = b;</span><br><span class="line">    d = c;</span><br><span class="line">    f = d;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;hello gcc\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用两种方式可以输出 DEBUG，一种是在程序开头定义 DEBUG宏，例如 <code>#define DEBUG</code></p><p>另一种是使用 gcc -D 命令选项。</p><p><code>gcc t.c -o t -D DEBUG</code>      //DEBUG是在程序中指定的，可以指定多个</p><p>执行<code>./t</code>，就能输出 DEBUG信息</p><h2 id="不生成任何警告">不生成任何警告</h2><p>-w</p><p>gcc t.c -o t -w</p><h2 id="生成所有的警告信息">生成所有的警告信息</h2><p>-Wall</p><p>gcc t.c -o t -Wall</p><p>执行上述语句，则会输出：</p><p>t.c:4:9: warning: unused variable ‘a’ [-Wunused-variable]<br>int a = 10;</p><h2 id="编译器优化级别">编译器优化级别</h2><p>-O0</p><p>-O1</p><p>-O2</p><p>-O3</p><p>级别越高，编译优化越大，越不容易通过反汇编得到原始代码。</p><h2 id="包含调试信息">包含调试信息</h2><p>此时调试信息为源代码，该程序可被调试器调试，比如可被GDB调试</p><p>-g</p><p>gcc t.c -o t -D DEBUG -g //该程序还包括-D参数，调试时包括DEBUG信息</p><h2 id="指定include-包含文件的搜索目录">指定include 包含文件的搜索目录</h2><p>gcc t.c -o t -I 路径     //I为i的大些</p><h2 id="在程序编译时，指定使用的库">在程序编译时，指定使用的库</h2><p>-l</p><p>gcc t.c -o t -l 库名称</p><h2 id="在编译时，指定使用的库的路径">在编译时，指定使用的库的路径</h2><p>-L</p><p>gcc t.c -o t -L 库路径</p><h2 id="生成与位置无关代码">生成与位置无关代码</h2><p>-fpic/fPIC</p><p>gcc t.c -o t -fpic</p><h2 id="生成共享目标文件，通常用在建立共享库时">生成共享目标文件，通常用在建立共享库时</h2><p>-shared</p><p>gcc t.c -o t -shared</p><h2 id="指定c方言">指定c方言</h2><p>-std=c99</p><p>gcc t.c -o t -std=c99 以c99标准编译源文件</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> gcc </tag>
            
            <tag> g++ </tag>
            
            <tag> 编译过程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Common Lisp 语法规则</title>
      <link href="/2021/04/26/common-lisp-yu-fa-gui-ze/"/>
      <url>/2021/04/26/common-lisp-yu-fa-gui-ze/</url>
      
        <content type="html"><![CDATA[<h1>注释</h1><p>;;;; 四个分号用于文件头注释<br>;;; 三个分号用于一大段特定代码的作用的描述<br>;; 某几行代码的功能性描述，注释与被注释的代码具有相同的缩进<br>; 用于单行注释</p><h1>S-表达式</h1><span id="more"></span><p>S-表达式的基本元素是列表(list)和原子(atom)。列表由括号所包围，并可包含任意数量的由空格所分隔的元素。原子是不可分割的元素。列表元素本身也可以是S-表达式。</p><p>比如(1 2 3) ，(“stf” 1 2 3)，(foo 1 2 3) ， (foo 1 2 3 (getMax 4 5))等都是S表达式。</p><h1>常见原子类型</h1><h2 id="数字">数字</h2><p>由(数位)，(.)，(表示正负的+或-)，(除号/)，(指数标记e或d)</p><p>123           ;表示数字123<br>+122        ;表示正123<br>-122          ;表示负122<br>12.1          ;默认精度浮点数<br>121e-1     ;同一个浮点数另一种写法<br>121d-1     ;双精度浮点数<br>-5/4           ;比值-五分之四</p><h2 id="字符串">字符串</h2><p>由双引号包围的某些可见字符组成的序列，反斜杠()为转移字符，转义接下来的任意字符</p><p>例如：<br>“foo”      表示由f,o,o组成的字符串<br>“fo\o”     同一个字符串<br>“fo\o”    表示由f,o,,o组成的字符串<br>“fo\”o”    表示由f,o,”,o组成的字符串</p><h2 id="名字">名字</h2><p>函数名和变量名是最常见的名字。几乎任何字符都可以出现在名字里，只要整个名字不被解释成一个数字，名字还可以包含句点(.)，但一个合法Lisp名字不能全为句点(.)。</p><p>10个特殊的字符不能被用于名字，分别是：<br>开括号       ()<br>闭括号       []<br>双引号       “<br>单引号        ‘<br>反引号        `<br>逗号            ,<br>冒号            :<br>分号            ;<br>反斜杠        <br>竖线            |</p><p>如果非用用这10个字符作为名字，则必须在字符前加入转移字符()<br>例如：<br>on\off    可以表示一个名字：on\of，但在定义和使用时应该使用完整名称<br>on\off。</p><h1>Lisp形式的S-表达式</h1><h2 id="函数调用">函数调用</h2><p>(function-name argument*)</p><p>比如:<br>(+ 1 2)            ;+号为函数名<br>(/ 2 (+ 1 1))    ;最外层的/是函数名，内部嵌套的+也为函数名</p><h2 id="特殊操作符">特殊操作符</h2><p>并非所有的操作都能定义成函数。例如以下条件判断语句也可以作为S-表达式。<br>(if (x) (format t “yes”) (format t “no”))     ；(x)返回真，输出yes, 为假输出no</p><p>(quote S-表达式)          ;只是简单返回S-表达式<br>以上等价于 `(S-表达式)</p><p>总结：一般特殊操作符所实现的语言特性，需要求值器作出某些特殊处理。</p><h2 id="宏">宏</h2><p>宏是以S-表达式为其参数的函数，并返回一个Lisp形式</p><p>宏的求值包含两个阶段：</p><ol><li>宏形式的元素不经求值即被传递到宏函数里。且这些元素不必是标准的Lisp形式。</li><li>由宏函数所返回的形式按照正常的求值规则进行求值。</li></ol><p>当Lisp代码被编译时，源文件的所有宏形式将被递归展开，直到代码中只有函数调用形式和特殊形式。这些无宏的代码被编译成一个FASL文件——Load函数知道如何去加载它。</p><h2 id="真假和等价">真假和等价</h2><p>符号NIL表示唯一的假值，除此以外的所有值都是真值T.</p><p>NIL是唯一一个既是原子又是列表的对象，因为它既可以作为假值使用，又可以作为空列表()</p><p>所以  nil,   (),  `() ,  `nil的求值结果相同<br>t  `t的求值结果也相同</p><h2 id="等价："><strong>等价：</strong></h2><p>EQ：是最严格的等价判断，只有当两个对象相同时才返回T, 其它都返回nil。</p><p>EQL：相比EQ更为宽松，当两个对象表示相同的字符或数字时，即使不是相同的对象，也返回T，其它类型回退到EQ水平。<br>例如(EQL 1 1)返回T，但(EQL 1 1.0)则返回nil, 因为1和1.0属于不同的对象。</p><p>EQUAL 相比EQL更宽松的一点是，它将在递归上具有相同结构和内容的列表视为等价，EQUAL 也认为含有相同字符的字符串是等价的。它对于位向量和路径名也定义了比EQL更加宽松的等价性。对于所有其它类型，它回退到EQL的水平。</p><p>EQUALP比EQUAL更加宽松之外，也相似于EQUAL，在判断两个字符串等价时忽略了大小写的区别，只要表示相同数学意义的值，它们就是等价的<br>例如：<br>(EQUALP  “helloworld” “HelloWorld”) 返回T<br>(EQUALP 1 1.0) 返回T</p><h2 id="emacs小技巧">emacs小技巧</h2><p>选中，C-M-q重新缩进整个表达式<br>在函数体的任何位置 通过C-c M-q来缩进整个函数体</p>]]></content>
      
      
      <categories>
          
          <category> Lisp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lisp </tag>
            
            <tag> 语法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Common Lisp函数</title>
      <link href="/2021/04/26/common-lisp-han-shu/"/>
      <url>/2021/04/26/common-lisp-han-shu/</url>
      
        <content type="html"><![CDATA[<h1>定义新函数</h1><p>新函数一般用defun宏来定义。其基本结构为：<br>(defun name<br>“一些说明文字”<br>body-form*)</p><p>任何符号都可以作为函数名，但通常函数名仅包含字典字符和连字符，但在特定的命名约定里，其它字符也允许使用。例如+函数可以将一个或多个数字相加。</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(defun hello-world()</span><br><span class="line">  &quot;打印Hello,world&quot;</span><br><span class="line">  (format t &quot;Hello,world&quot;))</span><br></pre></td></tr></table></figure><p>hello-world是函数名</p><ul><li>（）：形参列表，本函数无需传入实参</li><li>“打印Hello,world” ：注释字符串，可以通过documentation函数来获取<br>例如 <code> (documentation 'hello-world 'function)</code></li><li>(format t “Hello,world”) ：函数体，作用是向标准输出打印”Hello,world”</li></ul><p>body-form*可包含多个括号括起来的表达式，最后一个表达式的值作为函数的值返回。</p><h1>函数形参列表</h1><p>形参列表的基本用户为声明一些变量来接收传递给函数的实参，普通的形参列表，必须为每一个必要形参提供一个实参，不然会报错。</p><p>接下来讨论可选形参，剩余形参，关键字形参。</p><h1>可选形参</h1><p>当有时提供的实参数小于形参数时，未赋值的形参用默认值填充，默认值可以指定。在必要形参后放置符号&amp;optional, 后接可选形参的名字。<br>例如：<br><code>(defun foo (a b &amp;optional c d) (list a b c d)</code><br>可以这样调用：<br>(foo 1 2)  -&gt; (1 2 NIL)<br>(foo 1 2 3) -&gt; (1 2 3 NIL)<br>(foo 1 2 3 4) -&gt; (1 2 3 4)</p><p>有时想为可选的形参名提供默人值，可以这样写：<br><code>(defun foo (a b &amp;optional (c 10)) (list a b c)</code><br>(foo 1 2)  -&gt; (1 2 10)<br>(foo 1 2 3) -&gt; (1 2 3)</p><p>还可以基于其它形参来计算默认值<br><code>(defun foo (a &amp;optional (b a)) (list a b c)</code><br>(foo 12)  -&gt; (12 12)<br>(foo 12 6)  -&gt; (12 6)</p><h1>剩余形参</h1><p>有时需要根据需要传递多个实参给形参，可能1个，2个或多个。<br>在必要形参，可选形参后放置&amp;rest，那么可将满足了必要形参和可选形参之后的其余所有实参就会被被收集到一个列表里成为&amp;rest形参的值。</p><p><code>(defun + (&amp;rest numbers) ...)</code></p><h1>关键字形参</h1><p>假如调用者只想为四个参数中的一个提供值，或者更进一步，不同的调用者有可能将分别选择使用其中一个参数。<br>在任何必要的可选形参和剩余形参后放置符号&amp;key以及任意数量的关键字形参标识符<br><code>(defun foo (&amp;key a b c) (list a b c) )</code></p><p>(foo)     -&gt;    (NIL,NIL,NIL)<br>(foo :a 1)   -&gt;  (1,NIL,NIL)<br>(foo :b 1)   -&gt; (NIL,1,NIL)<br>(foo :c 1)   -&gt; (NIL,NIL,1)<br>(foo a: 1 :b 2 c: 3)    -&gt; (1 2 3)<br>(foo a: 1 :c 3 b: 2)    -&gt; (1 2 3)</p><h1>混合不同的形参类型</h1><p>各种形参的声明顺序必须是：必要形参，可选形参，然后剩余形参，最后关键字形参。<br>一般情况是把必要形参和另外一种类型的形参组合使用。<br>或者是：组合&amp;optional形参和&amp;rest形参。</p><p>如果一个函数要同时使用&amp;optional形参和&amp;key形参，应该把所有形参都是用&amp;key形参，这样更加灵活，并且总可以在不破坏该函数的已有调用的情况下添加新的关键字形参。</p><p>一般而言，使用关键字形参会使代码相对易于维护和扩展。</p><h1>函数返回值</h1><p>默认情况下函数最后一个表达式的值作为整个函数的返回值。</p><p>也可以使用return-from语句来在任何位置返回。</p><p>例如：<br>该函数用来发现一个数对，其中每个数都小于10，并且其乘机大于函数的参数n。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(defun foo (n)</span><br><span class="line">  (dotimes (i 10)</span><br><span class="line">    (dotimes (j 10)</span><br><span class="line">      (when (&gt; (* i j) n)</span><br><span class="line">      (return-from foo (list i j))))))</span><br></pre></td></tr></table></figure><h1>作为数据的函数——高阶函数</h1><p>函数也可以作为一种数据，保存在变量里，还可以传递给其它函数。<br>用defun定义一个函数时，实际上做了两件事：创建一个新的函数对象以及赋予其一个名字，也可以用lambda表达式来创建一个没有名字的函数。</p><p>一个函数对象的实际表示，无论是有名字还是匿名的，都只是一些二进制数据——以原生编译的Lisp形式存在，可能大部分是由机器码构成。</p><p>只需要知道如何保持它们，和需要时如何调用它们。</p><p>特殊操作符function可以用来获取一个函数对象<br>num++为函数名，用来将函数参数递增1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CL-USER&gt; (defun num++(n) (+ n 1))</span><br><span class="line">NUM++</span><br><span class="line">CL-USER&gt; (num++ 12)</span><br><span class="line">13</span><br><span class="line">CL-USER&gt; (num++ 14)</span><br><span class="line">15</span><br><span class="line">CL-USER&gt; (function num++)</span><br><span class="line">#&lt;FUNCTION NUM++&gt;     ;NUM++为函数对象</span><br></pre></td></tr></table></figure><p>(function num++) 类似于 #‘num++</p><p>当得到了函数对象，就可以调用它</p><p>可以通过funcall函数和apply函数来通过函数对象调用函数。<br>两者的区别：</p><ul><li>funcall用于在编写代码时确切知道传递给函数多少个实参</li><li>(apply 'num++ ‘(1))  类似于 (funcall #’num++ 1)</li></ul><h1>匿名函数</h1><p>使用lambda创建匿名函数的形式如下：<br><code>(lambda (parameters) body)</code></p><p>例如:<br>`(funcall #'(lambda (x y) (+ x y)) 2 3)  ;返回5</p>]]></content>
      
      
      <categories>
          
          <category> Lisp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lisp </tag>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 简明教程</title>
      <link href="/2021/04/25/git-jian-ming-jiao-cheng/"/>
      <url>/2021/04/25/git-jian-ming-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1>本地仓库</h1><ol><li><p>进入项目目录</p></li><li><p>版本库初始化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git init</span></span><br><span class="line">Initialized empty Git repository in /home/mygit/test/learn-git/.git/</span><br></pre></td></tr></table></figure></li></ol><span id="more"></span><ol start="3"><li><p>创建，查看和回退历史版本库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加文件 可以一个或多个文件 此时文件进入 暂存区</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add readme.txt</span>  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">此时刚添加的文件正式加入版本库，后续可恢复到提前前的状态</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;add readme.txt&quot;</span></span>     </span><br><span class="line">[master (root-commit) a1f54c2] add readme.txt</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 readme.txt</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加新文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;add file&quot;</span></span>            </span><br><span class="line">[master 3a3853a] add file</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 file</span><br><span class="line"><span class="meta prompt_"> </span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">添加修改过的文件 readme.txt 到暂存区</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add readme.txt</span>                  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把刚添加的文件放进版本库</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;add This project help you to learn git.&quot;</span></span>   </span><br><span class="line">[master bd8b50d] add This project help you to learn git.</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看版本库信息</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span></span>                             </span><br><span class="line">commit bd8b50d5b5062ac342f82f249bffba7d6baf0036 (HEAD -&gt; master)</span><br><span class="line">Author: wangjunstf &lt;2634683912@qq.com&gt;</span><br><span class="line">Date:   Fri Apr 23 10:05:09 2021 +0800</span><br><span class="line">    add This project help you to learn git.</span><br><span class="line"></span><br><span class="line">commit 3a3853a5374156ea2f7fdb7e07f06077636bd4bb</span><br><span class="line">Author: wangjunstf &lt;2634683912@qq.com&gt;</span><br><span class="line">Date:   Fri Apr 23 09:54:23 2021 +0800</span><br><span class="line">    add file</span><br><span class="line">......</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">简化版本库信息输出</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --pretty=oneline</span>            </span><br><span class="line">bd8b50d5b5062ac342f82f249bffba7d6baf0036 (HEAD -&gt; master) add This project help you to learn git.</span><br><span class="line">3a3853a5374156ea2f7fdb7e07f06077636bd4bb add file</span><br><span class="line">a1f54c2045fca053248ee67fffff087a478dfa72 add readme.txt</span><br></pre></td></tr></table></figure></li><li><p>版本回退</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回退到上一个版本</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard HEAD^</span>                </span><br><span class="line">HEAD is now at 3a3853a add file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">回退到指定版本,本指令和上一条指令的执行效果相同</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset --hard 3a3853</span>               </span><br><span class="line">HEAD is now at 3a3853a add file</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看历史记录</span>  </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reflog</span></span><br><span class="line">3a3853a (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to 3a3853</span><br><span class="line">3a3853a (HEAD -&gt; master) HEAD@&#123;1&#125;: reset: moving to HEAD^</span><br><span class="line">bd8b50d HEAD@&#123;2&#125;: commit: add This project help you to learn git.</span><br><span class="line">3a3853a (HEAD -&gt; master) HEAD@&#123;3&#125;: commit: add file</span><br><span class="line">a1f54c2 HEAD@&#123;4&#125;: commit (initial): add readme.txt</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">如果想恢复到调用reset之前的版本，可以用该命令查看指定的版本号恢复</span></span><br></pre></td></tr></table></figure></li><li><p>查看和修改工作区内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看工作区信息</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span>                            </span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改完文件之后，该命令能显示工作区的当前状态</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">modified:   readme.txt</span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) </span><br><span class="line"></span><br><span class="line">                # modified:   readme.txt 表示readme.txt已经修改过，但还没放入暂存区</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add readme.txt                    <span class="comment"># 将readme.txt 加入 暂存区</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">modified:   readme.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">modified:   readme.txt 表示readme.txt已经添加到暂存区，还未加入版本库</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看工作区和版本库里面最新版本的区别  HEAD^ 次新版本</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff HEAD -- readme.txt</span>           </span><br><span class="line">diff --git a/readme.txt b/readme.txt</span><br><span class="line">index d344129..2200906 100644</span><br><span class="line">--- a/readme.txt</span><br><span class="line">+++ b/readme.txt</span><br><span class="line">@@ -1 +1,3 @@</span><br><span class="line"> This is a readme file.</span><br><span class="line">+</span><br><span class="line">+This is a guide.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">丢弃工作区的修改 ,回到最近提交到版本库的版本，暂存区不变</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -- readme.txt</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">把暂存区的内容放回工作区</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git reset HEAD file</span>                   </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">丢弃工作区的修改，上面和本条命令结合，撤销了提交到暂存区的修改</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -- file</span>                  </span><br></pre></td></tr></table></figure></li><li><p>删除文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">删除工作区文件</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">rm</span> test.txt</span> </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">将删除操作提交到版本库</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;remove test.txt&quot;</span></span>        </span><br></pre></td></tr></table></figure></li></ol><h1>远程仓库提交(GitHub)</h1><ol><li><p>创建远程仓库</p><p>在<a href="https://github.com/%E7%BD%91%E7%AB%99%E4%B8%8A%E5%88%9B%E5%BB%BA%E4%BB%93%E5%BA%93">https://github.com/网站上创建仓库</a></p></li><li><p>将远程仓库克隆到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> git@github.com:wangjunstf/learn-git.git</span></span><br></pre></td></tr></table></figure></li><li><p>在远程仓库添加ssh公钥，具体百度</p></li><li><p>与远程仓库建立连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote add learngit git@github.com:wangjunstf/learn-git.git</span></span><br></pre></td></tr></table></figure></li><li><p>将本地库的所有内容推送到远程库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push -u learngit main</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">当与远程仓库建立连接之后使用 git push -u 远程仓库名 远程仓库分支</span></span><br></pre></td></tr></table></figure></li><li><p>查看远程仓库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git remote -v</span></span><br><span class="line">learngitgit@github.com:wangjunstf/learn-git.git (fetch)</span><br><span class="line">learngitgit@github.com:wangjunstf/learn-git.git (push)</span><br><span class="line">origingit@github.com:wangjunstf/learn-git.git (fetch)</span><br><span class="line">origingit@github.com:wangjunstf/learn-git.git (push)</span><br></pre></td></tr></table></figure></li></ol><h1>与远程仓库同步</h1><ol><li><p>抓取远程仓库更新内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch learngit main</span></span><br><span class="line">From github.com:wangjunstf/learn-git</span><br><span class="line"> * branch            main       -&gt; FETCH_HEAD</span><br><span class="line">   b291452..4bc596d  main       -&gt; learngit/main</span><br></pre></td></tr></table></figure></li><li><p>比较远程更新和本地版本库的差异</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> main.. learngit/main</span></span><br><span class="line">commit 4bc596dc726ee376e1b8c4b4264c35dfe80e0143 (origin/main, origin/HEAD, learngit/main)</span><br><span class="line">Author: jun &lt;47825821+wangjunstf@users.noreply.github.com&gt;</span><br><span class="line">Date:   Fri Apr 23 15:42:13 2021 +0800</span><br><span class="line"></span><br><span class="line">    Update hello.txt</span><br><span class="line"></span><br><span class="line">commit 3535e258a9ed18139bcca5a11b0ccd0624f51351</span><br><span class="line">Author: jun &lt;47825821+wangjunstf@users.noreply.github.com&gt;</span><br><span class="line">Date:   Fri Apr 23 15:41:37 2021 +0800</span><br><span class="line"></span><br><span class="line">    Update hello.txt</span><br></pre></td></tr></table></figure><p>可以看到，远程比本地多了两次commit</p></li><li><p>合并远程更新到本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge learngit/main</span></span><br><span class="line">Updating b291452..4bc596d</span><br><span class="line">Fast-forward</span><br><span class="line"> hello.txt | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure></li></ol><h1>分支管理</h1><h2 id="分支创建与合并">分支创建与合并</h2><ol><li><p>创建于切换分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch dev      <span class="comment"># 创建分支 dev</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout dev    <span class="comment"># 切换到分支dev</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b dev   <span class="comment"># 创建并切换到分支dev  相当于以上两条命令</span></span></span><br></pre></td></tr></table></figure></li><li><p>显示分支情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch</span></span><br><span class="line">* dev</span><br><span class="line">  main</span><br></pre></td></tr></table></figure></li><li><p>修改某些文件并提交到dev</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;branch test&quot;</span></span></span><br><span class="line">[dev 0289255] branch test</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure></li><li><p>切换回主分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout main</span></span><br><span class="line">Switched to branch &#x27;main&#x27;</span><br></pre></td></tr></table></figure></li><li><p>与合并dev分支到main分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge dev</span></span><br><span class="line">Updating 4bc596d..0289255</span><br><span class="line">Fast-forward</span><br><span class="line"> README.md | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br></pre></td></tr></table></figure></li><li><p>合并完成，删除dev分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d dev</span></span><br><span class="line">Deleted branch dev (was 0289255).</span><br></pre></td></tr></table></figure></li></ol><h2 id="分支冲突解决">分支冲突解决</h2><ol><li><p>创建分支feature，并在文件结尾添加&quot;Creating a new branch is quick AND simple.&quot;</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;feature&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README.md</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;And simeple&quot;</span></span></span><br><span class="line">[feature 01d4edf] feature</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></li><li><p>切回主分支并修改之前添加的内容，将AND simple 改为&amp; simple，并提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout main</span></span><br><span class="line">git add README.md </span><br><span class="line">git commit -m &quot;&amp; simple&quot;</span><br><span class="line">[main 329cbc2] &amp; simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure></li><li><p>合并</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge feature</span></span><br><span class="line">Auto-merging README.md</span><br><span class="line">CONFLICT (content): Merge conflict in README.md</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure></li><li><p>查看存在冲突的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git status</span></span><br><span class="line">On branch main</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line">  (use &quot;git merge --abort&quot; to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line">  </span><br><span class="line">both modified:   README.md</span><br></pre></td></tr></table></figure></li><li><p>冲突解决。因为两个分支修改了同样的内容，git无法自动合并，需要手动合并。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim README.md          <span class="comment"># 打开存在冲突的文件</span></span></span><br><span class="line">git会把存在冲突的部分标记为以下形式，我们需要手动修改它们</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating a new branch is quick AND simple.</span><br><span class="line"><span class="meta prompt_">&gt;</span><span class="language-bash">&gt;&gt;&gt;&gt;&gt;&gt; feature1</span></span><br><span class="line"></span><br><span class="line">将以上内容改为：</span><br><span class="line">Creating a new branch is quick &amp; simple.</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add README.md</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;conflict fixed&quot;</span></span></span><br><span class="line">[main ae5e8c4] conflict fixed   # 表示冲突已经解决  </span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -d feature         <span class="comment"># 删除已经合并的分支</span></span></span><br></pre></td></tr></table></figure></li><li><p>查看分支合并图</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> --graph</span></span><br></pre></td></tr></table></figure></li></ol><h1>分支管理策略</h1><h2 id="–no-ff模式">–no-ff模式</h2><p>git默认采用Fast forward模式，Fast forward会丢失合并前的信息。–no-ff模式合并，即禁用Fast forward</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge --no-ff -m <span class="string">&quot;merge with no-ff&quot;</span> dev <span class="comment"># 此时合并前会为提交之前的版本 提交一个commit</span></span></span><br></pre></td></tr></table></figure><h2 id="bug分支">bug分支</h2><ol><li><p>隐藏工作现场，此时一般是有紧急任务，比如修复某分支bug，但当前分支的修改还没提交到版本库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash<span class="comment"># 保存工作现场，一会恢复，工作区和暂存区的内容都会恢复</span></span></span><br></pre></td></tr></table></figure></li><li><p>查看工作现场</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash list</span></span><br><span class="line">stash@&#123;0&#125;: WIP on dev: ae5e8c4 conflict fixed</span><br></pre></td></tr></table></figure></li><li><p>修复完其他分支的bug，回到之前的分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash apply    <span class="comment"># 恢复到之前的工作现场   stash内容并不删除</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash drop     <span class="comment"># 删除最近一次保存的stash</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash pop      <span class="comment">#相当于执行以上两条命令，在恢复现场的同时删除stash</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git stash apply stash@&#123;0&#125;  <span class="comment"># 恢复到指定stash</span></span></span><br></pre></td></tr></table></figure></li><li><p>合并其他分支的commit（bug修复）到当前分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git cherry-pick 4c805e2</span></span><br></pre></td></tr></table></figure></li><li><p>强制删除分支（未合并分支）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch -D feature-vulcan</span></span><br></pre></td></tr></table></figure></li></ol><h1>多人协作</h1><p>假如现有一同事在同时维护一个仓库。</p><h2 id="提交远程时的冲突">提交远程时的冲突</h2><ol><li><p>默认克隆的仓库只能看到main分支，需要使用其他分支，需要创建分支并关联。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout -b dev origin/dev</span></span><br></pre></td></tr></table></figure></li><li><p>指定本地dev分支与远程dev分支建立连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git branch --set-upstream-to=origin/dev dev</span></span><br></pre></td></tr></table></figure></li><li><pre><code class="language-shell">$ git pull       # 作用为与远程合并，这时冲突依然存在，需要打开存在冲突的文件，手动修改冲突的部分，在commit提交，就可提交远程仓库<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. 与远程分支建立映射</span><br><span class="line"></span><br><span class="line">   ```shell</span><br><span class="line">   $ git branch -u origin/dev dev</span><br><span class="line">   Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure></code></pre></li></ol><h2 id="与远程同步时的冲突">与远程同步时的冲突</h2><p>出现问题的原因大多是远程仓库，版本高于本地，即要提交的文件，远程仓库已经有了修改过的版本，这时需要手动解决冲突。</p><ol><li><p>将远程仓库的所有更改取回本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git fetch origin</span></span><br></pre></td></tr></table></figure></li><li><p>比较远程仓库和本地仓库的差异</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">log</span> dev..origin/dev     <span class="comment"># 查看远程仓库的最新commit信息</span></span></span><br></pre></td></tr></table></figure></li><li><p>统计文件的改动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git diff --<span class="built_in">stat</span> dev origin/dev</span></span><br></pre></td></tr></table></figure></li><li><p>与远程分支合并</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git merge origin/dev</span></span><br></pre></td></tr></table></figure></li><li><p>一键同步远程分支</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git pull        <span class="comment"># 相当于 git fetch origin + git merge origin/dev</span></span></span><br></pre></td></tr></table></figure></li><li><p>若存在冲突，则打开冲突的文件，修改冲突的部分，假设mac.txt冲突</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim mac.txt            <span class="comment"># 修改冲突的部分</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add mac.txt</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;fix conflict&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin dev    <span class="comment">#这样就可以提交了</span></span></span><br></pre></td></tr></table></figure></li><li><p>将多个提交合并为一个提交</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">git rebase -i  [startpoint]  [endpoint]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase -i 36224db     <span class="comment"># git log查看</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git rebase -i HEAD~3      <span class="comment"># 和上条命令等小</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">打开后，将pick改成特定的字母即可</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">例如</span> </span><br><span class="line"> pick 7885574 add second</span><br><span class="line"> pick cdcd83f add second</span><br><span class="line"> pick 4db5372 add 1.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将以上内容改为</span></span><br><span class="line"> pick 7885574 add second</span><br><span class="line"> s cdcd83f add second</span><br><span class="line"> s 4db5372 add 1.txt</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">保存退出后，弹出的界面修改注释,保存就可将三条提交合并为一条</span></span><br></pre></td></tr></table></figure></li></ol><h1>标签</h1><ol><li><p>给当前版本打上标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag v0.9</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag v0.9 4db537274   <span class="comment"># 查询commit id</span></span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -a v0.1 -m <span class="string">&quot;version 0.1 released&quot;</span> 4db537274  <span class="comment"># 创建待说明的标签</span></span></span><br></pre></td></tr></table></figure></li><li><p>查看标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag</span></span><br></pre></td></tr></table></figure></li><li><p>查看标签信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git show v0.9</span></span><br></pre></td></tr></table></figure></li><li><p>标签删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -d v0.9</span></span><br></pre></td></tr></table></figure></li><li><p>推送某个版本到远程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin v1.0</span><br></pre></td></tr></table></figure></li><li><p>把本地尚未推送的标签推送到远程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --tags</span><br></pre></td></tr></table></figure></li><li><p>删除远程标签</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git tag -d v0.9</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push origin :refs/tags/v0.9</span></span><br></pre></td></tr></table></figure></li></ol><h1>相关资源</h1><p>master 迁移到 main</p><p><a href="https://segmentfault.com/a/1190000038643126">https://segmentfault.com/a/1190000038643126</a></p><p>git 教程</p><p><a href="http://iissnan.com/progit/html/zh/ch1_0.html">http://iissnan.com/progit/html/zh/ch1_0.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> 版本控制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux进程管理</title>
      <link href="/2021/04/16/linux-jin-cheng-guan-li/"/>
      <url>/2021/04/16/linux-jin-cheng-guan-li/</url>
      
        <content type="html"><![CDATA[<h1>CentOS 7的启动过程</h1><ol><li>BIOS加电自检</li><li>进入Boot Loader</li><li>加载Linux系统内核</li><li>启动初始化程序（前期版本System V init，CentOS7中使用systems，采用并发启动机制，提升开启速度），该进程为系统的第一个进程。</li><li>systemd初始化系统，创建login进程。</li><li>用户登录，login进程创建shell进程。以后进程都是由shell衍生出来。</li></ol><span id="more"></span><p>systemd和System V init的区别与作用</p><table><thead><tr><th>System V init运行级别</th><th>systemd目标名称</th><th>作用</th></tr></thead><tbody><tr><td>0</td><td>runlevel0.target，poweroff.target</td><td>关机</td></tr><tr><td>1</td><td>runlevel1.target，rescue.target</td><td>单用户模式（救援模式）</td></tr><tr><td>2</td><td>runlevel2.target，multi-user.target</td><td>等同于级别3</td></tr><tr><td>3</td><td>runlevel3.target，multi-user.target</td><td>多用户的文本界面（服务器缺省模式）</td></tr><tr><td>4</td><td>runlevel4.target，multi-user.target</td><td>等同于级别3</td></tr><tr><td>5</td><td>runlevel5.target，graphical.target</td><td>多用户的图形界面</td></tr><tr><td>6</td><td>runlevel5.target，reboot.target</td><td>重启</td></tr><tr><td>emergency</td><td>emergency.target</td><td>紧急Shell</td></tr></tbody></table><p>改变系统默认的运行目标方法：ln命令将目标文件链接到/etc/systemd/system/目录即可</p><p>如：ln -sf /lib/systemd/system/muti-user.target /etc/systemd/system/default.target</p><h1>Linux中的进程</h1><p>根据进程PID区分不同的进程。</p><p>系统启动后的第一个进程是systemd，它的PID为1。</p><p>当系统启动以后，systemd进程会创建login进程等待用户登录系统。</p><p>当用户登录系统后，login进程就会为用户启动shell进程。</p><p>此后用户运行的进程都是由shell衍生出来的。</p><p>进程的另外4个识别号：实际用户识别号（real user ID），实际群组识别号（real group ID），以及有效用户识别号（effect user ID）和有效群组识别号（effect group ID）。</p><h2 id="进程启动方式">进程启动方式</h2><p>手工启动</p><p>调度启动</p><h2 id="进程的优先级">进程的优先级</h2><p>每个进程有一个默认优先级NICE值(0)</p><p>通过nice命令可以调整进程的NICE值</p><p>在CentOS中它的调整范围为-20~19，<strong>NICE的值越大，进程的优先级越低</strong>。</p><h2 id="进程的状态">进程的状态</h2><p>可执行态（runnable）</p><p>睡眠态（sleeping）</p><p>暂停态（stopped）</p><p>僵死态（zombie）</p><blockquote><p>任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程(Zombie)的数据结构，等待父进程处理。</p></blockquote><h2 id="Linux进程状态变换">Linux进程状态变换</h2><img src="https://wangjun-1257394474.cos.ap-beijing.myqcloud.com/uPic/%E6%88%AA%E5%B1%8F2021-04-16%20%E4%B8%8B%E5%8D%883.53.12.png" alt="截屏2021-04-16 下午3.53.12" style="zoom:50%;" /><h1>作业</h1><p>正在执行的一个或多个相关进程被称为作业。</p><p>一个作业可以包含一个或者多个进程。</p><p>作业可以分为两类：前台作业和后台作业</p><p>在某一时刻，每个用户只能有一个前台作业</p><h1>进程操作相关命令</h1><ol><li>ps</li><li>jobs</li><li>pstree</li><li>top</li><li>nice和renice</li><li>kill</li></ol><h2 id="ps命令">ps命令</h2><p>命令格式：ps [option]</p><table><thead><tr><th>常用选项</th><th>说明</th></tr></thead><tbody><tr><td>-a</td><td>显示当前控制终端的所有进程</td></tr><tr><td>-e</td><td>在命令后显示环境变量</td></tr><tr><td>-u</td><td>显示进程的用户名和启动时间等信息</td></tr><tr><td>-A</td><td>显示所有终端的进程</td></tr><tr><td>-u</td><td>显示进程所有者的信息</td></tr><tr><td>-x</td><td>显示没有控制终端的进程</td></tr><tr><td>-f</td><td>显示进程树</td></tr><tr><td>-w</td><td>宽行输出，不截取输出中的命令行</td></tr><tr><td>-l</td><td>按长格式显示输出</td></tr></tbody></table><h2 id="jobs命令">jobs命令</h2><p>功能：查看系统当前的所有作业</p><p>命令格式：jobs [options]</p><p>常用选项：</p><p>-p：仅显示进程号</p><p>-l：同时显示进程号和作业号</p><p>-r：只列出运行的作业</p><p>-s：只列出停止的作业</p><h2 id="pstree">pstree</h2><p>命令格式：pstree [option]</p><p>常用选项：</p><p>-a：显示每个程序的完整指令，包括路径，参数或是常驻服务的标示</p><p>-l：采用长列格式显示树状图</p><p>-p：显示进程的PID号</p><p>-u：显示用户名称</p><p>-V：显示版本信息</p><p>pid|user：根据pid或者user信息来显示我们需要的信息</p><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pstree -p    #以树状图显示进程，进程号及进程ID</span><br><span class="line">pstree -a    #以树状图显示所有进程的所有详细信息</span><br><span class="line">pstree 1     #以树状图显示PID为1的进程以及子孙进程</span><br><span class="line">pstree -p 1  #以树状图显示PID为1的进程以及子孙进程，同时显示每个进程的PID</span><br></pre></td></tr></table></figure><h2 id="top">top</h2><p>top命令是Linux下常用的性能分析工具，能够实时显示各个进程的资源占用情况。</p><p>命令格式：top [option]</p><p>常用选项:</p><p>-b 批处理</p><p>-c 显示完整的命令</p><p>-l 忽略失效过程</p><p>-s 保密模式</p><p>-S 累积模式</p><p>-i&lt;时间&gt; 设置间隔时间</p><p>-u&lt;用户名&gt; 指定用户名</p><p>-p&lt;进程号&gt; 指定进程</p><p>-n&lt;次数&gt;循环显示的次数</p><p>-d&lt;秒&gt; 信息更新时间</p><p>例如:</p><p>top -c //显示完整命令</p><p><strong>top的交互命令</strong></p><p>h 显示帮助画面，给出一些简短的命令总结说明</p><p>k 终止一个进程</p><p>i 忽略闲置和僵死进程。这是一个开关式命令。</p><p>q 退出程序</p><p>r 重新安排一个进程的优先级别</p><p>m 切换显示内存信息</p><p>t 切换显示进程和CPU状态信息</p><p>c 切换显示命令名称和完整命令行</p><p>M 工具驻留内存大小进行排序</p><p>P 根据CPU使用百分比大小进行排序</p><p>T 根据时间/累计时间进行排序</p><h2 id="nice-和renice命令">nice 和renice命令</h2><p>设置进程优先级的命令</p><ol><li><p>nice命令</p><p>功能：指定将要启动进程的优先级。不指定优先级时默认为0</p><p>命令格式：nice [-n number] command [arg…]</p><p>如: nice -n 10 ls</p><p>​  nice -n 10 more 1.txt</p></li><li><p>renice命令</p><p>功能：修改<strong>运行中的进程</strong>的优先级。即设定指定用户或群组的进程的优先级</p><p>命令格式：renice priority-number [-p PID] [-u user] [-g pgrps]</p><p>主要选项说明：</p><p>-p：进程号，指定指定进程的优先级</p><p>-u：用户号，修改指定用户所启动进程的默认优先级</p><p>-g：组群号，修改指定群组中所有用户所启动进程的默认优先级</p><p>例如：</p><p>​renice -15 -p 2423(PID)</p></li></ol><h2 id="终止进程命令（kill-killall-pkill）">终止进程命令（kill, killall, pkill）</h2><p>功能：杀死进程，同时杀死该进程的所有子进程。</p><p>命令格式：kill [-signal] -PID</p><p>主要选项：</p><p>-l：信号，如果不加信号的编号参数，则使用&quot;-l&quot;参数会列出全部信号</p><p>-a：当处理当前进程时，不限制命令名和进程号的对应关系</p><p>-p：指定kill命令只打印相关进程的进程号，而不发送任何信号</p><p>-s：指定发送信号</p><p>-u：指定用户</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 进程管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c语言 fgets()函数</title>
      <link href="/2021/04/08/c-yu-yan-fgets/"/>
      <url>/2021/04/08/c-yu-yan-fgets/</url>
      
        <content type="html"><![CDATA[<p>fgets函数用于从指定流读取指定字节数的字符，Ascii码字符1个字符占用1个字节，1个汉字占用多少字节因平台而异。</p><p><strong>验证一个汉字占用几个字节：</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> chinese[<span class="number">10</span>] = <span class="string">&quot;中文&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%ld\n&quot;</span>, <span class="built_in">strlen</span>(chinese));</span><br></pre></td></tr></table></figure><span id="more"></span><p>终端输出：6，   表示当前平台一个汉字占用3个字节。</p><h1>函数调用方法</h1><p>char*  fgets(char* str, int num, FILE* stream );</p><h2 id="函数形参">函数形参</h2><ul><li><p>str为目标数组指针</p></li><li><p>num为读取的字符数，包括<strong>换行符</strong>，意味着只能输入(num-1)个Ascii码字符。</p><blockquote><p>输入为英文字符：</p><p>实际能输入(num-1)个字符，最后一个字符保存字符串结束符，即’\0’</p><p>输入为汉字:</p><p>实际能输入(num-1)/3个字符，最后一个字符保存字符串结束符，即’\0’</p><p>混合汉字与英文的输入：</p><p>需满足 (m + n*3 + 1) ⋜ num，其中m为英文字符数，n为中文字符数</p><p>num⋜ sizeof(str)</p></blockquote></li><li><p>stream为输入流</p><blockquote><p>指向作为输入流的FILE对象指针</p><p>传递stdin，表示从标准输入(终端)读取数据</p></blockquote></li></ul><h2 id="函数返回值">函数返回值</h2><p>根据执行结果有以下几种返回情况：</p><ul><li><p>执行成功：返回str</p></li><li><p>执行失败：返回空指针</p><blockquote><p>设置错误指示符：ferror</p><p>例如在调用fgets之后，紧接着执行int ferror（FILE * stream）;</p><ul><li><p>返回非0值，则表示之前对stream流操作失败</p></li><li><p>返回0，表示之前对stream流操作成功</p></li></ul></blockquote></li><li><p>其他情况</p><p><strong>读取过程中，遇到文件结束符号，则设置eof指示符（<a href="https://www.cplusplus.com/feof">feof</a>）并返回str</strong></p><p><strong>未读取到任何字符前遇到文件描述符，返回空指针</strong></p></li></ul><h1>代码示例</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">itoc</span><span class="params">(<span class="type">int</span> num, <span class="type">char</span>* str)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> tem[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> id=<span class="number">0</span>,id2=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t = num % <span class="number">10</span>;</span><br><span class="line">        tem[id++] = t + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        num /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    str[id--] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">while</span> (id &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        str[id2++] = tem[id--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> str[BUF_SIZE];</span><br><span class="line"></span><br><span class="line">    fgets(str,BUF_SIZE, <span class="built_in">stdin</span>);</span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">strlen</span>(str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;str&#x27;length %d\n&quot;</span>, len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入的字符串：%s&quot;</span>,str);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;下标为:%d 字符为%c 字符Ascii为%d\n下标为:%d 字符为%c 字符Ascii为%d\n&quot;</span>, len<span class="number">-1</span>, str[len<span class="number">-1</span>], (<span class="type">int</span>)str[len<span class="number">-1</span>], len, str[len], (<span class="type">int</span>)str[len]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行上述代码：输入hello world</p><p>输出以下内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">str&#x27;length 12</span><br><span class="line">输入的字符串：hello world         #   实际读到的字符串为&quot;hello world\n&quot;</span><br><span class="line">下标为:11 字符为                  #   str[11]为换行符</span><br><span class="line"> 字符Ascii为10                   #   str[12]为行结束符</span><br><span class="line">下标为:12 字符为 字符Ascii为0</span><br></pre></td></tr></table></figure><p>注意：实际输入的字节数，不要超过BUF_SIZE-2，因为还要额外预留两个空间存储换行符和行结束符</p>]]></content>
      
      
      <categories>
          
          <category> cpp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> fgets </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim学习笔记</title>
      <link href="/2021/03/28/vim-xue-xi-bi-ji/"/>
      <url>/2021/03/28/vim-xue-xi-bi-ji/</url>
      
        <content type="html"><![CDATA[<h1>Vim学习笔记(一)</h1><p>使用原厂配置</p><p>Vim -u NONE -N</p><p>-u NONE 让vim启动时不加载vimrc，插件也会被禁用</p><p>-N 不使用vi兼容模式</p><span id="more"></span><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;C-g&gt;显示当前文件名及状态</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;  增加缩进层级</span><br><span class="line">&gt;G 增加从光标开始处到文档末尾的缩进层级</span><br><span class="line">:set hls 查找高亮</span><br><span class="line"></span><br><span class="line">r 替换</span><br></pre></td></tr></table></figure><p>设置自动缩进和换行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">:set shiftwidth=4 softtabstop=4 expandtab</span><br><span class="line">shiftwidth 换行时自动缩进列数</span><br><span class="line">softtabstop 一个制表符插入几个空格</span><br><span class="line">expandtab 选项把插入的 tab 字符替换成特定数目的空格</span><br><span class="line"></span><br><span class="line">tabstop 选项只修改 tab 字符的显示宽度</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="普通模式">普通模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">set nrformats= 默认所有数字都为十进制数</span><br><span class="line">&lt;C-a&gt; 对数字加    10&lt;C-a&gt; 对数字加10</span><br><span class="line">&lt;C-x&gt; 对数字减    10&lt;C-x&gt; 对数字减10</span><br><span class="line"></span><br><span class="line">gg光标回到文件开头</span><br><span class="line">=G 自动缩进从光标位置到文件结尾的所有内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">cw 删除一个单词并进入插入模式</span><br><span class="line"></span><br><span class="line">^ 光标移到行首</span><br><span class="line">$ 光标移到行尾</span><br><span class="line">b 光标移到当前单词开头处</span><br><span class="line"></span><br><span class="line">操作符 + 动作命令 = 操作</span><br><span class="line">(指明操作类型)  (具体的操作行为)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">gu 转小写</span><br><span class="line">gul 光标处字符转小写</span><br><span class="line">guaw 光标处单词转小写</span><br><span class="line">guap 光标处段落转换为小写</span><br><span class="line"></span><br><span class="line">g~ 取反</span><br><span class="line"></span><br><span class="line">gU 转大写</span><br><span class="line"></span><br><span class="line">gUU 作用于当前行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">c 修改</span><br><span class="line">cl 修改一个字符</span><br><span class="line">caw 修改一个单词</span><br><span class="line">cap 修改一个段落</span><br><span class="line"></span><br><span class="line">d 删除操作</span><br><span class="line">dl 字符</span><br><span class="line">daw 单词</span><br><span class="line">dap 一个段落</span><br><span class="line">db 删除从光标起始位置到单词开头的内容</span><br><span class="line"></span><br><span class="line">y 复制</span><br><span class="line">yl 复制一个字符</span><br><span class="line">yaw 复制一个单词</span><br><span class="line">yap 复制一个段落</span><br><span class="line">yt; 从当前光标复制到出现第一个分号前的字符</span><br><span class="line"></span><br><span class="line">f&#123;char&#125; 跳转到某个字符 </span><br><span class="line">; 继续匹配下一个</span><br><span class="line">,继续匹配上一个</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R 进入替换模式</span><br><span class="line">gR虚拟替换 把制表符当作一组空格处理</span><br><span class="line"></span><br><span class="line">替换单个字符</span><br><span class="line">r&#123;char&#125;</span><br><span class="line">gr&#123;char&#125;</span><br><span class="line"></span><br><span class="line">&gt; 增加缩进</span><br><span class="line">&lt; 减小缩进</span><br><span class="line"></span><br><span class="line">= 自动缩进</span><br><span class="line"></span><br><span class="line">!使用外部程序过滤&#123;motion&#125;所跨越的行</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>操作符待决模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dw</span><br><span class="line">输入d进入该模式（只有操作符才能激活待决模式）</span><br><span class="line">输入w退出该模式</span><br></pre></td></tr></table></figure><p>命名空间</p><p>大多数时候第一个按键知识第二个按键的前缀，这些命令不会激活操作符待决模式。可以把它们看成命名空间</p><h2 id="插入模式">插入模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&lt;C-h&gt; 删除前一个字符</span><br><span class="line">&lt;C-w&gt; 删除前一个单词</span><br><span class="line">&lt;C-u&gt; 删除至行首</span><br><span class="line">上述三个命令也适用于bash shell</span><br><span class="line"></span><br><span class="line">&lt;C-r&gt;&lt;C-p&gt;&#123;register&#125; 按原义插入寄存器的文本</span><br><span class="line"></span><br><span class="line">表达式寄存器：</span><br><span class="line">&lt;C-r&gt;= 将表达式的结果插入文本中</span><br><span class="line"></span><br><span class="line">&lt;C-v&gt;&#123;code&#125; 插入某个字符的编码值，编码包含三个值</span><br><span class="line">&lt;C-v&gt;u&#123;1234&#125; 4位16进制数</span><br><span class="line"></span><br><span class="line">&lt;C-k&gt;&#123;char1&#125;&#123;char2&#125; 插入以二合字母&#123;char1&#125;&#123;char2&#125;表示的字符</span><br><span class="line"></span><br><span class="line">使用ga命令显示当前光标处字符的编码,分别以十进制和十六进制表示</span><br><span class="line">:h digraph-table 查看二合字母表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> </span><br></pre></td></tr></table></figure><p>插入-普通模式</p><p>是普通模式的一个特例，让我们执行一次普通模式的命令后又返回插入模式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;C-o&gt;zz 在插入位置重绘屏幕</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="可视模式">可视模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;C-g&gt;在可视模式和选择模式切换</span><br><span class="line">在选择模式输入任意字符，此字符会替换所选字符</span><br><span class="line">在可视模式下，可以用c键来修改所选内容</span><br><span class="line"></span><br><span class="line">v 面向字符</span><br><span class="line">V 面向行</span><br><span class="line">&lt;C-v&gt; 面向列块</span><br><span class="line">gv 重选上次选区</span><br><span class="line">o切换高亮选区的活动端</span><br><span class="line">b键向左移动</span><br><span class="line">e键向右移动</span><br><span class="line"></span><br><span class="line">vit 选择标签的内容</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果有可能，最好用操作符命令，而不是可视命令</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在可视模式中，i和a键沿用一个不同的约定，它们被当作一个文本对象</span><br></pre></td></tr></table></figure><h2 id="命令行模式">命令行模式</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">/ 调出查找命令</span><br><span class="line">&lt;C-r&gt;= 访问表达式寄存器</span><br><span class="line"></span><br><span class="line">:edit 读文件</span><br><span class="line">:write 写文件</span><br><span class="line">:tabnew 创建新标签页</span><br><span class="line">:split 水平分割窗口</span><br><span class="line">:vsplit 垂直分割窗口</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">操作参数列表</span><br><span class="line">:prev</span><br><span class="line">:next</span><br><span class="line"></span><br><span class="line">缓冲区列表</span><br><span class="line">:bprev</span><br><span class="line">:bnext</span><br><span class="line"></span><br><span class="line">p 打印当前行</span><br><span class="line">%p 打印整个文件</span><br><span class="line"></span><br><span class="line">%代表当前文件的所有行</span><br><span class="line"></span><br><span class="line">/&lt;html&gt;/,/&lt;\/html&gt;/p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">t等价于copy</span><br><span class="line">:6t. 第6行复制到当前行下方</span><br><span class="line">:t6  把当前行复制到第6行下方</span><br><span class="line"></span><br><span class="line">t. 等价于yyp </span><br><span class="line">yyp会使用默认寄存器</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x27;&lt;,&#x27;&gt;m$ 等价于dGp</span><br><span class="line"></span><br><span class="line">@: 重复上一次的Ex命令</span><br><span class="line"></span><br><span class="line">[range] normal. 在range范围执行普通模式下的.命令</span><br><span class="line"></span><br><span class="line">%normal A; 在文件的所有行执行普通模式的A ;</span><br><span class="line"></span><br><span class="line">&lt;C-o&gt; 回到跳转列表的上条记录</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//设置使用bash 的命令补全</span><br><span class="line">set wildmode=longest,list</span><br><span class="line"></span><br><span class="line">:shell</span><br><span class="line">exit 退出shell</span><br><span class="line"></span><br><span class="line">:%s//counter/g</span><br><span class="line">把匹配项替换为counter g指代所有匹配项都替换</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">history.vim</span><br><span class="line">cnoremap &lt;C-p&gt; &lt;Up&gt;</span><br><span class="line">cnoremap &lt;C-n&gt; &lt;Down&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;C-z&gt; 关起vim</span><br><span class="line"></span><br><span class="line">jobs 查看挂起的作业</span><br><span class="line"></span><br><span class="line">fg 用来唤醒挂起的作业</span><br><span class="line"></span><br><span class="line">把缓冲区内容作为标准输入或输出</span><br><span class="line">:read !&#123;cmd&#125; 把cmd输出写入当前缓冲区</span><br><span class="line">:write !&#123;cmd&#125; 把缓冲区内容作为cmd的标准输入</span><br><span class="line"></span><br><span class="line">:write! sh把缓冲区的内容写入一个名为sh的文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1>Vim学习笔记(二)</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:ls</span><br><span class="line"></span><br><span class="line">% 哪个缓冲区在当前窗口可见</span><br><span class="line"></span><br><span class="line">#  轮换文件  &lt;C-^&gt; 轮换文件</span><br></pre></td></tr></table></figure><h2 id="缓冲区">缓冲区</h2><p>缓冲区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:w 把缓冲区内容写入磁盘</span><br><span class="line">:edit!  回滚所做修改</span><br><span class="line">:qall!  关闭所有窗口，放弃所有修改</span><br><span class="line">:wall! 把所有改变写入磁盘</span><br></pre></td></tr></table></figure><p>缓冲区移动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">:bnext 下一个  简写 bn</span><br><span class="line">:bprev 上一个      bp</span><br><span class="line"></span><br><span class="line">:bfirst 第一个     bf</span><br><span class="line">:blast 最后一个    bl</span><br><span class="line"></span><br><span class="line">:b 数字编号</span><br><span class="line"></span><br><span class="line">:bufdo ex命令 在所有缓冲期上执行EX命令 </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>缓冲区删除</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:1,3bd</span><br><span class="line">:bd 1 2 3 </span><br></pre></td></tr></table></figure><h2 id="参数列表">参数列表</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:args *.*  当前目录加入参数列表</span><br><span class="line">:args **/*.js  递归进入指定目录的子目录</span><br><span class="line">:args **/*.*</span><br><span class="line"></span><br><span class="line">:args `cat .chapters` </span><br></pre></td></tr></table></figure><p>遍历参数列表文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:next</span><br><span class="line">:preve</span><br></pre></td></tr></table></figure><p>设置隐藏缓冲区</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:set hidden</span><br><span class="line">运行 argdo 和 bufdo 前，启用hidden设置</span><br></pre></td></tr></table></figure><h2 id="窗口">窗口</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">设置当前窗口的本地工作目录 </span><br><span class="line">:lcn &#123;path&#125;</span><br><span class="line"></span><br><span class="line">当包含子窗口时</span><br><span class="line">:windo lcd &#123;path&#125; 为所有窗口设置本地工作目录</span><br></pre></td></tr></table></figure><p>子窗口开启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;C-w&gt;s  水平切分此窗口  等价于 :splist &#123;file&#125; 并在窗口中载入file</span><br><span class="line">&lt;C-w&gt;v  垂直切分此窗口  等价于 :vsplit &#123;file&#125; 并在窗口中载入file</span><br><span class="line">生成的子窗口和原窗口显示相同的缓冲区</span><br></pre></td></tr></table></figure><p>窗口移动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;C-w&gt;w  在窗口间循环移动</span><br><span class="line">&lt;C-w&gt;h  切换到左边窗口</span><br><span class="line">&lt;C-w&gt;j  切换到下边窗口</span><br><span class="line">&lt;C-w&gt;k  切换到上边窗口</span><br><span class="line">&lt;C-w&gt;l  切换到右边窗口</span><br></pre></td></tr></table></figure><p>窗口关闭</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;close&gt;  关闭活动窗口</span><br><span class="line">:only    只保留活动窗口</span><br></pre></td></tr></table></figure><p>窗口大小及排列</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;C-w&gt;=  使所有窗口等宽，等高</span><br><span class="line">&lt;C-w&gt;_  最大化活动窗口的高度</span><br><span class="line">&lt;C-w&gt;|  最大化活动窗口的宽度</span><br><span class="line">[n]&lt;C-w&gt;_  把活动窗口的高度设为n行</span><br><span class="line">[n]&lt;C-w&gt;|  把活动窗口的宽度设为n列</span><br></pre></td></tr></table></figure><h2 id="标齐页">标齐页</h2><p>打开/关闭标签页</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">:tabe[dit] &#123;filename&#125; 新建标签页，并在其中打开filename</span><br><span class="line">&lt;C-w&gt;T 把当前窗口移到一个新标签页</span><br><span class="line">:tabc[close] 关闭当前标签页及其中所有窗口</span><br><span class="line">:tabo[nly]   只保留活动标签页，关闭所有其它标签页</span><br></pre></td></tr></table></figure><p>标签页跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;n&#125;gt 跳转到标签页n    等价ex命令    :tabn[ext] &#123;n&#125;</span><br><span class="line">gt 跳转到下一个标签页   等价ex命令    :tabn[ext]</span><br><span class="line">gT 跳转到上一个标签页   等价ex命令    :tabp[revious]</span><br></pre></td></tr></table></figure><p>标签页重排</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:tabmove [n] </span><br><span class="line">n为0，当前标签页移到开头</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用edit打开文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:edit %:h &lt;table&gt; %代表活动区缓冲区的文件路径</span><br><span class="line">cnoremap&lt;expr&gt; %% getcmdtype()==&#x27;:&#x27;?expand(&#x27;%:h&#x27;).&#x27;/&#x27;:&#x27;%%&#x27;</span><br></pre></td></tr></table></figure><p>find打开文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:set path+=app/**</span><br></pre></td></tr></table></figure><h2 id="netrw文件管理系统">netrw文件管理系统</h2><p>vim . 打开当前所在目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:e 目录地址 缺省为当前目录</span><br><span class="line">:E 显示活动缓冲区所在目录</span><br><span class="line"></span><br><span class="line">:Se   水平切分窗口</span><br><span class="line">:Ve   垂直切分窗口</span><br></pre></td></tr></table></figure><p>将文件保存到不存在的目录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:!mkdir -p %:h -p蚕食使mkdir创建任何不存在的中间目录  %:h 相对于缓冲区的路径</span><br></pre></td></tr></table></figure><p>以root用户写入文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">:w !sodu tee % &gt; /dev/nulll </span><br><span class="line">tee以root权限运行</span><br><span class="line">%在vim命令行模式中指当前文件的完整路径</span><br></pre></td></tr></table></figure><h1>Vim学习笔记(三)</h1><h2 id="关标移动">关标移动</h2><table><thead><tr><th>命令</th><th>光标动作</th></tr></thead><tbody><tr><td>gj</td><td>向下移动一个屏幕行</td></tr><tr><td>gk</td><td>向上移动一个屏幕行</td></tr><tr><td>0</td><td>移动到实际行行首</td></tr><tr><td>g0</td><td>移动到屏幕行行首</td></tr><tr><td>$</td><td>移动到实际行行尾</td></tr><tr><td>g$</td><td>移动到屏幕行行尾</td></tr><tr><td>^</td><td>移动到实际行的第一个非空白字符</td></tr><tr><td>g^</td><td>移动到屏幕行的第一个非空白字符</td></tr></tbody></table><p>基于单词移动</p><table><thead><tr><th>命令</th><th>光标动作</th></tr></thead><tbody><tr><td>w</td><td>正向移动到下一个单词的开头</td></tr><tr><td>W</td><td>正向移动到下一个字串开头</td></tr><tr><td>b</td><td>反向移动到当前单词/上一个单词开头</td></tr><tr><td>e</td><td>正向移动到当前单词/下一个单词结尾</td></tr><tr><td>ge</td><td>反向移动到上一个单词的结尾</td></tr></tbody></table><h2 id="字符查找">字符查找</h2><table><thead><tr><th>命令</th><th>光标动作</th></tr></thead><tbody><tr><td>f字符</td><td>查找字符</td></tr><tr><td>F字符</td><td>反向查找字符</td></tr><tr><td>t字符</td><td>移动到下一个字符之处前一个字符上</td></tr><tr><td>T字符</td><td>移动到上一个字符之处后一个字符上</td></tr><tr><td>;</td><td>重复上次的字符查找命令</td></tr><tr><td>,</td><td>上一个匹配位置</td></tr></tbody></table><p>d与查找结合</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dt, 删除从当前字符开始到第一个,处</span><br></pre></td></tr></table></figure><p>通过查找移动</p><table><thead><tr><th>命令</th><th>光标动作</th></tr></thead><tbody><tr><td>v</td><td>进入可视模式</td></tr><tr><td>/字串</td><td>选中当前光标所在位置到查找到的字符光标之前的所有字符</td></tr></tbody></table><p>用文本对象选择选区</p><table><thead><tr><th>vi}</th><th>选中{}直接的内容</th></tr></thead><tbody><tr><td>a&quot;</td><td>选中&quot;之间的内容，包括&quot;</td></tr><tr><td>i&gt;</td><td>选中&lt;&gt;之间的内容</td></tr><tr><td>it</td><td>选中XML标签之间的内容</td></tr><tr><td>ci&quot;</td><td>删除&quot;&quot;之间的内容，并进入插入模式</td></tr></tbody></table><p>文本对象</p><table><thead><tr><th>文本对象</th><th>选择范围</th></tr></thead><tbody><tr><td>iw</td><td>当前单词</td></tr><tr><td>aw</td><td>当前单词及一个空格</td></tr><tr><td>iW</td><td>当前字串</td></tr><tr><td>aW</td><td>当前字串及一个空格</td></tr><tr><td>is</td><td>当前句子</td></tr><tr><td>as</td><td>当前句子及一个空格</td></tr><tr><td>ip</td><td>当前段落</td></tr><tr><td>ap</td><td>当前段落及一个空行</td></tr></tbody></table><p>设置位置标记</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">m&#123;a-zA-Z&#125;  标记当前位置</span><br><span class="line">`&#123;mark&#125;</span><br></pre></td></tr></table></figure><p>Vim自动标记位置</p><table><thead><tr><th>位置标记</th><th>跳转到</th></tr></thead><tbody><tr><td>``</td><td>当前文件中上次跳转动作之前的位置</td></tr><tr><td>`.</td><td>上次修改的地方</td></tr><tr><td>`^</td><td>上次插入的地方</td></tr><tr><td>`[</td><td>上次修改或复制的起始位置</td></tr><tr><td>`]</td><td>上次修改或复制的结束位置</td></tr><tr><td>`&lt;</td><td>上次高亮选区的起始位置</td></tr><tr><td>`&gt;</td><td>上次高亮或选区的结束位置</td></tr></tbody></table><p>匹配括号间跳转</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">% 在匹配括号间跳转</span><br></pre></td></tr></table></figure><p>surround.vim</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p ~/.vim/pack/tpope/start</span><br><span class="line">cd ~/.vim/pack/tpope/start</span><br><span class="line">git clone https://tpope.io/vim/surround.git</span><br><span class="line">vim -u NONE -c &quot;helptags surround/doc&quot; -c q</span><br></pre></td></tr></table></figure><table><thead><tr><th>按键</th><th>结果</th></tr></thead><tbody><tr><td>S&quot;</td><td>将选中文字添加&quot;</td></tr><tr><td>cs]}</td><td>将匹配的括号[] 替换为 {}</td></tr></tbody></table><h2 id="跳转动作">跳转动作</h2><p><code>&lt;c-o&gt; &lt;c-i&gt;</code></p><table><thead><tr><th>命令</th><th>用途</th></tr></thead><tbody><tr><td>[count]G</td><td>跳转到指定行号</td></tr><tr><td><code>/pattern&lt;CR&gt;/?pattern&lt;CR&gt;/n/N</code></td><td>跳转到下一个/上一个模式出现处</td></tr><tr><td>%</td><td>跳转到匹配的括号所在处</td></tr><tr><td>(/)</td><td>跳转到上一句/下一句开头</td></tr><tr><td>{/}</td><td>跳转到上一段/下一段开头</td></tr><tr><td>H/M/L</td><td>跳转到屏幕最上方/正中间/最下方</td></tr><tr><td>gf</td><td>跳转到关标下的文件名</td></tr><tr><td>&lt;C-]&gt;</td><td>跳转到关标下关键字的定义之处</td></tr><tr><td>`{mark}/'{mark}</td><td>跳转到位置标记</td></tr></tbody></table><h2 id="遍历改变的列表">遍历改变的列表</h2><table><thead><tr><th>命令</th><th>跳转位置</th></tr></thead><tbody><tr><td>g;</td><td>下一个跳转位置</td></tr><tr><td>g,</td><td>上一个跳转位置</td></tr><tr><td>gi 等价于 `^</td><td>跳转到上次插入的位置</td></tr></tbody></table><p>跳转到文件中的指定文件名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">set suffixesadd+=.rb</span><br><span class="line">gf 跳转到指定路径</span><br><span class="line">&lt;C-o&gt; 返回</span><br><span class="line"></span><br><span class="line">查看当前工作目录</span><br><span class="line">:set path?</span><br><span class="line">path=.,/usr/include,,</span><br><span class="line">.代表当前文件所在目录</span><br><span class="line">空字符代表工作目录</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="标记">标记</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m&#123;A-Z&#125;  `&#123;A-Z&#125;  在文件间跳转</span><br></pre></td></tr></table></figure><p>mkdir mydir</p><p>cd mydir</p><p>vim f1</p><p>yy</p><p>9p</p><p>rm f1</p><p>find . -name “f1” -exec rm {} ;</p><h1>Vim学习笔记(四)</h1><h2 id="寄存器">寄存器</h2><p>无名寄存器</p><p>对文本进行d与y操作，默认会把操作内容存到到无名寄存器</p><p>用p粘贴文本时，默认粘贴无名寄存器的内容</p><p>{a-z} 对应26个寄存器</p><p>使用时，例如</p><p>“ayiw 复制关标所在处的单词到寄存器a</p><p>&quot;ap 将a中的内容粘贴至光标之前</p><p>黑洞寄存器</p><p>&quot;_ 彻底删除</p><p>“+ 系统剪切板</p><p>&quot;* 主剪切板</p><p>&quot;0无名寄存器</p><p>其它寄存器</p><table><thead><tr><th>寄存器</th><th>内容</th></tr></thead><tbody><tr><td>&quot;%</td><td>当前文件名</td></tr><tr><td>&quot;#</td><td>轮换文件名</td></tr><tr><td>&quot;.</td><td>上次插入的文本</td></tr><tr><td>&quot;:</td><td>上次执行的Ex命令</td></tr><tr><td>&quot;/</td><td>上次查找的模式</td></tr></tbody></table><h2 id="宏">宏</h2><p>q+{a-z} 开始录制</p><p>q 结束录制</p><p>@{a-z} 执行宏</p><p>3@a 执行三次宏</p><p>Normal @a 在所有文件列表上执行宏a</p><h2 id="设置变量，并给变量赋值">设置变量，并给变量赋值</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:let i=1</span><br><span class="line">:let i+=1 递增i，并把i赋给新i</span><br></pre></td></tr></table></figure><h2 id="给宏附加指令">给宏附加指令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">q+&#123;A-Z&#125; 开始录制</span><br><span class="line"></span><br><span class="line">q 结束录制</span><br></pre></td></tr></table></figure><h1>Vim学习笔记(五) 模式</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\c 忽略大小写查找</span><br><span class="line">\C 强制区分大小写</span><br><span class="line"></span><br><span class="line">ignorecase 不区分大小写</span><br><span class="line">smartcase 当匹配小写字母时，不区分大小写，当匹配大写字母时区分大小写</span><br></pre></td></tr></table></figure><p>若用正则表达式查找，用\v模式开工</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">body   &#123; color: #3c3c3c; &#125;</span><br><span class="line">a      &#123; color: #0000EE; &#125;</span><br><span class="line">strong &#123; color: #000; &#125;</span><br><span class="line"></span><br><span class="line">/\v#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)</span><br><span class="line">使用\x代替字符集[0-9a-fA-F]</span><br><span class="line">/\v#(\x&#123;6&#125;|\x&#123;3&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>按原义查找文本 \V</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/\Va.k.a</span><br></pre></td></tr></table></figure><p>匹配重复单词</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/\v&lt;(\w+)\_s+\1&gt;</span><br><span class="line"></span><br><span class="line">\w匹配单词类字符，包括字母，数字以及符号“_”</span><br><span class="line">\W匹配除单词类字符以外的其它字符</span><br></pre></td></tr></table></figure><p>界定单词边界</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/\v&lt;the&gt;  这时只会匹配the，而不会匹配them their</span><br><span class="line"></span><br><span class="line">使用圆括号，但不匹配其内容</span><br><span class="line">/\v(W|w)angjun  可以匹配wangjun，也可以匹配Wangjun</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">将指定的名字的姓和名跌倒顺序</span><br><span class="line">/\v(%(W|w)ang) (jun)  任何用圆括号内部的匹配文本都会被保存到一个临时仓库 有多个括号 依次用\1 \2 \3存储 </span><br><span class="line">\0永远会引用整个匹配</span><br><span class="line">:%s//\2,\1/g</span><br></pre></td></tr></table></figure><h2 id="界定匹配的边界">界定匹配的边界</h2><p>\zs 开始</p><p>\ze 结尾</p><h2 id="转义问题字符">转义问题字符</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">http://vimdoc.net/search?q=/\\</span><br><span class="line">当要查找上述地址时，/和\都属于特殊字符，需要进行转移</span><br><span class="line"></span><br><span class="line">当正向查找时：/http:\/\/vimdoc.net\/search?q=\/\\\\</span><br><span class="line">当反向查找时：?http://vimdoc.net/search?q=/\\</span><br><span class="line"></span><br><span class="line">库函数实现自动转义</span><br><span class="line">正向查找时 escape(@u,&#x27;/\&#x27;) 他会为每个/\加上反斜杠前缀</span><br><span class="line">反向查找，escape(@u,&#x27;?\&#x27;) ?会当作查找域的结束符</span><br></pre></td></tr></table></figure><p>查找高亮</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">set hlsearch</span><br><span class="line">关闭高亮 </span><br><span class="line">set nohlsearch</span><br><span class="line"></span><br><span class="line">设置快捷键短暂关闭高亮</span><br><span class="line">nnoremap &lt;silent&gt; &lt;C-l&gt; : &lt;C-u&gt; nohlsearch&lt;CR&gt;&lt;Cl&gt;  对应快捷键&lt;C-u&gt;&lt;C-l&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>执行查找前预览第一处匹配</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set incsearch</span><br><span class="line"></span><br><span class="line">在按回车键时如果按esc键则回到原位</span><br><span class="line"></span><br><span class="line">&lt;C-r&gt;&lt;C-w&gt; 粘贴刚刚匹配的单词</span><br></pre></td></tr></table></figure><p>匹配当前模式的匹配个数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:%s///gn</span><br></pre></td></tr></table></figure><p>将光标移到查找匹配的结尾</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/lang/e lang为待查找的词</span><br><span class="line">//e 重用上一次查找模式</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
            <tag> 模式 </tag>
            
            <tag> 缓冲区 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>取余和取模运算区别</title>
      <link href="/2021/03/23/qu-yu-he-qu-mo-yun-suan-qu-bie/"/>
      <url>/2021/03/23/qu-yu-he-qu-mo-yun-suan-qu-bie/</url>
      
        <content type="html"><![CDATA[<h1>相同点</h1><p><strong>取余和取模当商为正数时是一致的，区别在于商为负数时</strong><br>取余或取模的计算公式：<br>例如求 c = a%b</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">先求整数商x</span><br><span class="line">第一步：x = [a÷b]</span><br><span class="line">第二步：c = a - x*b</span><br></pre></td></tr></table></figure><p>取余和取模的区别在于第一步，第二步一样。</p><h1>不同点</h1><p>x = [a÷b]<br>取余时：x向0取整<br>取模时：x向-∞取整</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">-7/4=-1.75</span><br><span class="line">取余时：x=-1  余数为：-3</span><br><span class="line">取模时：x=-2  模数为：1</span><br></pre></td></tr></table></figure><p><strong>关于取余运算符(%)</strong><br>在c/c++, java环境下为取余<br>在python环境下为取模</p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 取余 </tag>
            
            <tag> 取模 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
